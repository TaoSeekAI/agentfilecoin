import { toHex } from 'multiformats/bytes';
export class PDPUploadService {
    apiEndpoint;
    serviceName;
    constructor(apiEndpoint, serviceName = 'public') {
        if (apiEndpoint === '') {
            throw new Error('PDP API endpoint is required');
        }
        this.apiEndpoint = apiEndpoint.endsWith('/') ? apiEndpoint.slice(0, -1) : apiEndpoint;
        this.serviceName = serviceName;
    }
    async upload(data, commp) {
        const bytes = data instanceof ArrayBuffer ? new Uint8Array(data) : data;
        const byteLength = bytes.length;
        const uploadId = await this._createUpload(commp, byteLength);
        await this._uploadData(uploadId, bytes);
    }
    async _createUpload(commp, byteLength) {
        const hashBytes = commp.multihash.digest;
        const hashHex = toHex(hashBytes);
        const checkData = {
            name: 'sha2-256-trunc254-padded',
            hash: hashHex,
            size: byteLength
        };
        const requestBody = {
            check: checkData
        };
        const response = await fetch(`${this.apiEndpoint}/pdp/piece`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });
        if (response.status === 200) {
            const data = await response.json();
            console.log(`Piece already exists on server: ${data.pieceCID}`);
            return '';
        }
        if (response.status !== 201) {
            const errorText = await response.text();
            throw new Error(`Failed to create upload: ${response.status} ${response.statusText} - ${errorText}`);
        }
        const location = response.headers.get('Location');
        if (location == null) {
            throw new Error('Server did not provide Location header in response (may be restricted by CORS policy)');
        }
        const locationMatch = location.match(/\/(?:pdp\/)?piece\/upload\/([a-fA-F0-9-]+)/);
        if (locationMatch == null) {
            throw new Error(`Invalid Location header format: ${location}`);
        }
        return locationMatch[1];
    }
    async _uploadData(uploadId, data) {
        if (uploadId === '') {
            return;
        }
        const uploadUrl = `${this.apiEndpoint}/pdp/piece/upload/${uploadId}`;
        const response = await fetch(uploadUrl, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/octet-stream',
                'Content-Length': data.length.toString()
            },
            body: data
        });
        if (response.status !== 204) {
            const errorText = await response.text();
            throw new Error(`Failed to upload data: ${response.status} ${response.statusText} - ${errorText}`);
        }
    }
    getServiceName() {
        return this.serviceName;
    }
    getApiEndpoint() {
        return this.apiEndpoint;
    }
}
//# sourceMappingURL=upload-service.js.map