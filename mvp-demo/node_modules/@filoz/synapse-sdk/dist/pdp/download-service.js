import { asCommP, createCommPStream } from '../commp/index.js';
export class PDPDownloadService {
    retrievalUrl;
    constructor(retrievalUrl) {
        if (retrievalUrl === '') {
            throw new Error('Retrieval URL is required');
        }
        this.retrievalUrl = retrievalUrl.endsWith('/') ? retrievalUrl.slice(0, -1) : retrievalUrl;
    }
    async downloadPiece(commp) {
        const normalizedCommP = asCommP(commp);
        if (normalizedCommP == null) {
            throw new Error('Invalid CommP provided');
        }
        const downloadUrl = `${this.retrievalUrl}/piece/${normalizedCommP.toString()}`;
        const response = await fetch(downloadUrl, {
            method: 'GET',
            headers: {
                Accept: 'application/octet-stream'
            }
        });
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Failed to download piece: ${response.status} ${response.statusText} - ${errorText}`);
        }
        if (response.body == null) {
            throw new Error('Response body is null');
        }
        console.log('Streaming and verifying downloaded data...');
        const { stream: commpStream, getCommP } = createCommPStream();
        const chunks = [];
        const collectStream = new TransformStream({
            transform(chunk, controller) {
                chunks.push(chunk);
                controller.enqueue(chunk);
            }
        });
        const pipelineStream = response.body
            .pipeThrough(commpStream)
            .pipeThrough(collectStream);
        const reader = pipelineStream.getReader();
        try {
            while (true) {
                const { done } = await reader.read();
                if (done)
                    break;
            }
        }
        finally {
            reader.releaseLock();
        }
        const calculatedCommP = getCommP();
        if (calculatedCommP == null) {
            throw new Error('Failed to calculate CommP from stream');
        }
        if (calculatedCommP.toString() !== normalizedCommP.toString()) {
            throw new Error(`CommP verification failed. Expected: ${normalizedCommP.toString()}, Got: ${calculatedCommP.toString()}`);
        }
        console.log('âœ… CommP verification successful');
        const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
        const result = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of chunks) {
            result.set(chunk, offset);
            offset += chunk.length;
        }
        return result;
    }
    getRetrievalUrl() {
        return this.retrievalUrl;
    }
}
//# sourceMappingURL=download-service.js.map