!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("ethers")):"function"==typeof define&&define.amd?define("SynapseSDK",["ethers"],t):"object"==typeof exports?exports.SynapseSDK=t(require("ethers")):e.SynapseSDK=t(e.ethers)}(this,(e=>(()=>{"use strict";var t={320:t=>{t.exports=e}},n={};function r(e){var o=n[e];if(void 0!==o)return o.exports;var i=n[e]={exports:{}};return t[e](i,i.exports,r),i.exports}r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var o={};r.d(o,{default:()=>qn});var i={};r.r(i),r.d(i,{code:()=>Ie,digest:()=>Ue,name:()=>ke,size:()=>Ee});var s={};r.r(s),r.d(s,{computeNode:()=>Gt,create:()=>Jt,depth:()=>Ot,from:()=>Yt,offset:()=>zt,path:()=>jt,resolveRoot:()=>Wt,truncate:()=>Kt,truncatedHash:()=>qt,validateLevelIndex:()=>Qt,verify:()=>Ht});var a={};r.r(a),r.d(a,{tD:()=>bn,y1:()=>vn});var c={};r.r(c),r.d(c,{FIL_COMMITMENT_UNSEALED:()=>kn,SHA2_256_TRUNC254_PADDED:()=>En,asCommP:()=>Pn,calculate:()=>In,createCommPStream:()=>_n,toZeroPaddedSize:()=>Dn});var u={};r.r(u),r.d(u,{PDPAuthHelper:()=>Tn,PDPDownloadService:()=>Mn,PDPTool:()=>Nn,PDPUploadService:()=>$n,StorageProviderTool:()=>Hn});var l={};r.r(l),r.d(l,{CHAIN_IDS:()=>Ln,CONTRACT_ABIS:()=>jn,CONTRACT_ADDRESSES:()=>On,MockStorageService:()=>xn,MockUploadTask:()=>ee,RPC_URLS:()=>zn,Synapse:()=>Wn,SynapsePayments:()=>Vn,TOKENS:()=>Fn,createError:()=>Rn});var d=r(320);function h(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0}function f(e){if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")}new Uint8Array(0);const p=function(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var n=new Uint8Array(256),r=0;r<n.length;r++)n[r]=255;for(var o=0;o<e.length;o++){var i=e.charAt(o),s=i.charCodeAt(0);if(255!==n[s])throw new TypeError(i+" is ambiguous");n[s]=o}var a=e.length,c=e.charAt(0),u=Math.log(a)/Math.log(256),l=Math.log(256)/Math.log(a);function d(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var r=0,o=0;e[t]===c;)r++,t++;for(var i=(e.length-t)*u+1>>>0,s=new Uint8Array(i);e[t];){var l=n[e.charCodeAt(t)];if(255===l)return;for(var d=0,h=i-1;(0!==l||d<o)&&-1!==h;h--,d++)l+=a*s[h]>>>0,s[h]=l%256>>>0,l=l/256>>>0;if(0!==l)throw new Error("Non-zero carry");o=d,t++}if(" "!==e[t]){for(var f=i-o;f!==i&&0===s[f];)f++;for(var p=new Uint8Array(r+(i-f)),g=r;f!==i;)p[g++]=s[f++];return p}}}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var n=0,r=0,o=0,i=t.length;o!==i&&0===t[o];)o++,n++;for(var s=(i-o)*l+1>>>0,u=new Uint8Array(s);o!==i;){for(var d=t[o],h=0,f=s-1;(0!==d||h<r)&&-1!==f;f--,h++)d+=256*u[f]>>>0,u[f]=d%a>>>0,d=d/a>>>0;if(0!==d)throw new Error("Non-zero carry");r=h,o++}for(var p=s-r;p!==s&&0===u[p];)p++;for(var g=c.repeat(n);p<s;++p)g+=e.charAt(u[p]);return g},decodeUnsafe:d,decode:function(e){var n=d(e);if(n)return n;throw new Error(`Non-${t} character`)}}};class g{name;prefix;baseEncode;constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class w{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,n){this.name=e,this.prefix=t;const r=t.codePointAt(0);if(void 0===r)throw new Error("Invalid prefix character");this.prefixCodePoint=r,this.baseDecode=n}decode(e){if("string"==typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return m(this,e)}}class y{decoders;constructor(e){this.decoders=e}or(e){return m(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(null!=n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function m(e,t){return new y({...e.decoders??{[e.prefix]:e},...t.decoders??{[t.prefix]:t}})}class b{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,n,r){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=r,this.encoder=new g(e,t,n),this.decoder=new w(e,t,r)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function v({name:e,prefix:t,encode:n,decode:r}){return new b(e,t,n,r)}function S({name:e,prefix:t,alphabet:n}){const{encode:r,decode:o}=p(n,e);return v({prefix:t,name:e,encode:r,decode:e=>f(o(e))})}function C({name:e,prefix:t,bitsPerChar:n,alphabet:r}){const o=function(e){const t={};for(let n=0;n<e.length;++n)t[e[n]]=n;return t}(r);return v({prefix:t,name:e,encode:e=>function(e,t,n){const r="="===t[t.length-1],o=(1<<n)-1;let i="",s=0,a=0;for(let r=0;r<e.length;++r)for(a=a<<8|e[r],s+=8;s>n;)s-=n,i+=t[o&a>>s];if(0!==s&&(i+=t[o&a<<n-s]),r)for(;i.length*n&7;)i+="=";return i}(e,r,n),decode:t=>function(e,t,n,r){let o=e.length;for(;"="===e[o-1];)--o;const i=new Uint8Array(o*n/8|0);let s=0,a=0,c=0;for(let u=0;u<o;++u){const o=t[e[u]];if(void 0===o)throw new SyntaxError(`Non-${r} character`);a=a<<n|o,s+=n,s>=8&&(s-=8,i[c++]=255&a>>s)}if(s>=n||255&a<<8-s)throw new SyntaxError("Unexpected end of data");return i}(t,o,n,e)})}const A=C({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),k=(C({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),C({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),C({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),C({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),C({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),C({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),C({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),C({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),S({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"})),E=(S({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),S({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}));S({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var D=128,P=-128,U=Math.pow(2,31),I=128,_=127,x=Math.pow(2,7),$=Math.pow(2,14),M=Math.pow(2,21),B=Math.pow(2,28),T=Math.pow(2,35),N=Math.pow(2,42),R=Math.pow(2,49),F=Math.pow(2,56),L=Math.pow(2,63);const j={encode:function e(t,n,r){n=n||[];for(var o=r=r||0;t>=U;)n[r++]=255&t|D,t/=128;for(;t&P;)n[r++]=255&t|D,t>>>=7;return n[r]=0|t,e.bytes=r-o+1,n},decode:function e(t,n){var r,o=0,i=(n=n||0,0),s=n,a=t.length;do{if(s>=a)throw e.bytes=0,new RangeError("Could not decode varint");r=t[s++],o+=i<28?(r&_)<<i:(r&_)*Math.pow(2,i),i+=7}while(r>=I);return e.bytes=s-n,o},encodingLength:function(e){return e<x?1:e<$?2:e<M?3:e<B?4:e<T?5:e<N?6:e<R?7:e<F?8:e<L?9:10}};function z(e,t=0){return[j.decode(e,t),j.decode.bytes]}function O(e,t,n=0){return j.encode(e,t,n),t}function H(e){return j.encodingLength(e)}function V(e,t){const n=t.byteLength,r=H(e),o=r+H(n),i=new Uint8Array(o+n);return O(e,i,0),O(n,i,r),i.set(t,o),new W(e,n,t,i)}class W{code;size;digest;bytes;constructor(e,t,n,r){this.code=e,this.size=t,this.digest=n,this.bytes=r}}function q(e,t){const{bytes:n,version:r}=e;return 0===r?function(e,t,n){const{prefix:r}=n;if(r!==E.prefix)throw Error(`Cannot string encode V0 in ${n.name} encoding`);const o=t.get(r);if(null==o){const o=n.encode(e).slice(1);return t.set(r,o),o}return o}(n,K(e),t??E.encoder):function(e,t,n){const{prefix:r}=n,o=t.get(r);if(null==o){const o=n.encode(e);return t.set(r,o),o}return o}(n,K(e),t??A.encoder)}const G=new WeakMap;function K(e){const t=G.get(e);if(null==t){const t=new Map;return G.set(e,t),t}return t}class J{code;version;multihash;bytes;"/";constructor(e,t,n,r){this.code=t,this.version=e,this.multihash=n,this.bytes=r,this["/"]=r}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==Y)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==Q)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return J.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=V(e,t);return J.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return J.equals(this,e)}static equals(e,t){const n=t;return null!=n&&e.code===n.code&&e.version===n.version&&function(e,t){if(e===t)return!0;{const n=t;return e.code===n.code&&e.size===n.size&&n.bytes instanceof Uint8Array&&h(e.bytes,n.bytes)}}(e.multihash,n.multihash)}toString(e){return q(this,e)}toJSON(){return{"/":q(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(null==e)return null;const t=e;if(t instanceof J)return t;if(null!=t["/"]&&t["/"]===t.bytes||t.asCID===t){const{version:e,code:n,multihash:r,bytes:o}=t;return new J(e,n,r,o??Z(e,n,r.bytes))}if(!0===t[X]){const{version:e,multihash:n,code:r}=t,o=function(e){const t=f(e),[n,r]=z(t),[o,i]=z(t.subarray(r)),s=t.subarray(r+i);if(s.byteLength!==o)throw new Error("Incorrect length");return new W(n,o,s,t)}(n);return J.create(e,r,o)}return null}static create(e,t,n){if("number"!=typeof t)throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:if(t!==Y)throw new Error(`Version 0 CID must use dag-pb (code: ${Y}) block encoding`);return new J(e,t,n,n.bytes);case 1:{const r=Z(e,t,n.bytes);return new J(e,t,n,r)}default:throw new Error("Invalid version")}}static createV0(e){return J.create(0,Y,e)}static createV1(e,t){return J.create(1,e,t)}static decode(e){const[t,n]=J.decodeFirst(e);if(0!==n.length)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=J.inspectBytes(e),n=t.size-t.multihashSize,r=f(e.subarray(n,n+t.multihashSize));if(r.byteLength!==t.multihashSize)throw new Error("Incorrect length");const o=r.subarray(t.multihashSize-t.digestSize),i=new W(t.multihashCode,t.digestSize,o,r);return[0===t.version?J.createV0(i):J.createV1(t.codec,i),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[n,r]=z(e.subarray(t));return t+=r,n};let r=n(),o=Y;if(18===r?(r=0,t=0):o=n(),0!==r&&1!==r)throw new RangeError(`Invalid CID version ${r}`);const i=t,s=n(),a=n(),c=t+a;return{version:r,codec:o,multihashCode:s,digestSize:a,multihashSize:c-i,size:c}}static parse(e,t){const[n,r]=function(e,t){switch(e[0]){case"Q":{const n=t??E;return[E.prefix,n.decode(`${E.prefix}${e}`)]}case E.prefix:{const n=t??E;return[E.prefix,n.decode(e)]}case A.prefix:{const n=t??A;return[A.prefix,n.decode(e)]}case k.prefix:{const n=t??k;return[k.prefix,n.decode(e)]}default:if(null==t)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}}(e,t),o=J.decode(r);if(0===o.version&&"Q"!==e[0])throw Error("Version 0 CID string must not include multibase prefix");return K(o).set(n,e),o}}const Y=112,Q=18;function Z(e,t,n){const r=H(e),o=r+H(t),i=new Uint8Array(o+n.byteLength);return O(e,i,0),O(t,i,r),i.set(n,o),i}const X=Symbol.for("@ipld/js-cid/CID");class ee{_data;_commp;_sp;_txHash;_withCDN;constructor(e,t){this._data=e instanceof ArrayBuffer?new Uint8Array(e):e,this._withCDN=t,console.log("[MockSynapse] UploadTask created with",this._data.length,"bytes (withCDN=",this._withCDN,")")}async commp(){if(console.log("[MockSynapse] UploadTask.commp() called"),null==this._commp){console.log("[MockSynapse] Generating mock CommP for",this._data.length,"bytes..."),console.log("[MockSynapse] Simulating CommP calculation delay..."),await new Promise((e=>setTimeout(e,100)));const e="baga6ea4seaqjtovkwk4myyzj56eztkh5pzsk5upksan6f5outesy62bsvl4dsha";this._commp=J.parse(e),console.log("[MockSynapse] CommP generated:",this._commp.toString())}else console.log("[MockSynapse] Returning cached CommP:",this._commp.toString());return this._commp}async store(){return console.log("[MockSynapse] UploadTask.store() called"),null==this._sp?(console.log("[MockSynapse] Ensuring CommP is generated before storage..."),await this.commp(),console.log("[MockSynapse] Negotiating with storage provider..."),this._sp="f01234",console.log("[MockSynapse] Selected storage provider:",this._sp),console.log("[MockSynapse] Simulating storage negotiation delay (500ms)..."),await new Promise((e=>setTimeout(e,500))),console.log("[MockSynapse] Storage negotiation complete")):console.log("[MockSynapse] Returning cached storage provider:",this._sp),this._sp}async done(){return console.log("[MockSynapse] UploadTask.done() called"),null==this._txHash?(console.log("[MockSynapse] Ensuring storage is complete before chain commit..."),await this.store(),console.log("[MockSynapse] Submitting transaction to blockchain..."),this._txHash="0x"+Array.from({length:64},(()=>Math.floor(16*Math.random()).toString(16))).join(""),console.log("[MockSynapse] Generated mock transaction hash:",this._txHash),console.log("[MockSynapse] Simulating blockchain confirmation delay (1000ms)..."),await new Promise((e=>setTimeout(e,1e3))),console.log("[MockSynapse] Transaction confirmed on chain")):console.log("[MockSynapse] Returning cached transaction hash:",this._txHash),this._txHash}}BigInt(4);const te=127,ne=BigInt(te),re=BigInt(128),oe=.9921875,ie=32,se=BigInt(ie),ae=2*ie+1,ce=()=>ue,ue=(e=>{if(e instanceof Uint8Array){if(e.length>ie)return e.subarray(0,ie);if(e.length==ie)return e}const t=new Uint8Array(ie);return t.set([...e]),t})(new Uint8Array(ie).fill(0));function le(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function de(e,t){!function(e,...t){if(!(e instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(e.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`)}(e);const n=t.outputLen;if(e.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}Object.freeze(ue.buffer);const he=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),fe=(e,t)=>e<<32-t|e>>>t;if(68!==new Uint8Array(new Uint32Array([287454020]).buffer)[0])throw new Error("Non little-endian hardware is not supported");function pe(e){if("string"==typeof e&&(e=function(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}(e)),!(e instanceof Uint8Array))throw new Error("expected Uint8Array, got "+typeof e);return e}class ge{clone(){return this._cloneInto()}}function we(e){const t=t=>e().update(pe(t)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}class ye extends ge{constructor(e,t,n,r){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=he(this.buffer)}update(e){le(this);const{view:t,buffer:n,blockLen:r}=this,o=(e=pe(e)).length;for(let i=0;i<o;){const s=Math.min(r-this.pos,o-i);if(s!==r)n.set(e.subarray(i,i+s),this.pos),this.pos+=s,i+=s,this.pos===r&&(this.process(t,0),this.pos=0);else{const t=he(e);for(;r<=o-i;i+=r)this.process(t,i)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){le(this),de(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:r,isLE:o}=this;let{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>r-i&&(this.process(n,0),i=0);for(let e=i;e<r;e++)t[e]=0;!function(e,t,n,r){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,n,r);const o=BigInt(32),i=BigInt(4294967295),s=Number(n>>o&i),a=Number(n&i),c=r?4:0,u=r?0:4;e.setUint32(t+c,s,r),e.setUint32(t+u,a,r)}(n,r-8,BigInt(8*this.length),o),this.process(n,0);const s=he(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const c=a/4,u=this.get();if(c>u.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<c;e++)s.setUint32(4*e,u[e],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:r,finished:o,destroyed:i,pos:s}=this;return e.length=r,e.pos=s,e.finished=o,e.destroyed=i,r%t&&e.buffer.set(n),e}}const me=(e,t,n)=>e&t^e&n^t&n,be=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),ve=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Se=new Uint32Array(64);class Ce extends ye{constructor(){super(64,32,8,!1),this.A=0|ve[0],this.B=0|ve[1],this.C=0|ve[2],this.D=0|ve[3],this.E=0|ve[4],this.F=0|ve[5],this.G=0|ve[6],this.H=0|ve[7]}get(){const{A:e,B:t,C:n,D:r,E:o,F:i,G:s,H:a}=this;return[e,t,n,r,o,i,s,a]}set(e,t,n,r,o,i,s,a){this.A=0|e,this.B=0|t,this.C=0|n,this.D=0|r,this.E=0|o,this.F=0|i,this.G=0|s,this.H=0|a}process(e,t){for(let n=0;n<16;n++,t+=4)Se[n]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=Se[e-15],n=Se[e-2],r=fe(t,7)^fe(t,18)^t>>>3,o=fe(n,17)^fe(n,19)^n>>>10;Se[e]=o+Se[e-7]+r+Se[e-16]|0}let{A:n,B:r,C:o,D:i,E:s,F:a,G:c,H:u}=this;for(let e=0;e<64;e++){const t=u+(fe(s,6)^fe(s,11)^fe(s,25))+((l=s)&a^~l&c)+be[e]+Se[e]|0,d=(fe(n,2)^fe(n,13)^fe(n,22))+me(n,r,o)|0;u=c,c=a,a=s,s=i+t|0,i=o,o=r,r=n,n=t+d|0}var l;n=n+this.A|0,r=r+this.B|0,o=o+this.C|0,i=i+this.D|0,s=s+this.E|0,a=a+this.F|0,c=c+this.G|0,u=u+this.H|0,this.set(n,r,o,i,s,a,c,u)}roundClean(){Se.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Ae=we((()=>new Ce)),ke="sha2-256",Ee=32,De=new Uint8Array([18,32]);class Pe{constructor(e){this.code=18,this.name=ke,this.bytes=e,this.size=Ee,this.digest=e.subarray(2)}}const Ue=e=>{const t=new Uint8Array(De.length+Ee);return t.set(De,0),t.set(Ae(e),De.length),new Pe(t)},Ie=18,_e=["string","number","bigint","symbol"],xe=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];class $e{constructor(e,t,n){this.major=e,this.majorEncoded=e<<5,this.name=t,this.terminal=n}toString(){return`Type[${this.major}].${this.name}`}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}}$e.uint=new $e(0,"uint",!0),$e.negint=new $e(1,"negint",!0),$e.bytes=new $e(2,"bytes",!0),$e.string=new $e(3,"string",!0),$e.array=new $e(4,"array",!1),$e.map=new $e(5,"map",!1),$e.tag=new $e(6,"tag",!1),$e.float=new $e(7,"float",!0),$e.false=new $e(7,"false",!0),$e.true=new $e(7,"true",!0),$e.null=new $e(7,"null",!0),$e.undefined=new $e(7,"undefined",!0),$e.break=new $e(7,"break",!0);class Me{constructor(e,t,n){this.type=e,this.value=t,this.encodedLength=n,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}}const Be=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&"function"==typeof globalThis.Buffer.isBuffer,Te=new TextDecoder,Ne=new TextEncoder;function Re(e){return Be&&globalThis.Buffer.isBuffer(e)}const Fe=Be?(e,t,n)=>n-t>64?globalThis.Buffer.from(e.subarray(t,n)).toString("utf8"):Ve(e,t,n):(e,t,n)=>n-t>64?Te.decode(e.subarray(t,n)):Ve(e,t,n),Le=Be?e=>e.length>64?globalThis.Buffer.from(e):He(e):e=>e.length>64?Ne.encode(e):He(e),je=Be?(e,t,n)=>Re(e)?new Uint8Array(e.subarray(t,n)):e.slice(t,n):(e,t,n)=>e.slice(t,n),ze=Be?(e,t)=>{return e=e.map((e=>e instanceof Uint8Array?e:globalThis.Buffer.from(e))),(n=globalThis.Buffer.concat(e,t))instanceof Uint8Array?Re(n)?new Uint8Array(n.buffer,n.byteOffset,n.byteLength):n:Uint8Array.from(n);var n}:(e,t)=>{const n=new Uint8Array(t);let r=0;for(let t of e)r+t.length>n.length&&(t=t.subarray(0,n.length-r)),n.set(t,r),r+=t.length;return n},Oe=Be?e=>globalThis.Buffer.allocUnsafe(e):e=>new Uint8Array(e);function He(e){const t=[];let n=0;for(let r=0;r<e.length;r++){let o=e.charCodeAt(r);o<128?t[n++]=o:o<2048?(t[n++]=o>>6|192,t[n++]=63&o|128):55296==(64512&o)&&r+1<e.length&&56320==(64512&e.charCodeAt(r+1))?(o=65536+((1023&o)<<10)+(1023&e.charCodeAt(++r)),t[n++]=o>>18|240,t[n++]=o>>12&63|128,t[n++]=o>>6&63|128,t[n++]=63&o|128):(t[n++]=o>>12|224,t[n++]=o>>6&63|128,t[n++]=63&o|128)}return t}function Ve(e,t,n){const r=[];for(;t<n;){const o=e[t];let i=null,s=o>239?4:o>223?3:o>191?2:1;if(t+s<=n){let n,r,a,c;switch(s){case 1:o<128&&(i=o);break;case 2:n=e[t+1],128==(192&n)&&(c=(31&o)<<6|63&n,c>127&&(i=c));break;case 3:n=e[t+1],r=e[t+2],128==(192&n)&&128==(192&r)&&(c=(15&o)<<12|(63&n)<<6|63&r,c>2047&&(c<55296||c>57343)&&(i=c));break;case 4:n=e[t+1],r=e[t+2],a=e[t+3],128==(192&n)&&128==(192&r)&&128==(192&a)&&(c=(15&o)<<18|(63&n)<<12|(63&r)<<6|63&a,c>65535&&c<1114112&&(i=c))}}null===i?(i=65533,s=1):i>65535&&(i-=65536,r.push(i>>>10&1023|55296),i=56320|1023&i),r.push(i),t+=s}return function(e){const t=e.length;if(t<=We)return String.fromCharCode.apply(String,e);let n="",r=0;for(;r<t;)n+=String.fromCharCode.apply(String,e.slice(r,r+=We));return n}(r)}const We=4096;const qe="CBOR decode error:",Ge="CBOR encode error:",Ke=[];function Je(e,t,n){if(e.length-t<n)throw new Error(`${qe} not enough data for type`)}Ke[23]=1,Ke[24]=2,Ke[25]=3,Ke[26]=5,Ke[27]=9;const Ye=[24,256,65536,4294967296,BigInt("18446744073709551616")];function Qe(e,t,n){Je(e,t,1);const r=e[t];if(!0===n.strict&&r<Ye[0])throw new Error(`${qe} integer encoded in more bytes than necessary (strict decode)`);return r}function Ze(e,t,n){Je(e,t,2);const r=e[t]<<8|e[t+1];if(!0===n.strict&&r<Ye[1])throw new Error(`${qe} integer encoded in more bytes than necessary (strict decode)`);return r}function Xe(e,t,n){Je(e,t,4);const r=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3];if(!0===n.strict&&r<Ye[2])throw new Error(`${qe} integer encoded in more bytes than necessary (strict decode)`);return r}function et(e,t,n){Je(e,t,8);const r=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3],o=16777216*e[t+4]+(e[t+5]<<16)+(e[t+6]<<8)+e[t+7],i=(BigInt(r)<<BigInt(32))+BigInt(o);if(!0===n.strict&&i<Ye[3])throw new Error(`${qe} integer encoded in more bytes than necessary (strict decode)`);if(i<=Number.MAX_SAFE_INTEGER)return Number(i);if(!0===n.allowBigInt)return i;throw new Error(`${qe} integers outside of the safe integer range are not supported`)}function tt(e,t){return nt(e,0,t.value)}function nt(e,t,n){if(n<Ye[0]){const r=Number(n);e.push([t|r])}else if(n<Ye[1]){const r=Number(n);e.push([24|t,r])}else if(n<Ye[2]){const r=Number(n);e.push([25|t,r>>>8,255&r])}else if(n<Ye[3]){const r=Number(n);e.push([26|t,r>>>24&255,r>>>16&255,r>>>8&255,255&r])}else{const r=BigInt(n);if(!(r<Ye[4]))throw new Error(`${qe} encountered BigInt larger than allowable range`);{const n=[27|t,0,0,0,0,0,0,0];let o=Number(r&BigInt(4294967295)),i=Number(r>>BigInt(32)&BigInt(4294967295));n[8]=255&o,o>>=8,n[7]=255&o,o>>=8,n[6]=255&o,o>>=8,n[5]=255&o,n[4]=255&i,i>>=8,n[3]=255&i,i>>=8,n[2]=255&i,i>>=8,n[1]=255&i,e.push(n)}}}tt.encodedSize=function(e){return nt.encodedSize(e.value)},nt.encodedSize=function(e){return e<Ye[0]?1:e<Ye[1]?2:e<Ye[2]?3:e<Ye[3]?5:9},tt.compareTokens=function(e,t){return e.value<t.value?-1:e.value>t.value?1:0};const rt=BigInt(-1),ot=BigInt(1);function it(e,t){const n=t.value,r="bigint"==typeof n?n*rt-ot:-1*n-1;nt(e,t.type.majorEncoded,r)}function st(e,t,n,r){Je(e,t,n+r);const o=je(e,t+n,t+n+r);return new Me($e.bytes,o,n+r)}function at(e,t,n,r){return st(e,t,1,n)}function ct(e){return void 0===e.encodedBytes&&(e.encodedBytes=e.type===$e.string?Le(e.value):e.value),e.encodedBytes}function ut(e,t){const n=ct(t);nt(e,t.type.majorEncoded,n.length),e.push(n)}function lt(e,t,n,r,o){const i=n+r;Je(e,t,i);const s=new Me($e.string,Fe(e,t+n,t+i),i);return!0===o.retainStringBytes&&(s.byteValue=je(e,t+n,t+i)),s}function dt(e,t,n,r){return lt(e,t,1,n,r)}it.encodedSize=function(e){const t=e.value,n="bigint"==typeof t?t*rt-ot:-1*t-1;return n<Ye[0]?1:n<Ye[1]?2:n<Ye[2]?3:n<Ye[3]?5:9},it.compareTokens=function(e,t){return e.value<t.value?1:e.value>t.value?-1:0},ut.encodedSize=function(e){const t=ct(e);return nt.encodedSize(t.length)+t.length},ut.compareTokens=function(e,t){return n=ct(e),r=ct(t),n.length<r.length?-1:n.length>r.length?1:function(e,t){if(Re(e)&&Re(t))return e.compare(t);for(let n=0;n<e.length;n++)if(e[n]!==t[n])return e[n]<t[n]?-1:1;return 0}(n,r);var n,r};const ht=ut;function ft(e,t,n,r){return new Me($e.array,r,n)}function pt(e,t,n,r){return ft(0,0,1,n)}function gt(e,t){nt(e,$e.array.majorEncoded,t.value)}function wt(e,t,n,r){return new Me($e.map,r,n)}function yt(e,t,n,r){return wt(0,0,1,n)}function mt(e,t){nt(e,$e.map.majorEncoded,t.value)}function bt(e,t,n,r){return new Me($e.tag,n,1)}function vt(e,t){nt(e,$e.tag.majorEncoded,t.value)}function St(e,t,n){if(n){if(!1===n.allowNaN&&Number.isNaN(e))throw new Error(`${qe} NaN values are not supported`);if(!1===n.allowInfinity&&(e===1/0||e===-1/0))throw new Error(`${qe} Infinity values are not supported`)}return new Me($e.float,e,t)}function Ct(e,t,n){const r=t.value;if(!1===r)e.push([20|$e.float.majorEncoded]);else if(!0===r)e.push([21|$e.float.majorEncoded]);else if(null===r)e.push([22|$e.float.majorEncoded]);else if(void 0===r)e.push([23|$e.float.majorEncoded]);else{let t,i=!1;n&&!0===n.float64||(Dt(r),t=Pt(Et,1),r===t||Number.isNaN(r)?(Et[0]=249,e.push(Et.slice(0,3)),i=!0):(Ut(r),t=It(Et,1),r===t&&(Et[0]=250,e.push(Et.slice(0,5)),i=!0))),i||(o=r,kt.setFloat64(0,o,!1),t=_t(Et,1),Et[0]=251,e.push(Et.slice(0,9)))}var o}gt.compareTokens=tt.compareTokens,gt.encodedSize=function(e){return nt.encodedSize(e.value)},mt.compareTokens=tt.compareTokens,mt.encodedSize=function(e){return nt.encodedSize(e.value)},vt.compareTokens=tt.compareTokens,vt.encodedSize=function(e){return nt.encodedSize(e.value)},Ct.encodedSize=function(e,t){const n=e.value;if(!1===n||!0===n||null==n)return 1;if(!t||!0!==t.float64){Dt(n);let e=Pt(Et,1);if(n===e||Number.isNaN(n))return 3;if(Ut(n),e=It(Et,1),n===e)return 5}return 9};const At=new ArrayBuffer(9),kt=new DataView(At,1),Et=new Uint8Array(At,0);function Dt(e){if(e===1/0)kt.setUint16(0,31744,!1);else if(e===-1/0)kt.setUint16(0,64512,!1);else if(Number.isNaN(e))kt.setUint16(0,32256,!1);else{kt.setFloat32(0,e);const t=kt.getUint32(0),n=(2139095040&t)>>23,r=8388607&t;if(255===n)kt.setUint16(0,31744,!1);else if(0===n)kt.setUint16(0,(2147483648&e)>>16|r>>13,!1);else{const e=n-127;e<-24?kt.setUint16(0,0):e<-14?kt.setUint16(0,(2147483648&t)>>16|1<<24+e,!1):kt.setUint16(0,(2147483648&t)>>16|e+15<<10|r>>13,!1)}}}function Pt(e,t){if(e.length-t<2)throw new Error(`${qe} not enough data for float16`);const n=(e[t]<<8)+e[t+1];if(31744===n)return 1/0;if(64512===n)return-1/0;if(32256===n)return NaN;const r=n>>10&31,o=1023&n;let i;return i=0===r?o*2**-24:31!==r?(o+1024)*2**(r-25):0===o?1/0:NaN,32768&n?-i:i}function Ut(e){kt.setFloat32(0,e,!1)}function It(e,t){if(e.length-t<4)throw new Error(`${qe} not enough data for float32`);const n=(e.byteOffset||0)+t;return new DataView(e.buffer,n,4).getFloat32(0,!1)}function _t(e,t){if(e.length-t<8)throw new Error(`${qe} not enough data for float64`);const n=(e.byteOffset||0)+t;return new DataView(e.buffer,n,8).getFloat64(0,!1)}function xt(e,t,n){throw new Error(`${qe} encountered invalid minor (${n}) for major ${e[t]>>>5}`)}function $t(e){return()=>{throw new Error(`${qe} ${e}`)}}Ct.compareTokens=tt.compareTokens;const Mt=[];for(let e=0;e<=23;e++)Mt[e]=xt;Mt[24]=function(e,t,n,r){return new Me($e.uint,Qe(e,t+1,r),2)},Mt[25]=function(e,t,n,r){return new Me($e.uint,Ze(e,t+1,r),3)},Mt[26]=function(e,t,n,r){return new Me($e.uint,Xe(e,t+1,r),5)},Mt[27]=function(e,t,n,r){return new Me($e.uint,et(e,t+1,r),9)},Mt[28]=xt,Mt[29]=xt,Mt[30]=xt,Mt[31]=xt;for(let e=32;e<=55;e++)Mt[e]=xt;Mt[56]=function(e,t,n,r){return new Me($e.negint,-1-Qe(e,t+1,r),2)},Mt[57]=function(e,t,n,r){return new Me($e.negint,-1-Ze(e,t+1,r),3)},Mt[58]=function(e,t,n,r){return new Me($e.negint,-1-Xe(e,t+1,r),5)},Mt[59]=function(e,t,n,r){const o=et(e,t+1,r);if("bigint"!=typeof o){const e=-1-o;if(e>=Number.MIN_SAFE_INTEGER)return new Me($e.negint,e,9)}if(!0!==r.allowBigInt)throw new Error(`${qe} integers outside of the safe integer range are not supported`);return new Me($e.negint,rt-BigInt(o),9)},Mt[60]=xt,Mt[61]=xt,Mt[62]=xt,Mt[63]=xt;for(let e=64;e<=87;e++)Mt[e]=at;Mt[88]=function(e,t,n,r){return st(e,t,2,Qe(e,t+1,r))},Mt[89]=function(e,t,n,r){return st(e,t,3,Ze(e,t+1,r))},Mt[90]=function(e,t,n,r){return st(e,t,5,Xe(e,t+1,r))},Mt[91]=function(e,t,n,r){const o=et(e,t+1,r);if("bigint"==typeof o)throw new Error(`${qe} 64-bit integer bytes lengths not supported`);return st(e,t,9,o)},Mt[92]=xt,Mt[93]=xt,Mt[94]=xt,Mt[95]=$t("indefinite length bytes/strings are not supported");for(let e=96;e<=119;e++)Mt[e]=dt;Mt[120]=function(e,t,n,r){return lt(e,t,2,Qe(e,t+1,r),r)},Mt[121]=function(e,t,n,r){return lt(e,t,3,Ze(e,t+1,r),r)},Mt[122]=function(e,t,n,r){return lt(e,t,5,Xe(e,t+1,r),r)},Mt[123]=function(e,t,n,r){const o=et(e,t+1,r);if("bigint"==typeof o)throw new Error(`${qe} 64-bit integer string lengths not supported`);return lt(e,t,9,o,r)},Mt[124]=xt,Mt[125]=xt,Mt[126]=xt,Mt[127]=$t("indefinite length bytes/strings are not supported");for(let e=128;e<=151;e++)Mt[e]=pt;Mt[152]=function(e,t,n,r){return ft(0,0,2,Qe(e,t+1,r))},Mt[153]=function(e,t,n,r){return ft(0,0,3,Ze(e,t+1,r))},Mt[154]=function(e,t,n,r){return ft(0,0,5,Xe(e,t+1,r))},Mt[155]=function(e,t,n,r){const o=et(e,t+1,r);if("bigint"==typeof o)throw new Error(`${qe} 64-bit integer array lengths not supported`);return ft(0,0,9,o)},Mt[156]=xt,Mt[157]=xt,Mt[158]=xt,Mt[159]=function(e,t,n,r){if(!1===r.allowIndefinite)throw new Error(`${qe} indefinite length items not allowed`);return ft(0,0,1,1/0)};for(let e=160;e<=183;e++)Mt[e]=yt;Mt[184]=function(e,t,n,r){return wt(0,0,2,Qe(e,t+1,r))},Mt[185]=function(e,t,n,r){return wt(0,0,3,Ze(e,t+1,r))},Mt[186]=function(e,t,n,r){return wt(0,0,5,Xe(e,t+1,r))},Mt[187]=function(e,t,n,r){const o=et(e,t+1,r);if("bigint"==typeof o)throw new Error(`${qe} 64-bit integer map lengths not supported`);return wt(0,0,9,o)},Mt[188]=xt,Mt[189]=xt,Mt[190]=xt,Mt[191]=function(e,t,n,r){if(!1===r.allowIndefinite)throw new Error(`${qe} indefinite length items not allowed`);return wt(0,0,1,1/0)};for(let e=192;e<=215;e++)Mt[e]=bt;Mt[216]=function(e,t,n,r){return new Me($e.tag,Qe(e,t+1,r),2)},Mt[217]=function(e,t,n,r){return new Me($e.tag,Ze(e,t+1,r),3)},Mt[218]=function(e,t,n,r){return new Me($e.tag,Xe(e,t+1,r),5)},Mt[219]=function(e,t,n,r){return new Me($e.tag,et(e,t+1,r),9)},Mt[220]=xt,Mt[221]=xt,Mt[222]=xt,Mt[223]=xt;for(let e=224;e<=243;e++)Mt[e]=$t("simple values are not supported");Mt[244]=xt,Mt[245]=xt,Mt[246]=xt,Mt[247]=function(e,t,n,r){if(!1===r.allowUndefined)throw new Error(`${qe} undefined values are not supported`);return!0===r.coerceUndefinedToNull?new Me($e.null,null,1):new Me($e.undefined,void 0,1)},Mt[248]=$t("simple values are not supported"),Mt[249]=function(e,t,n,r){return St(Pt(e,t+1),3,r)},Mt[250]=function(e,t,n,r){return St(It(e,t+1),5,r)},Mt[251]=function(e,t,n,r){return St(_t(e,t+1),9,r)},Mt[252]=xt,Mt[253]=xt,Mt[254]=xt,Mt[255]=function(e,t,n,r){if(!1===r.allowIndefinite)throw new Error(`${qe} indefinite length items not allowed`);return new Me($e.break,void 0,1)};const Bt=[];for(let e=0;e<24;e++)Bt[e]=new Me($e.uint,e,1);for(let e=-1;e>=-24;e--)Bt[31-e]=new Me($e.negint,e,1);Bt[64]=new Me($e.bytes,new Uint8Array(0),1),Bt[96]=new Me($e.string,"",1),Bt[128]=new Me($e.array,0,1),Bt[160]=new Me($e.map,0,1),Bt[244]=new Me($e.false,!1,1),Bt[245]=new Me($e.true,!0,1),Bt[246]=new Me($e.null,null,1),function(){const e=[];e[$e.uint.major]=tt,e[$e.negint.major]=it,e[$e.bytes.major]=ut,e[$e.string.major]=ht,e[$e.array.major]=gt,e[$e.map.major]=mt,e[$e.tag.major]=vt,e[$e.float.major]=Ct}(),new class{constructor(e=256){this.chunkSize=e,this.cursor=0,this.maxCursor=-1,this.chunks=[],this._initReuseChunk=null}reset(){this.cursor=0,this.maxCursor=-1,this.chunks.length&&(this.chunks=[]),null!==this._initReuseChunk&&(this.chunks.push(this._initReuseChunk),this.maxCursor=this._initReuseChunk.length-1)}push(e){let t=this.chunks[this.chunks.length-1];if(this.cursor+e.length<=this.maxCursor+1){const n=t.length-(this.maxCursor-this.cursor)-1;t.set(e,n)}else{if(t){const e=t.length-(this.maxCursor-this.cursor)-1;e<t.length&&(this.chunks[this.chunks.length-1]=t.subarray(0,e),this.maxCursor=this.cursor-1)}e.length<64&&e.length<this.chunkSize?(t=Oe(this.chunkSize),this.chunks.push(t),this.maxCursor+=t.length,null===this._initReuseChunk&&(this._initReuseChunk=t),t.set(e,0)):(this.chunks.push(e),this.maxCursor+=e.length)}this.cursor+=e.length}toBytes(e=!1){let t;if(1===this.chunks.length){const n=this.chunks[0];e&&this.cursor>n.length/2?(t=this.cursor===n.length?n:n.subarray(0,this.cursor),this._initReuseChunk=null,this.chunks=[]):t=je(n,0,this.cursor)}else t=ze(this.chunks,this.cursor);return e&&this.reset(),t}};class Tt{constructor(e,t){this.obj=e,this.parent=t}includes(e){let t=this;do{if(t.obj===e)return!0}while(t=t.parent);return!1}static createCheck(e,t){if(e&&e.includes(t))throw new Error(`${Ge} object contains circular references`);return new Tt(t,e)}}const Nt={null:new Me($e.null,null),undefined:new Me($e.undefined,void 0),true:new Me($e.true,!0),false:new Me($e.false,!1),emptyArray:new Me($e.array,0),emptyMap:new Me($e.map,0)},Rt={number:(e,t,n,r)=>Number.isInteger(e)&&Number.isSafeInteger(e)?new Me(e>=0?$e.uint:$e.negint,e):new Me($e.float,e),bigint:(e,t,n,r)=>e>=BigInt(0)?new Me($e.uint,e):new Me($e.negint,e),Uint8Array:(e,t,n,r)=>new Me($e.bytes,e),string:(e,t,n,r)=>new Me($e.string,e),boolean:(e,t,n,r)=>e?Nt.true:Nt.false,null:(e,t,n,r)=>Nt.null,undefined:(e,t,n,r)=>Nt.undefined,ArrayBuffer:(e,t,n,r)=>new Me($e.bytes,new Uint8Array(e)),DataView:(e,t,n,r)=>new Me($e.bytes,new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),Array(e,t,n,r){if(!e.length)return!0===n.addBreakTokens?[Nt.emptyArray,new Me($e.break)]:Nt.emptyArray;r=Tt.createCheck(r,e);const o=[];let i=0;for(const t of e)o[i++]=Ft(t,n,r);return n.addBreakTokens?[new Me($e.array,e.length),o,new Me($e.break)]:[new Me($e.array,e.length),o]},Object(e,t,n,r){const o="Object"!==t,i=o?e.keys():Object.keys(e),s=o?e.size:i.length;if(!s)return!0===n.addBreakTokens?[Nt.emptyMap,new Me($e.break)]:Nt.emptyMap;r=Tt.createCheck(r,e);const a=[];let c=0;for(const t of i)a[c++]=[Ft(t,n,r),Ft(o?e.get(t):e[t],n,r)];return function(e,t){t.mapSorter&&e.sort(t.mapSorter)}(a,n),n.addBreakTokens?[new Me($e.map,s),a,new Me($e.break)]:[new Me($e.map,s),a]}};Rt.Map=Rt.Object,Rt.Buffer=Rt.Uint8Array;for(const e of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))Rt[`${e}Array`]=Rt.DataView;function Ft(e,t={},n){const r=function(e){if(null===e)return"null";if(void 0===e)return"undefined";if(!0===e||!1===e)return"boolean";const t=typeof e;if(_e.includes(t))return t;if("function"===t)return"Function";if(Array.isArray(e))return"Array";if(function(e){return e&&e.constructor&&e.constructor.isBuffer&&e.constructor.isBuffer.call(null,e)}(e))return"Buffer";return function(e){const t=Object.prototype.toString.call(e).slice(8,-1);if(xe.includes(t))return t}(e)||"Object"}(e),o=t&&t.typeEncoders&&t.typeEncoders[r]||Rt[r];if("function"==typeof o){const i=o(e,r,t,n);if(null!=i)return i}const i=Rt[r];if(!i)throw new Error(`${Ge} unsupported type: ${r}`);return i(e,r,t,n)}Symbol.for("DONE"),Symbol.for("BREAK");const Lt={allowIndefinite:!1,coerceUndefinedToNull:!0,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,rejectDuplicateMapKeys:!0,tags:[]};Lt.tags[42]=function(e){if(0!==e[0])throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");return J.decode(e.subarray(1))},Lt.tags.slice();const jt=([,e])=>e,zt=([e])=>e,Ot=e=>jt(e).length,Ht=(e,{tree:t,node:n})=>{const r=Wt(e,n);return r.error?{error:new Error(`computing root: ${r.error.message}`)}:h(r.ok,t)?{ok:{}}:{error:new Error("inclusion proof does not lead to the same root")}},Vt=63;function Wt(e,t){if(Ot(e)>Vt)return{error:new RangeError("merkle proofs with depths greater than 63 are not supported")};let n=zt(e);if(n>>BigInt(Ot(e))!==0n)return{error:new RangeError("offset greater than width of the tree")};let r=t,o=0n;for(const t of jt(e))o=1n&n,n>>=1n,r=1n===o?Gt(t,r):Gt(r,t);return{ok:r}}function qt(e,t={}){const n=t.hasher||i,{digest:r}=n.digest(e);return Kt(r)}const Gt=(e,t,n)=>{const r=new Uint8Array(e.length+t.length);return r.set(e,0),r.set(t,e.length),qt(r,n)};function Kt(e){return e[ie-1]&=63,e}const Jt=({offset:e,path:t})=>[e,t],Yt=e=>{const[t,n]=Array.isArray(e)?e:[e.offset,e.path];return Jt({offset:BigInt(t),path:n})},Qt=(e,t,n)=>{if(t<0)throw new RangeError("level can not be negative");if(t>e)throw new RangeError(`level too high: ${t} >= ${e}`);if(n>(1<<e-t)-1)throw new RangeError(`index too large for level: idx ${n}, level ${t} : ${(1<<e-t)-1}`)},Zt=e=>{return 2n**BigInt((t=(e+ne-1n)/ne)<=1n?0:(e=>{let t=0n;for(;e>>=1n;)t++;return Number(t)})(BigInt(t)-1n)+1);var t},Xt=e=>en(2n**BigInt(e)),en=e=>e*se,tn=4113,nn=Ee,rn=10+Ee,on=H(tn),sn=on+H(rn)+rn;Xt(255),BigInt(254),BigInt(256);class an{constructor(e){this.bytes=e;const[t]=z(e);if(t!==tn)throw new RangeError("Expected multihash with code 4113");let n=on;const[r,o]=z(e,n);n+=o;const i=e.subarray(n);if(i.length!==r)throw new RangeError(`Invalid multihash size expected ${n+r} bytes, got ${e.length} bytes`);this.digest=i}get name(){return"fr32-sha2-256-trunc254-padded-binary-tree"}get code(){return tn}get size(){return this.digest.length}get padding(){return(({digest:e})=>{const[t]=z(e);return BigInt(t)})(this)}get height(){return(({digest:e})=>{const[,t]=z(e);return e[t]})(this)}get root(){return(({digest:e})=>{const[,t]=z(e);return e.subarray(t+1,t+1+Ee)})(this)}}const cn=new class{constructor(){this.bytes=new Uint8Array(64*ie),this.bytes.set(ce(),0),this.node=ce(),this.length=ie}slice(e,t){for(;this.length<t;)this.node=Gt(this.node,this.node),this.bytes.set(this.node,this.length),this.length+=ie;return this.bytes.subarray(e,t)}},un=e=>{if(e<0||e>=64)throw new Error("Only levels between 0 and 63 inclusive are available");return cn.slice(ie*e,ie*(e+1))},ln=e=>{const t=e.length/ie,n=new Array(t);for(let r=0;r<t;r++){const t=r*ie,o=e.subarray(t,t+ie);n[r]=o}return n};function dn(e){const t=Math.max(e,ae),n=Math.floor(Math.log2(t)),r=Math.ceil(oe*2**(n+1));return t<=r?r:Math.ceil(oe*2**(n+2))}const hn=(e,t=new Uint8Array((e=>dn(e)/oe)(e.length)))=>{const n=dn(e.byteLength)/te;for(let r=0;r<n;r++){const n=r*te,o=128*r;t.set(e.subarray(n,n+32),o),t[o+31]&=63;for(let r=32;r<64;r++)t[o+r]=e[n+r]<<2|e[n+r-1]>>6;t[o+63]&=63;for(let r=64;r<96;r++)t[o+r]=e[n+r]<<4|e[n+r-1]>>4;t[o+95]&=63;for(let r=96;r<127;r++)t[o+r]=e[n+r]<<6|e[n+r-1]>>2;t[o+127]=e[n+126]>>2}return t},fn=Xt(255)*BigInt(254)/BigInt(256),pn=()=>new gn;class gn{constructor(){this.bytesWritten=0n,this.buffer=new Uint8Array(te),this.offset=0,this.layers=[[]]}count(){return this.bytesWritten}digest(){const e=new Uint8Array(sn),t=this.digestInto(e,0,!0);return(e=>new an(e))(e.subarray(0,t))}digestInto(e,t=0,n=!0){const{buffer:r,layers:o,offset:i,bytesWritten:s}=this;let[a,...c]=o;(i>0||0n===s)&&(a=[...a,...ln(hn(r.fill(0,i)))]);const u=yn([a,...c]),l=u.length-1,[d]=u[l],h=Number((e=>(e=>Zt(e)*ne)(e)-e)(this.bytesWritten)),f=H(h);let p=t;if(n){O(4113,e,p),p+=on;const t=f+1+nn,n=H(t);O(t,e,p),p+=n}return O(h,e,p),p+=f,e[p]=l,p+=1,e.set(d,p),p+=d.length,p-t}write(e){const{buffer:t,offset:n,layers:r}=this,o=r[0],{length:i}=e;if(0===i)return this;if(this.bytesWritten+BigInt(i)>fn)throw new RangeError(`Writing ${i} bytes exceeds max payload size of ${fn}`);if(n+i<t.length)return t.set(e,n),this.offset+=i,this.bytesWritten+=BigInt(i),this;{const r=t.length-n;t.set(e.subarray(0,r),n),o.push(...ln(hn(t)));let s=r;for(;s+te<i;){const t=e.subarray(s,s+te);o.push(...ln(hn(t))),s+=te}return this.buffer.set(e.subarray(s),0),this.offset=i-s,this.bytesWritten+=BigInt(i),wn(this.layers),this}}reset(){return this.offset=0,this.bytesWritten=0n,this.layers.length=1,this.layers[0].length=0,this}dispose(){this.reset()}get code(){return 4113}get name(){return"fr32-sha2-256-trunc254-padded-binary-tree"}}const wn=e=>mn(e,!1),yn=e=>mn([...e],!0),mn=(e,t)=>{let n=0;for(;n<e.length;){let r=e[n+1];const o=e[n];t&&o.length%2>0&&r&&o.push(un(n)),n+=1,r=r?t?[...r]:r:[];let i=0;for(;i+1<o.length;){const e=Gt(o[i],o[i+1]);delete o[i],delete o[i+1],r.push(e),i+=2}r.length&&(e[n]=r),o.splice(0,i)}return e};BigInt(256);const bn=16,vn=8,{y1:Sn,tD:Cn}=a,An=BigInt(ie+Sn+Sn+Cn);BigInt(ie),Number(An),Xt(60),(()=>{const e=(e=>{const t=BigInt(e);return t<re?{error:RangeError(`Minimum piece size is ${re} bytes`)}:1!==(e=>{let t=0;for(let n=0n;n<64n;n++)0n!=(e&1n<<n)&&t++;return t})(t)?{error:RangeError("Piece size must be a power of 2")}:{ok:t}})(2n**35n);if(e.error)throw e.error;e.ok})();const kn=61697,En=4114;function Dn(e){return dn(e)}function Pn(e){return"string"==typeof e?function(e){try{const t=J.parse(e);return t.code!==kn||t.multihash.code!==En?null:t}catch{return null}}(e):"object"==typeof e&&null!==J.asCID(e)?(t=e).code!==kn||t.multihash.code!==En?null:e:null;var t}function Un(e){const t=V(En,e.bytes.subarray(e.bytes.length-nn));return J.create(1,kn,t)}function In(e){const t=pn();for(let n=0;n<e.length;n+=2048)t.write(e.subarray(n,n+2048));return Un(t.digest())}function _n(){const e=pn();let t=!1,n=null;return{stream:new TransformStream({transform(t,n){e.write(t),n.enqueue(t)},flush(){const r=e.digest();n=Un(r),t=!0}}),getCommP:()=>t?n:null}}class xn{proofSetId;storageProvider;_storedData=new Map;_signerAddress;_withCDN;constructor(e,t,n,r){this.proofSetId=e,this.storageProvider=t,this._signerAddress=n,this._withCDN=r}upload(e){console.log("[MockSynapse] StorageService.upload() called"),console.log("[MockSynapse] Data size:",e instanceof ArrayBuffer?e.byteLength:e.length,"bytes");const t=new ee(e,this._withCDN);return(async()=>{console.log("[MockSynapse] Storing data internally for mock retrieval...");const n=await t.commp(),r=e instanceof ArrayBuffer?new Uint8Array(e):e;this._storedData.set(n.toString(),r),console.log("[MockSynapse] Data stored with CommP:",n.toString())})().catch((()=>{})),t}async download(e,t){const n=Pn(e);if(null==n)throw new Error("Invalid CommP provided");const r=n.toString();if(console.log("[MockSynapse] StorageService.download() called"),console.log("[MockSynapse] CommP:",r),console.log("[MockSynapse] Download options:",t),!1!==t?.withCDN&&(this._withCDN||t?.withCDN)){console.log("[MockSynapse] Using CDN for download (withCDN=true)");const e=await fetch(`https://${this._signerAddress}.calibration.filcdn.io/${r}`);return new Uint8Array(await e.arrayBuffer())}console.log("[MockSynapse] Simulating download network delay (300ms)..."),await new Promise((e=>setTimeout(e,300))),console.log("[MockSynapse] Looking up data in mock storage...");const o=this._storedData.get(r);if(null==o)throw console.log("[MockSynapse] Data not found in mock storage!"),new Error(`Data not found for CommP: ${r}`);return console.log("[MockSynapse] Data found, size:",o.length,"bytes"),!0!==t?.noVerify?(console.log("[MockSynapse] Verifying data integrity..."),console.log("[MockSynapse] Simulating verification delay (200ms)..."),await new Promise((e=>setTimeout(e,200))),console.log("[MockSynapse] Data verification complete")):console.log("[MockSynapse] Skipping verification (noVerify=true)"),console.log("[MockSynapse] Returning data copy"),new Uint8Array(o)}async delete(e){const t=Pn(e);if(null==t)throw new Error("Invalid CommP provided");const n=t.toString();console.log("[MockSynapse] StorageService.delete() called"),console.log("[MockSynapse] CommP:",n),console.log("[MockSynapse] Simulating delete network delay (500ms)..."),await new Promise((e=>setTimeout(e,500))),console.log("[MockSynapse] Removing data from mock storage..."),this._storedData.delete(n),console.log("[MockSynapse] Data deleted successfully")}async settlePayments(){console.log("[MockSynapse] StorageService.settlePayments() called"),console.log("[MockSynapse] Simulating settlement processing delay (1000ms)..."),await new Promise((e=>setTimeout(e,1e3)));const e={settledAmount:50000000000000000n,epoch:Math.floor(Date.now()/3e4)};return console.log("[MockSynapse] Settlement complete:",e),e}}class $n{apiEndpoint;serviceName;constructor(e,t="public"){if(""===e)throw new Error("PDP API endpoint is required");this.apiEndpoint=e.endsWith("/")?e.slice(0,-1):e,this.serviceName=t}async upload(e,t){const n=e instanceof ArrayBuffer?new Uint8Array(e):e,r=n.length,o=await this._createUpload(t,r);await this._uploadData(o,n)}async _createUpload(e,t){const n={check:{name:"sha2-256-trunc254-padded",hash:e.multihash.digest.reduce(((e,t)=>e+t.toString(16).padStart(2,"0")),""),size:t}},r=await fetch(`${this.apiEndpoint}/pdp/piece`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(n)});if(200===r.status){const e=await r.json();return console.log(`Piece already exists on server: ${e.pieceCID}`),""}if(201!==r.status){const e=await r.text();throw new Error(`Failed to create upload: ${r.status} ${r.statusText} - ${e}`)}const o=r.headers.get("Location");if(null==o)throw new Error("Server did not provide Location header in response (may be restricted by CORS policy)");const i=o.match(/\/(?:pdp\/)?piece\/upload\/([a-fA-F0-9-]+)/);if(null==i)throw new Error(`Invalid Location header format: ${o}`);return i[1]}async _uploadData(e,t){if(""===e)return;const n=`${this.apiEndpoint}/pdp/piece/upload/${e}`,r=await fetch(n,{method:"PUT",headers:{"Content-Type":"application/octet-stream","Content-Length":t.length.toString()},body:t});if(204!==r.status){const e=await r.text();throw new Error(`Failed to upload data: ${r.status} ${r.statusText} - ${e}`)}}getServiceName(){return this.serviceName}getApiEndpoint(){return this.apiEndpoint}}class Mn{retrievalUrl;constructor(e){if(""===e)throw new Error("Retrieval URL is required");this.retrievalUrl=e.endsWith("/")?e.slice(0,-1):e}async downloadPiece(e){const t=Pn(e);if(null==t)throw new Error("Invalid CommP provided");const n=`${this.retrievalUrl}/piece/${t.toString()}`,r=await fetch(n,{method:"GET",headers:{Accept:"application/octet-stream"}});if(!r.ok){const e=await r.text();throw new Error(`Failed to download piece: ${r.status} ${r.statusText} - ${e}`)}if(null==r.body)throw new Error("Response body is null");console.log("Streaming and verifying downloaded data...");const{stream:o,getCommP:i}=_n(),s=[],a=new TransformStream({transform(e,t){s.push(e),t.enqueue(e)}}),c=r.body.pipeThrough(o).pipeThrough(a).getReader();try{for(;;){const{done:e}=await c.read();if(e)break}}finally{c.releaseLock()}const u=i();if(null==u)throw new Error("Failed to calculate CommP from stream");if(u.toString()!==t.toString())throw new Error(`CommP verification failed. Expected: ${t.toString()}, Got: ${u.toString()}`);console.log("âœ… CommP verification successful");const l=s.reduce(((e,t)=>e+t.length),0),d=new Uint8Array(l);let h=0;for(const e of s)d.set(e,h),h+=e.length;return d}getRetrievalUrl(){return this.retrievalUrl}}const Bn={CreateProofSet:[{name:"clientDataSetId",type:"uint256"},{name:"withCDN",type:"bool"},{name:"payee",type:"address"}],Cid:[{name:"data",type:"bytes"}],RootData:[{name:"root",type:"Cid"},{name:"rawSize",type:"uint256"}],AddRoots:[{name:"clientDataSetId",type:"uint256"},{name:"firstAdded",type:"uint256"},{name:"rootData",type:"RootData[]"}],ScheduleRemovals:[{name:"clientDataSetId",type:"uint256"},{name:"rootIds",type:"uint256[]"}],DeleteProofSet:[{name:"clientDataSetId",type:"uint256"}]};class Tn{signer;domain;constructor(e,t,n){this.signer=t,this.domain={name:"PandoraService",version:"1",chainId:Number(n),verifyingContract:e}}async isMetaMaskSigner(){try{const e=this.signer.provider;if(null==e)return!1;if("_eip1193Provider"in e)return!0;if("undefined"!=typeof globalThis&&"window"in globalThis){const e=globalThis;if(null!=e.window?.ethereum)return!0}if("send"in e||"request"in e)return!0}catch(e){}return!1}async signWithMetaMask(e,t){const n=this.signer.provider;if(null==n)throw new Error("No provider available");const r=await this.signer.getAddress();let o="";for(const t of Object.keys(e))if("Cid"!==t&&"RootData"!==t){o=t;break}const i={types:{EIP712Domain:[{name:"name",type:"string"},{name:"version",type:"string"},{name:"chainId",type:"uint256"},{name:"verifyingContract",type:"address"}],...e},primaryType:o,domain:this.domain,message:t};let s,a;return s="_eip1193Provider"in n?n._eip1193Provider:n,a=null!=s&&"request"in s?await s.request({method:"eth_signTypedData_v4",params:[r.toLowerCase(),JSON.stringify(i)]}):await n.send("eth_signTypedData_v4",[r.toLowerCase(),JSON.stringify(i)]),a}async signCreateProofSet(e,t,n=!1){let r;if(await this.isMetaMaskSigner()){const o={clientDataSetId:e.toString(),withCDN:n,payee:t};r=await this.signWithMetaMask({CreateProofSet:Bn.CreateProofSet},o)}else{const o={clientDataSetId:BigInt(e),withCDN:n,payee:t};r=await this.signer.signTypedData(this.domain,{CreateProofSet:Bn.CreateProofSet},o)}const o=d.ethers.Signature.from(r),i=d.ethers.TypedDataEncoder.hash(this.domain,{CreateProofSet:Bn.CreateProofSet},{clientDataSetId:BigInt(e),withCDN:n,payee:t});return{signature:r,v:o.v,r:o.r,s:o.s,signedData:i}}async signAddRoots(e,t,n){const r=[];for(const e of n){const t="string"==typeof e.cid?Pn(e.cid):e.cid;if(null==t)throw new Error(`Invalid CommP: ${String(e.cid)}`);r.push({root:{data:t.bytes},rawSize:BigInt(Dn(e.rawSize))})}let o;if(await this.isMetaMaskSigner()){const n={clientDataSetId:e.toString(),firstAdded:t.toString(),rootData:r.map((e=>({root:{data:d.ethers.hexlify(e.root.data)},rawSize:e.rawSize.toString()})))},i={AddRoots:Bn.AddRoots,RootData:Bn.RootData,Cid:Bn.Cid};o=await this.signWithMetaMask(i,n)}else{const n={clientDataSetId:BigInt(e),firstAdded:BigInt(t),rootData:r},i={AddRoots:Bn.AddRoots,RootData:Bn.RootData,Cid:Bn.Cid};o=await this.signer.signTypedData(this.domain,i,n)}const i=d.ethers.Signature.from(o),s=d.ethers.TypedDataEncoder.hash(this.domain,{AddRoots:Bn.AddRoots,RootData:Bn.RootData,Cid:Bn.Cid},{clientDataSetId:BigInt(e),firstAdded:BigInt(t),rootData:r});return{signature:o,v:i.v,r:i.r,s:i.s,signedData:s}}async signScheduleRemovals(e,t){const n=t.map((e=>BigInt(e)));let r;if(await this.isMetaMaskSigner()){const t={clientDataSetId:e.toString(),rootIds:n.map((e=>e.toString()))};r=await this.signWithMetaMask({ScheduleRemovals:Bn.ScheduleRemovals},t)}else{const t={clientDataSetId:BigInt(e),rootIds:n};r=await this.signer.signTypedData(this.domain,{ScheduleRemovals:Bn.ScheduleRemovals},t)}const o=d.ethers.Signature.from(r),i=d.ethers.TypedDataEncoder.hash(this.domain,{ScheduleRemovals:Bn.ScheduleRemovals},{clientDataSetId:BigInt(e),rootIds:n});return{signature:r,v:o.v,r:o.r,s:o.s,signedData:i}}async signDeleteProofSet(e){let t;if(await this.isMetaMaskSigner()){const n={clientDataSetId:e.toString()};t=await this.signWithMetaMask({DeleteProofSet:Bn.DeleteProofSet},n)}else{const n={clientDataSetId:BigInt(e)};t=await this.signer.signTypedData(this.domain,{DeleteProofSet:Bn.DeleteProofSet},n)}const n=d.ethers.Signature.from(t),r=d.ethers.TypedDataEncoder.hash(this.domain,{DeleteProofSet:Bn.DeleteProofSet},{clientDataSetId:BigInt(e)});return{signature:t,v:n.v,r:n.r,s:n.s,signedData:r}}async getSignerAddress(){return await this.signer.getAddress()}}class Nn{apiEndpoint;pdpAuthHelper;constructor(e,t){if(""===e)throw new Error("PDP API endpoint is required");this.apiEndpoint=e.endsWith("/")?e.slice(0,-1):e,this.pdpAuthHelper=t}async createProofSet(e,t,n,r){const o=await this.pdpAuthHelper.signCreateProofSet(e,t,n),i={recordKeeper:r,extraData:`0x${this._encodeProofSetCreateData({metadata:"",payer:await this.pdpAuthHelper.getSignerAddress(),withCDN:n,signature:o.signature})}`},s=await fetch(`${this.apiEndpoint}/pdp/proof-sets`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(i)});if(201!==s.status){const e=await s.text();throw new Error(`Failed to create proof set: ${s.status} ${s.statusText} - ${e}`)}const a=s.headers.get("Location");if(null==a)throw new Error("Server did not provide Location header in response");const c=a.match(/\/pdp\/proof-sets\/created\/(.+)$/);if(null==c)throw new Error(`Invalid Location header format: ${a}`);return{txHash:c[1],statusUrl:`${this.apiEndpoint}${a}`}}async getProofSetCreationStatus(e){const t=await fetch(`${this.apiEndpoint}/pdp/proof-sets/created/${e}`,{method:"GET",headers:{"Content-Type":"application/json"}});if(404===t.status)throw new Error(`Proof set creation not found for transaction hash: ${e}`);if(200!==t.status){const e=await t.text();throw new Error(`Failed to get proof set creation status: ${t.status} ${t.statusText} - ${e}`)}return await t.json()}async addRoots(e,t,n,r){if(0===r.length)throw new Error("At least one root must be provided");for(const e of r)if(null==Pn(e.cid))throw new Error(`Invalid CommP: ${String(e.cid)}`);const o=await this.pdpAuthHelper.signAddRoots(t,n,r),i=this._encodeAddRootsExtraData({signature:o.signature,metadata:""}),s={roots:r.map((e=>{const t="string"==typeof e.cid?e.cid:e.cid.toString();return{rootCid:t,subroots:[{subrootCid:t}]}})),extraData:`0x${i}`},a=await fetch(`${this.apiEndpoint}/pdp/proof-sets/${e}/roots`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(s)});if(201!==a.status){const e=await a.text();throw new Error(`Failed to add roots to proof set: ${a.status} ${a.statusText} - ${e}`)}const c=await a.text();return{message:""!==c?c:`Roots added to proof set ID ${e} successfully`}}getApiEndpoint(){return this.apiEndpoint}getPDPAuthHelper(){return this.pdpAuthHelper}_encodeProofSetCreateData(e){const t=e.signature.startsWith("0x")?e.signature:`0x${e.signature}`;return d.ethers.AbiCoder.defaultAbiCoder().encode(["string","address","bool","bytes"],[e.metadata,e.payer,e.withCDN,t]).slice(2)}_encodeAddRootsExtraData(e){const t=e.signature.startsWith("0x")?e.signature:`0x${e.signature}`;return d.ethers.AbiCoder.defaultAbiCoder().encode(["bytes","string"],[t,e.metadata]).slice(2)}}function Rn(e,t,n,r){const o=`${e} ${t} failed: ${n}`;return null!=r?new Error(o,{cause:r}):new Error(o)}const Fn={USDFC:"USDFC",FIL:"FIL"},Ln={mainnet:314,calibration:314159},jn={ERC20:["function balanceOf(address owner) view returns (uint256)","function decimals() view returns (uint8)","function symbol() view returns (string)","function approve(address spender, uint256 amount) returns (bool)","function allowance(address owner, address spender) view returns (uint256)","function transfer(address to, uint256 amount) returns (bool)"],PAYMENTS:["function deposit(address token, address to, uint256 amount)","function withdraw(address token, uint256 amount)","function accounts(address token, address owner) view returns (uint256 funds, uint256 lockedFunds, bool frozen)","function setOperatorApproval(address token, address operator, bool approved, uint256 rateAllowance, uint256 lockupAllowance)","function operatorApprovals(address token, address client, address operator) view returns (bool isApproved, uint256 rateAllowance, uint256 rateUsed, uint256 lockupAllowance, uint256 lockupUsed)"],PANDORA_SERVICE:["function registerServiceProvider(string pdpUrl, string pieceRetrievalUrl) external","function approveServiceProvider(address provider) external","function rejectServiceProvider(address provider) external","function removeServiceProvider(uint256 providerId) external","function isProviderApproved(address provider) external view returns (bool)","function getProviderIdByAddress(address provider) external view returns (uint256)","function getApprovedProvider(uint256 providerId) external view returns (tuple(address owner, string pdpUrl, string pieceRetrievalUrl, uint256 registeredAt, uint256 approvedAt))","function pendingProviders(address provider) external view returns (string pdpUrl, string pieceRetrievalUrl, uint256 registeredAt)","function approvedProviders(uint256 providerId) external view returns (address owner, string pdpUrl, string pieceRetrievalUrl, uint256 registeredAt, uint256 approvedAt)","function nextServiceProviderId() external view returns (uint256)","function owner() external view returns (address)","function approvedProvidersMap(address) external view returns (bool)","function providerToId(address) external view returns (uint256)","function getAllApprovedProviders() external view returns (tuple(address owner, string pdpUrl, string pieceRetrievalUrl, uint256 registeredAt, uint256 approvedAt)[])"]},zn={mainnet:{http:"https://api.node.glif.io/rpc/v1",websocket:"wss://wss.node.glif.io/apigw/lotus/rpc/v1"},calibration:{http:"https://api.calibration.node.glif.io/rpc/v1",websocket:"wss://wss.calibration.node.glif.io/apigw/lotus/rpc/v1"}},On={USDFC:{mainnet:"0x80B98d3aa09ffff255c3ba4A241111Ff1262F045",calibration:"0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0"},PAYMENTS:{mainnet:"",calibration:"0x0E690D3e60B0576D01352AB03b258115eb84A047"},PANDORA_SERVICE:{mainnet:"",calibration:"0x394feCa6bCB84502d93c0c5C03c620ba8897e8f4"}};class Hn{contract;signer;constructor(e,t){this.signer=t,this.contract=new d.Contract(e,jn.PANDORA_SERVICE,t)}async register(e,t){return await this.contract.registerServiceProvider(e,t)}async approve(e){return await this.contract.approveServiceProvider(e)}async reject(e){return await this.contract.rejectServiceProvider(e)}async remove(e){return await this.contract.removeServiceProvider(e)}async isApproved(e){return await this.contract.isProviderApproved(e)}async getProviderIdByAddress(e){return await this.contract.getProviderIdByAddress(e)}async getApprovedProvider(e){const t=await this.contract.getApprovedProvider(e);return{owner:t.owner,pdpUrl:t.pdpUrl,pieceRetrievalUrl:t.pieceRetrievalUrl,registeredAt:t.registeredAt,approvedAt:t.approvedAt}}async getPendingProvider(e){const[t,n,r]=await this.contract.pendingProviders(e);return{pdpUrl:t,pieceRetrievalUrl:n,registeredAt:r}}async getNextProviderId(){return await this.contract.nextServiceProviderId()}async getOwner(){return await this.contract.owner()}async getSignerAddress(){return await this.signer.getAddress()}async isOwner(){const[e,t]=await Promise.all([this.getOwner(),this.getSignerAddress()]);return e.toLowerCase()===t.toLowerCase()}async getAllApprovedProviders(){const e=await this.getNextProviderId(),t=[];for(let n=1n;n<e;n++)try{const e=await this.getApprovedProvider(n);"0x0000000000000000000000000000000000000000"!==e.owner&&t.push({id:n,info:e})}catch(e){continue}return t}getContractAddress(){return this.contract.target}}class Vn{_provider;_signer;_network;_disableNonceManager;_usdfcContract=null;_paymentsContract=null;static USDFC=Fn.USDFC;constructor(e,t,n,r){this._provider=e,this._signer=t,this._network=n,this._disableNonceManager=r}_getUsdfcContract(){if(null==this._usdfcContract){const e=On.USDFC[this._network];if(null==e)throw new Error(`USDFC contract not deployed on ${this._network} network`);this._usdfcContract=new d.ethers.Contract(e,jn.ERC20,this._signer)}return this._usdfcContract}_getPaymentsContract(){if(null==this._paymentsContract){const e=On.PAYMENTS[this._network];if(null==e||""===e)throw new Error(`Payments contract not deployed on ${this._network} network. Currently only Calibration testnet is supported.`);this._paymentsContract=new d.ethers.Contract(e,jn.PAYMENTS,this._signer)}return this._paymentsContract}async balance(e=Vn.USDFC){if(e!==Vn.USDFC)throw Rn("SynapsePayments","payments contract balance check",`Token "${e}" is not supported. Currently only USDFC token is supported for payments contract balance queries.`);const t=await this._signer.getAddress(),n=On.USDFC[this._network],r=this._getPaymentsContract();let o;try{o=await r.accounts(n,t)}catch(e){throw Rn("SynapsePayments","payments contract balance check","Failed to read account information from payments contract. This could indicate the contract is not properly deployed, the ABI is incorrect, or there are network connectivity issues.",e)}const[i,s]=o;return BigInt(i)-BigInt(s)}async walletBalance(e){if(null==e||e===Fn.FIL)try{const e=await this._signer.getAddress();return await this._provider.getBalance(e)}catch(e){throw Rn("SynapsePayments","wallet FIL balance check","Unable to retrieve FIL balance from wallet. This could be due to network connectivity issues, RPC endpoint problems, or wallet connection issues.",e)}if(e===Vn.USDFC)try{const e=await this._signer.getAddress(),t=this._getUsdfcContract();return await t.balanceOf(e)}catch(e){throw Rn("SynapsePayments","wallet USDFC balance check","Unexpected error while checking USDFC token balance in wallet.",e)}throw Rn("SynapsePayments","wallet balance check",`Token "${e}" is not supported. Currently only USDFC token is supported for balance queries.`)}decimals(e=Vn.USDFC){return 18}async allowance(e,t){if(e!==Vn.USDFC)throw Rn("SynapsePayments","allowance",`Token "${e}" is not supported. Currently only USDFC token is supported.`);const n=await this._signer.getAddress(),r=this._getUsdfcContract();try{return await r.allowance(n,t)}catch(e){throw Rn("SynapsePayments","allowance check","Failed to check token allowance. This could indicate network connectivity issues or an invalid spender address.",e)}}async approve(e,t,n){if(e!==Vn.USDFC)throw Rn("SynapsePayments","approve",`Token "${e}" is not supported. Currently only USDFC token is supported.`);const r="bigint"==typeof n?n:BigInt(n);if(r<0n)throw Rn("SynapsePayments","approve","Approval amount cannot be negative");const o=await this._signer.getAddress(),i=this._getUsdfcContract(),s={};if(this._disableNonceManager){const e=await this._provider.getTransactionCount(o,"pending");s.nonce=e}try{const e=await i.approve(t,r,s);return await e.wait(),e.hash}catch(n){throw Rn("SynapsePayments","approve",`Failed to approve ${t} to spend ${r.toString()} ${e}`,n)}}async approveService(e,t,n,r=Vn.USDFC){if(r!==Vn.USDFC)throw Rn("SynapsePayments","approveService",`Token "${r}" is not supported. Currently only USDFC token is supported.`);const o="bigint"==typeof t?t:BigInt(t),i="bigint"==typeof n?n:BigInt(n);if(o<0n||i<0n)throw Rn("SynapsePayments","approveService","Allowance values cannot be negative");const s=await this._signer.getAddress(),a=On.USDFC[this._network],c=this._getPaymentsContract(),u={};if(this._disableNonceManager){const e=await this._provider.getTransactionCount(s,"pending");u.nonce=e}try{const t=await c.setOperatorApproval(a,e,!0,o,i,u);return await t.wait(),t.hash}catch(t){throw Rn("SynapsePayments","approveService",`Failed to approve service ${e} as operator for ${r}`,t)}}async revokeService(e,t=Vn.USDFC){if(t!==Vn.USDFC)throw Rn("SynapsePayments","revokeService",`Token "${t}" is not supported. Currently only USDFC token is supported.`);const n=await this._signer.getAddress(),r=On.USDFC[this._network],o=this._getPaymentsContract(),i={};if(this._disableNonceManager){const e=await this._provider.getTransactionCount(n,"pending");i.nonce=e}try{const t=await o.setOperatorApproval(r,e,!1,0n,0n,i);return await t.wait(),t.hash}catch(n){throw Rn("SynapsePayments","revokeService",`Failed to revoke service ${e} as operator for ${t}`,n)}}async serviceApproval(e,t=Vn.USDFC){if(t!==Vn.USDFC)throw Rn("SynapsePayments","serviceApproval",`Token "${t}" is not supported. Currently only USDFC token is supported.`);const n=await this._signer.getAddress(),r=On.USDFC[this._network],o=this._getPaymentsContract();try{const t=await o.operatorApprovals(r,n,e);return{isApproved:t[0],rateAllowance:t[1],lockupAllowance:t[2],rateUsed:t[3],lockupUsed:t[4]}}catch(t){throw Rn("SynapsePayments","serviceApproval",`Failed to check service approval status for ${e}`,t)}}async deposit(e,t=Vn.USDFC){if(t!==Vn.USDFC)throw Rn("SynapsePayments","deposit",`Unsupported token: ${t}`);const n="bigint"==typeof e?e:BigInt(e);if(n<=0n)throw Rn("SynapsePayments","deposit","Invalid amount");const r=await this._signer.getAddress(),o=On.USDFC[this._network],i=this._getUsdfcContract(),s=this._getPaymentsContract(),a=await i.balanceOf(r);if(a<n)throw Rn("SynapsePayments","deposit",`Insufficient USDFC: have ${BigInt(a).toString()}, need ${n.toString()}`);const c=On.PAYMENTS[this._network];if(null==c)throw Rn("SynapsePayments","deposit",`Payments contract not deployed on ${this._network}`);await this.allowance(t,c)<n&&await this.approve(t,c,n);const u=await s.accounts(o,r),[,,l]=u;if(!0===l)throw Rn("SynapsePayments","deposit","Account is frozen");const d={};if(this._disableNonceManager){const e=await this._provider.getTransactionCount(r,"pending");d.nonce=e}const h=await s.deposit(o,r,n,d);return await h.wait(),h.hash}async withdraw(e,t=Vn.USDFC){if(t!==Vn.USDFC)throw Rn("SynapsePayments","withdraw",`Unsupported token: ${t}`);const n="bigint"==typeof e?e:BigInt(e);if(n<=0n)throw Rn("SynapsePayments","withdraw","Invalid amount");const r=await this._signer.getAddress(),o=On.USDFC[this._network],i=this._getPaymentsContract(),s=await i.accounts(o,r),[a,c,u]=s,l=BigInt(a)-BigInt(c);if(!0===u)throw Rn("SynapsePayments","withdraw","Account is frozen");if(l<n)throw Rn("SynapsePayments","withdraw",`Insufficient balance: have ${l.toString()}, need ${n.toString()}`);const d={};if(this._disableNonceManager){const e=await this._provider.getTransactionCount(r,"pending");d.nonce=e}const h=await i.withdraw(o,n,d);return await h.wait(),h.hash}}class Wn{_signer;_network;_withCDN;_payments;_pdpAuthHelper=null;static async create(e){if(1!==[e.privateKey,e.provider,e.signer].filter(Boolean).length)throw new Error("Must provide exactly one of: privateKey, provider, or signer");if(null!=e.privateKey&&null==e.rpcURL)throw new Error("rpcURL is required when using privateKey");let t,n,r;if(null!=e.privateKey&&null!=e.rpcURL){if(e.rpcURL.startsWith("ws://")||e.rpcURL.startsWith("wss://"))t=new d.ethers.WebSocketProvider(e.rpcURL);else if(null!=e.authorization){const n=new d.ethers.FetchRequest(e.rpcURL);n.setHeader("Authorization",e.authorization),t=new d.ethers.JsonRpcProvider(n)}else t=new d.ethers.JsonRpcProvider(e.rpcURL);const r=new d.ethers.Wallet(e.privateKey,t);n=!0!==e.disableNonceManager?new d.ethers.NonceManager(r):r}else if(null!=e.provider){if(t=e.provider,!("getSigner"in t)||"function"!=typeof t.getSigner)throw new Error("Provider must support getSigner() method");{const r=await t.getSigner();n=!0!==e.disableNonceManager?new d.ethers.NonceManager(r):r}}else{if(null==e.signer)throw new Error("Invalid configuration");if(n=e.signer,null==n.provider)throw new Error("Signer must have a provider attached");t=n.provider,!0!==e.disableNonceManager&&(n=new d.ethers.NonceManager(n))}try{const e=await t.getNetwork(),n=Number(e.chainId);if(n===Ln.mainnet)r="mainnet";else{if(n!==Ln.calibration)throw new Error(`Unsupported network with chain ID ${n}. Synapse SDK only supports Filecoin mainnet (${Ln.mainnet}) and calibration (${Ln.calibration}) networks.`);r="calibration"}}catch(e){throw new Error("Failed to detect network from provider. Please ensure your RPC endpoint is accessible and responds to network queries. "+(e instanceof Error?`Underlying error: ${e.message}`:""))}return new Wn(t,n,r,!0===e.disableNonceManager,!0===e.withCDN)}constructor(e,t,n,r,o){this._signer=t,this._network=n,this._withCDN=o,this._payments=new Vn(e,t,n,r)}get payments(){return this._payments}async createStorage(e){console.log("[MockSynapse] Creating storage service..."),console.log("[MockSynapse] Options:",e),console.log("[MockSynapse] Simulating network delay (500ms)..."),await new Promise((e=>setTimeout(e,500)));const t=e?.proofSetId??"ps_"+Math.random().toString(36).substring(2,15),n=e?.storageProvider??"f01234";return console.log(`[MockSynapse] Storage service created with proofSetId: ${t}, SP: ${n}`),console.log("[MockSynapse] Storage service ready for operations"),new xn(t,n,await this._signer.getAddress(),this._withCDN)}getPDPAuthHelper(){if(null==this._pdpAuthHelper){const e=On.PANDORA_SERVICE[this._network];if(""===e)throw Rn("Synapse","getPDPAuthHelper",`PDP service contract not deployed on ${this._network} network`);const t=BigInt(Ln[this._network]);this._pdpAuthHelper=new Tn(e,this._signer,t)}return this._pdpAuthHelper}}const qn={...l,...c,...u};return o.default})()));