import*as e from"ethers";var t={d:(e,n)=>{for(var r in n)t.o(n,r)&&!t.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},n={};t.r(n),t.d(n,{code:()=>Ue,digest:()=>Pe,name:()=>Ae,size:()=>ke});var r={};t.r(r),t.d(r,{computeNode:()=>qt,create:()=>Kt,depth:()=>Ot,from:()=>Jt,offset:()=>zt,path:()=>Lt,resolveRoot:()=>Vt,truncate:()=>Gt,truncatedHash:()=>Wt,validateLevelIndex:()=>Yt,verify:()=>jt});var o={};t.r(o),t.d(o,{tD:()=>mn,y1:()=>bn});var i={};t.r(i),t.d(i,{FIL_COMMITMENT_UNSEALED:()=>An,SHA2_256_TRUNC254_PADDED:()=>kn,asCommP:()=>Dn,calculate:()=>Un,createCommPStream:()=>In,toZeroPaddedSize:()=>En});var s={};t.r(s),t.d(s,{PDPAuthHelper:()=>Bn,PDPDownloadService:()=>$n,PDPTool:()=>Tn,PDPUploadService:()=>xn,StorageProviderTool:()=>jn});var a={};t.r(a),t.d(a,{CHAIN_IDS:()=>Fn,CONTRACT_ABIS:()=>Ln,CONTRACT_ADDRESSES:()=>On,MockStorageService:()=>_n,MockUploadTask:()=>X,RPC_URLS:()=>zn,Synapse:()=>Vn,SynapsePayments:()=>Hn,TOKENS:()=>Rn,createError:()=>Nn});const c=(l={Contract:()=>e.Contract,ethers:()=>e.ethers},u={},t.d(u,l),u);var l,u;function d(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0}function h(e){if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")}new Uint8Array(0);const f=function(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var n=new Uint8Array(256),r=0;r<n.length;r++)n[r]=255;for(var o=0;o<e.length;o++){var i=e.charAt(o),s=i.charCodeAt(0);if(255!==n[s])throw new TypeError(i+" is ambiguous");n[s]=o}var a=e.length,c=e.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function d(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var r=0,o=0;e[t]===c;)r++,t++;for(var i=(e.length-t)*l+1>>>0,s=new Uint8Array(i);e[t];){var u=n[e.charCodeAt(t)];if(255===u)return;for(var d=0,h=i-1;(0!==u||d<o)&&-1!==h;h--,d++)u+=a*s[h]>>>0,s[h]=u%256>>>0,u=u/256>>>0;if(0!==u)throw new Error("Non-zero carry");o=d,t++}if(" "!==e[t]){for(var f=i-o;f!==i&&0===s[f];)f++;for(var p=new Uint8Array(r+(i-f)),g=r;f!==i;)p[g++]=s[f++];return p}}}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var n=0,r=0,o=0,i=t.length;o!==i&&0===t[o];)o++,n++;for(var s=(i-o)*u+1>>>0,l=new Uint8Array(s);o!==i;){for(var d=t[o],h=0,f=s-1;(0!==d||h<r)&&-1!==f;f--,h++)d+=256*l[f]>>>0,l[f]=d%a>>>0,d=d/a>>>0;if(0!==d)throw new Error("Non-zero carry");r=h,o++}for(var p=s-r;p!==s&&0===l[p];)p++;for(var g=c.repeat(n);p<s;++p)g+=e.charAt(l[p]);return g},decodeUnsafe:d,decode:function(e){var n=d(e);if(n)return n;throw new Error(`Non-${t} character`)}}};class p{name;prefix;baseEncode;constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class g{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,n){this.name=e,this.prefix=t;const r=t.codePointAt(0);if(void 0===r)throw new Error("Invalid prefix character");this.prefixCodePoint=r,this.baseDecode=n}decode(e){if("string"==typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return y(this,e)}}class w{decoders;constructor(e){this.decoders=e}or(e){return y(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(null!=n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function y(e,t){return new w({...e.decoders??{[e.prefix]:e},...t.decoders??{[t.prefix]:t}})}class m{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,n,r){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=r,this.encoder=new p(e,t,n),this.decoder=new g(e,t,r)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function b({name:e,prefix:t,encode:n,decode:r}){return new m(e,t,n,r)}function v({name:e,prefix:t,alphabet:n}){const{encode:r,decode:o}=f(n,e);return b({prefix:t,name:e,encode:r,decode:e=>h(o(e))})}function S({name:e,prefix:t,bitsPerChar:n,alphabet:r}){const o=function(e){const t={};for(let n=0;n<e.length;++n)t[e[n]]=n;return t}(r);return b({prefix:t,name:e,encode:e=>function(e,t,n){const r="="===t[t.length-1],o=(1<<n)-1;let i="",s=0,a=0;for(let r=0;r<e.length;++r)for(a=a<<8|e[r],s+=8;s>n;)s-=n,i+=t[o&a>>s];if(0!==s&&(i+=t[o&a<<n-s]),r)for(;i.length*n&7;)i+="=";return i}(e,r,n),decode:t=>function(e,t,n,r){let o=e.length;for(;"="===e[o-1];)--o;const i=new Uint8Array(o*n/8|0);let s=0,a=0,c=0;for(let l=0;l<o;++l){const o=t[e[l]];if(void 0===o)throw new SyntaxError(`Non-${r} character`);a=a<<n|o,s+=n,s>=8&&(s-=8,i[c++]=255&a>>s)}if(s>=n||255&a<<8-s)throw new SyntaxError("Unexpected end of data");return i}(t,o,n,e)})}const C=S({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),A=(S({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),S({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),S({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),S({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),S({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),S({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),S({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),S({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),v({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"})),k=(v({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),v({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}));v({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var E=128,D=-128,P=Math.pow(2,31),U=128,I=127,_=Math.pow(2,7),x=Math.pow(2,14),$=Math.pow(2,21),M=Math.pow(2,28),B=Math.pow(2,35),T=Math.pow(2,42),N=Math.pow(2,49),R=Math.pow(2,56),F=Math.pow(2,63);const L={encode:function e(t,n,r){n=n||[];for(var o=r=r||0;t>=P;)n[r++]=255&t|E,t/=128;for(;t&D;)n[r++]=255&t|E,t>>>=7;return n[r]=0|t,e.bytes=r-o+1,n},decode:function e(t,n){var r,o=0,i=(n=n||0,0),s=n,a=t.length;do{if(s>=a)throw e.bytes=0,new RangeError("Could not decode varint");r=t[s++],o+=i<28?(r&I)<<i:(r&I)*Math.pow(2,i),i+=7}while(r>=U);return e.bytes=s-n,o},encodingLength:function(e){return e<_?1:e<x?2:e<$?3:e<M?4:e<B?5:e<T?6:e<N?7:e<R?8:e<F?9:10}};function z(e,t=0){return[L.decode(e,t),L.decode.bytes]}function O(e,t,n=0){return L.encode(e,t,n),t}function j(e){return L.encodingLength(e)}function H(e,t){const n=t.byteLength,r=j(e),o=r+j(n),i=new Uint8Array(o+n);return O(e,i,0),O(n,i,r),i.set(t,o),new V(e,n,t,i)}class V{code;size;digest;bytes;constructor(e,t,n,r){this.code=e,this.size=t,this.digest=n,this.bytes=r}}function W(e,t){const{bytes:n,version:r}=e;return 0===r?function(e,t,n){const{prefix:r}=n;if(r!==k.prefix)throw Error(`Cannot string encode V0 in ${n.name} encoding`);const o=t.get(r);if(null==o){const o=n.encode(e).slice(1);return t.set(r,o),o}return o}(n,G(e),t??k.encoder):function(e,t,n){const{prefix:r}=n,o=t.get(r);if(null==o){const o=n.encode(e);return t.set(r,o),o}return o}(n,G(e),t??C.encoder)}const q=new WeakMap;function G(e){const t=q.get(e);if(null==t){const t=new Map;return q.set(e,t),t}return t}class K{code;version;multihash;bytes;"/";constructor(e,t,n,r){this.code=t,this.version=e,this.multihash=n,this.bytes=r,this["/"]=r}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==J)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==Y)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return K.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=H(e,t);return K.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return K.equals(this,e)}static equals(e,t){const n=t;return null!=n&&e.code===n.code&&e.version===n.version&&function(e,t){if(e===t)return!0;{const n=t;return e.code===n.code&&e.size===n.size&&n.bytes instanceof Uint8Array&&d(e.bytes,n.bytes)}}(e.multihash,n.multihash)}toString(e){return W(this,e)}toJSON(){return{"/":W(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(null==e)return null;const t=e;if(t instanceof K)return t;if(null!=t["/"]&&t["/"]===t.bytes||t.asCID===t){const{version:e,code:n,multihash:r,bytes:o}=t;return new K(e,n,r,o??Q(e,n,r.bytes))}if(!0===t[Z]){const{version:e,multihash:n,code:r}=t,o=function(e){const t=h(e),[n,r]=z(t),[o,i]=z(t.subarray(r)),s=t.subarray(r+i);if(s.byteLength!==o)throw new Error("Incorrect length");return new V(n,o,s,t)}(n);return K.create(e,r,o)}return null}static create(e,t,n){if("number"!=typeof t)throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:if(t!==J)throw new Error(`Version 0 CID must use dag-pb (code: ${J}) block encoding`);return new K(e,t,n,n.bytes);case 1:{const r=Q(e,t,n.bytes);return new K(e,t,n,r)}default:throw new Error("Invalid version")}}static createV0(e){return K.create(0,J,e)}static createV1(e,t){return K.create(1,e,t)}static decode(e){const[t,n]=K.decodeFirst(e);if(0!==n.length)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=K.inspectBytes(e),n=t.size-t.multihashSize,r=h(e.subarray(n,n+t.multihashSize));if(r.byteLength!==t.multihashSize)throw new Error("Incorrect length");const o=r.subarray(t.multihashSize-t.digestSize),i=new V(t.multihashCode,t.digestSize,o,r);return[0===t.version?K.createV0(i):K.createV1(t.codec,i),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[n,r]=z(e.subarray(t));return t+=r,n};let r=n(),o=J;if(18===r?(r=0,t=0):o=n(),0!==r&&1!==r)throw new RangeError(`Invalid CID version ${r}`);const i=t,s=n(),a=n(),c=t+a;return{version:r,codec:o,multihashCode:s,digestSize:a,multihashSize:c-i,size:c}}static parse(e,t){const[n,r]=function(e,t){switch(e[0]){case"Q":{const n=t??k;return[k.prefix,n.decode(`${k.prefix}${e}`)]}case k.prefix:{const n=t??k;return[k.prefix,n.decode(e)]}case C.prefix:{const n=t??C;return[C.prefix,n.decode(e)]}case A.prefix:{const n=t??A;return[A.prefix,n.decode(e)]}default:if(null==t)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}}(e,t),o=K.decode(r);if(0===o.version&&"Q"!==e[0])throw Error("Version 0 CID string must not include multibase prefix");return G(o).set(n,e),o}}const J=112,Y=18;function Q(e,t,n){const r=j(e),o=r+j(t),i=new Uint8Array(o+n.byteLength);return O(e,i,0),O(t,i,r),i.set(n,o),i}const Z=Symbol.for("@ipld/js-cid/CID");class X{_data;_commp;_sp;_txHash;_withCDN;constructor(e,t){this._data=e instanceof ArrayBuffer?new Uint8Array(e):e,this._withCDN=t,console.log("[MockSynapse] UploadTask created with",this._data.length,"bytes (withCDN=",this._withCDN,")")}async commp(){if(console.log("[MockSynapse] UploadTask.commp() called"),null==this._commp){console.log("[MockSynapse] Generating mock CommP for",this._data.length,"bytes..."),console.log("[MockSynapse] Simulating CommP calculation delay..."),await new Promise((e=>setTimeout(e,100)));const e="baga6ea4seaqjtovkwk4myyzj56eztkh5pzsk5upksan6f5outesy62bsvl4dsha";this._commp=K.parse(e),console.log("[MockSynapse] CommP generated:",this._commp.toString())}else console.log("[MockSynapse] Returning cached CommP:",this._commp.toString());return this._commp}async store(){return console.log("[MockSynapse] UploadTask.store() called"),null==this._sp?(console.log("[MockSynapse] Ensuring CommP is generated before storage..."),await this.commp(),console.log("[MockSynapse] Negotiating with storage provider..."),this._sp="f01234",console.log("[MockSynapse] Selected storage provider:",this._sp),console.log("[MockSynapse] Simulating storage negotiation delay (500ms)..."),await new Promise((e=>setTimeout(e,500))),console.log("[MockSynapse] Storage negotiation complete")):console.log("[MockSynapse] Returning cached storage provider:",this._sp),this._sp}async done(){return console.log("[MockSynapse] UploadTask.done() called"),null==this._txHash?(console.log("[MockSynapse] Ensuring storage is complete before chain commit..."),await this.store(),console.log("[MockSynapse] Submitting transaction to blockchain..."),this._txHash="0x"+Array.from({length:64},(()=>Math.floor(16*Math.random()).toString(16))).join(""),console.log("[MockSynapse] Generated mock transaction hash:",this._txHash),console.log("[MockSynapse] Simulating blockchain confirmation delay (1000ms)..."),await new Promise((e=>setTimeout(e,1e3))),console.log("[MockSynapse] Transaction confirmed on chain")):console.log("[MockSynapse] Returning cached transaction hash:",this._txHash),this._txHash}}BigInt(4);const ee=127,te=BigInt(ee),ne=BigInt(128),re=.9921875,oe=32,ie=BigInt(oe),se=2*oe+1,ae=()=>ce,ce=(e=>{if(e instanceof Uint8Array){if(e.length>oe)return e.subarray(0,oe);if(e.length==oe)return e}const t=new Uint8Array(oe);return t.set([...e]),t})(new Uint8Array(oe).fill(0));function le(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function ue(e,t){!function(e,...t){if(!(e instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(e.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`)}(e);const n=t.outputLen;if(e.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}Object.freeze(ce.buffer);const de=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),he=(e,t)=>e<<32-t|e>>>t;if(68!==new Uint8Array(new Uint32Array([287454020]).buffer)[0])throw new Error("Non little-endian hardware is not supported");function fe(e){if("string"==typeof e&&(e=function(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}(e)),!(e instanceof Uint8Array))throw new Error("expected Uint8Array, got "+typeof e);return e}class pe{clone(){return this._cloneInto()}}function ge(e){const t=t=>e().update(fe(t)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}class we extends pe{constructor(e,t,n,r){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=de(this.buffer)}update(e){le(this);const{view:t,buffer:n,blockLen:r}=this,o=(e=fe(e)).length;for(let i=0;i<o;){const s=Math.min(r-this.pos,o-i);if(s!==r)n.set(e.subarray(i,i+s),this.pos),this.pos+=s,i+=s,this.pos===r&&(this.process(t,0),this.pos=0);else{const t=de(e);for(;r<=o-i;i+=r)this.process(t,i)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){le(this),ue(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:r,isLE:o}=this;let{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>r-i&&(this.process(n,0),i=0);for(let e=i;e<r;e++)t[e]=0;!function(e,t,n,r){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,n,r);const o=BigInt(32),i=BigInt(4294967295),s=Number(n>>o&i),a=Number(n&i),c=r?4:0,l=r?0:4;e.setUint32(t+c,s,r),e.setUint32(t+l,a,r)}(n,r-8,BigInt(8*this.length),o),this.process(n,0);const s=de(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const c=a/4,l=this.get();if(c>l.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<c;e++)s.setUint32(4*e,l[e],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:r,finished:o,destroyed:i,pos:s}=this;return e.length=r,e.pos=s,e.finished=o,e.destroyed=i,r%t&&e.buffer.set(n),e}}const ye=(e,t,n)=>e&t^e&n^t&n,me=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),be=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ve=new Uint32Array(64);class Se extends we{constructor(){super(64,32,8,!1),this.A=0|be[0],this.B=0|be[1],this.C=0|be[2],this.D=0|be[3],this.E=0|be[4],this.F=0|be[5],this.G=0|be[6],this.H=0|be[7]}get(){const{A:e,B:t,C:n,D:r,E:o,F:i,G:s,H:a}=this;return[e,t,n,r,o,i,s,a]}set(e,t,n,r,o,i,s,a){this.A=0|e,this.B=0|t,this.C=0|n,this.D=0|r,this.E=0|o,this.F=0|i,this.G=0|s,this.H=0|a}process(e,t){for(let n=0;n<16;n++,t+=4)ve[n]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=ve[e-15],n=ve[e-2],r=he(t,7)^he(t,18)^t>>>3,o=he(n,17)^he(n,19)^n>>>10;ve[e]=o+ve[e-7]+r+ve[e-16]|0}let{A:n,B:r,C:o,D:i,E:s,F:a,G:c,H:l}=this;for(let e=0;e<64;e++){const t=l+(he(s,6)^he(s,11)^he(s,25))+((u=s)&a^~u&c)+me[e]+ve[e]|0,d=(he(n,2)^he(n,13)^he(n,22))+ye(n,r,o)|0;l=c,c=a,a=s,s=i+t|0,i=o,o=r,r=n,n=t+d|0}var u;n=n+this.A|0,r=r+this.B|0,o=o+this.C|0,i=i+this.D|0,s=s+this.E|0,a=a+this.F|0,c=c+this.G|0,l=l+this.H|0,this.set(n,r,o,i,s,a,c,l)}roundClean(){ve.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Ce=ge((()=>new Se)),Ae="sha2-256",ke=32,Ee=new Uint8Array([18,32]);class De{constructor(e){this.code=18,this.name=Ae,this.bytes=e,this.size=ke,this.digest=e.subarray(2)}}const Pe=e=>{const t=new Uint8Array(Ee.length+ke);return t.set(Ee,0),t.set(Ce(e),Ee.length),new De(t)},Ue=18,Ie=["string","number","bigint","symbol"],_e=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];class xe{constructor(e,t,n){this.major=e,this.majorEncoded=e<<5,this.name=t,this.terminal=n}toString(){return`Type[${this.major}].${this.name}`}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}}xe.uint=new xe(0,"uint",!0),xe.negint=new xe(1,"negint",!0),xe.bytes=new xe(2,"bytes",!0),xe.string=new xe(3,"string",!0),xe.array=new xe(4,"array",!1),xe.map=new xe(5,"map",!1),xe.tag=new xe(6,"tag",!1),xe.float=new xe(7,"float",!0),xe.false=new xe(7,"false",!0),xe.true=new xe(7,"true",!0),xe.null=new xe(7,"null",!0),xe.undefined=new xe(7,"undefined",!0),xe.break=new xe(7,"break",!0);class $e{constructor(e,t,n){this.type=e,this.value=t,this.encodedLength=n,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}}const Me=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&"function"==typeof globalThis.Buffer.isBuffer,Be=new TextDecoder,Te=new TextEncoder;function Ne(e){return Me&&globalThis.Buffer.isBuffer(e)}const Re=Me?(e,t,n)=>n-t>64?globalThis.Buffer.from(e.subarray(t,n)).toString("utf8"):He(e,t,n):(e,t,n)=>n-t>64?Be.decode(e.subarray(t,n)):He(e,t,n),Fe=Me?e=>e.length>64?globalThis.Buffer.from(e):je(e):e=>e.length>64?Te.encode(e):je(e),Le=Me?(e,t,n)=>Ne(e)?new Uint8Array(e.subarray(t,n)):e.slice(t,n):(e,t,n)=>e.slice(t,n),ze=Me?(e,t)=>{return e=e.map((e=>e instanceof Uint8Array?e:globalThis.Buffer.from(e))),(n=globalThis.Buffer.concat(e,t))instanceof Uint8Array?Ne(n)?new Uint8Array(n.buffer,n.byteOffset,n.byteLength):n:Uint8Array.from(n);var n}:(e,t)=>{const n=new Uint8Array(t);let r=0;for(let t of e)r+t.length>n.length&&(t=t.subarray(0,n.length-r)),n.set(t,r),r+=t.length;return n},Oe=Me?e=>globalThis.Buffer.allocUnsafe(e):e=>new Uint8Array(e);function je(e){const t=[];let n=0;for(let r=0;r<e.length;r++){let o=e.charCodeAt(r);o<128?t[n++]=o:o<2048?(t[n++]=o>>6|192,t[n++]=63&o|128):55296==(64512&o)&&r+1<e.length&&56320==(64512&e.charCodeAt(r+1))?(o=65536+((1023&o)<<10)+(1023&e.charCodeAt(++r)),t[n++]=o>>18|240,t[n++]=o>>12&63|128,t[n++]=o>>6&63|128,t[n++]=63&o|128):(t[n++]=o>>12|224,t[n++]=o>>6&63|128,t[n++]=63&o|128)}return t}function He(e,t,n){const r=[];for(;t<n;){const o=e[t];let i=null,s=o>239?4:o>223?3:o>191?2:1;if(t+s<=n){let n,r,a,c;switch(s){case 1:o<128&&(i=o);break;case 2:n=e[t+1],128==(192&n)&&(c=(31&o)<<6|63&n,c>127&&(i=c));break;case 3:n=e[t+1],r=e[t+2],128==(192&n)&&128==(192&r)&&(c=(15&o)<<12|(63&n)<<6|63&r,c>2047&&(c<55296||c>57343)&&(i=c));break;case 4:n=e[t+1],r=e[t+2],a=e[t+3],128==(192&n)&&128==(192&r)&&128==(192&a)&&(c=(15&o)<<18|(63&n)<<12|(63&r)<<6|63&a,c>65535&&c<1114112&&(i=c))}}null===i?(i=65533,s=1):i>65535&&(i-=65536,r.push(i>>>10&1023|55296),i=56320|1023&i),r.push(i),t+=s}return function(e){const t=e.length;if(t<=Ve)return String.fromCharCode.apply(String,e);let n="",r=0;for(;r<t;)n+=String.fromCharCode.apply(String,e.slice(r,r+=Ve));return n}(r)}const Ve=4096;const We="CBOR decode error:",qe="CBOR encode error:",Ge=[];function Ke(e,t,n){if(e.length-t<n)throw new Error(`${We} not enough data for type`)}Ge[23]=1,Ge[24]=2,Ge[25]=3,Ge[26]=5,Ge[27]=9;const Je=[24,256,65536,4294967296,BigInt("18446744073709551616")];function Ye(e,t,n){Ke(e,t,1);const r=e[t];if(!0===n.strict&&r<Je[0])throw new Error(`${We} integer encoded in more bytes than necessary (strict decode)`);return r}function Qe(e,t,n){Ke(e,t,2);const r=e[t]<<8|e[t+1];if(!0===n.strict&&r<Je[1])throw new Error(`${We} integer encoded in more bytes than necessary (strict decode)`);return r}function Ze(e,t,n){Ke(e,t,4);const r=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3];if(!0===n.strict&&r<Je[2])throw new Error(`${We} integer encoded in more bytes than necessary (strict decode)`);return r}function Xe(e,t,n){Ke(e,t,8);const r=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3],o=16777216*e[t+4]+(e[t+5]<<16)+(e[t+6]<<8)+e[t+7],i=(BigInt(r)<<BigInt(32))+BigInt(o);if(!0===n.strict&&i<Je[3])throw new Error(`${We} integer encoded in more bytes than necessary (strict decode)`);if(i<=Number.MAX_SAFE_INTEGER)return Number(i);if(!0===n.allowBigInt)return i;throw new Error(`${We} integers outside of the safe integer range are not supported`)}function et(e,t){return tt(e,0,t.value)}function tt(e,t,n){if(n<Je[0]){const r=Number(n);e.push([t|r])}else if(n<Je[1]){const r=Number(n);e.push([24|t,r])}else if(n<Je[2]){const r=Number(n);e.push([25|t,r>>>8,255&r])}else if(n<Je[3]){const r=Number(n);e.push([26|t,r>>>24&255,r>>>16&255,r>>>8&255,255&r])}else{const r=BigInt(n);if(!(r<Je[4]))throw new Error(`${We} encountered BigInt larger than allowable range`);{const n=[27|t,0,0,0,0,0,0,0];let o=Number(r&BigInt(4294967295)),i=Number(r>>BigInt(32)&BigInt(4294967295));n[8]=255&o,o>>=8,n[7]=255&o,o>>=8,n[6]=255&o,o>>=8,n[5]=255&o,n[4]=255&i,i>>=8,n[3]=255&i,i>>=8,n[2]=255&i,i>>=8,n[1]=255&i,e.push(n)}}}et.encodedSize=function(e){return tt.encodedSize(e.value)},tt.encodedSize=function(e){return e<Je[0]?1:e<Je[1]?2:e<Je[2]?3:e<Je[3]?5:9},et.compareTokens=function(e,t){return e.value<t.value?-1:e.value>t.value?1:0};const nt=BigInt(-1),rt=BigInt(1);function ot(e,t){const n=t.value,r="bigint"==typeof n?n*nt-rt:-1*n-1;tt(e,t.type.majorEncoded,r)}function it(e,t,n,r){Ke(e,t,n+r);const o=Le(e,t+n,t+n+r);return new $e(xe.bytes,o,n+r)}function st(e,t,n,r){return it(e,t,1,n)}function at(e){return void 0===e.encodedBytes&&(e.encodedBytes=e.type===xe.string?Fe(e.value):e.value),e.encodedBytes}function ct(e,t){const n=at(t);tt(e,t.type.majorEncoded,n.length),e.push(n)}function lt(e,t,n,r,o){const i=n+r;Ke(e,t,i);const s=new $e(xe.string,Re(e,t+n,t+i),i);return!0===o.retainStringBytes&&(s.byteValue=Le(e,t+n,t+i)),s}function ut(e,t,n,r){return lt(e,t,1,n,r)}ot.encodedSize=function(e){const t=e.value,n="bigint"==typeof t?t*nt-rt:-1*t-1;return n<Je[0]?1:n<Je[1]?2:n<Je[2]?3:n<Je[3]?5:9},ot.compareTokens=function(e,t){return e.value<t.value?1:e.value>t.value?-1:0},ct.encodedSize=function(e){const t=at(e);return tt.encodedSize(t.length)+t.length},ct.compareTokens=function(e,t){return n=at(e),r=at(t),n.length<r.length?-1:n.length>r.length?1:function(e,t){if(Ne(e)&&Ne(t))return e.compare(t);for(let n=0;n<e.length;n++)if(e[n]!==t[n])return e[n]<t[n]?-1:1;return 0}(n,r);var n,r};const dt=ct;function ht(e,t,n,r){return new $e(xe.array,r,n)}function ft(e,t,n,r){return ht(0,0,1,n)}function pt(e,t){tt(e,xe.array.majorEncoded,t.value)}function gt(e,t,n,r){return new $e(xe.map,r,n)}function wt(e,t,n,r){return gt(0,0,1,n)}function yt(e,t){tt(e,xe.map.majorEncoded,t.value)}function mt(e,t,n,r){return new $e(xe.tag,n,1)}function bt(e,t){tt(e,xe.tag.majorEncoded,t.value)}function vt(e,t,n){if(n){if(!1===n.allowNaN&&Number.isNaN(e))throw new Error(`${We} NaN values are not supported`);if(!1===n.allowInfinity&&(e===1/0||e===-1/0))throw new Error(`${We} Infinity values are not supported`)}return new $e(xe.float,e,t)}function St(e,t,n){const r=t.value;if(!1===r)e.push([20|xe.float.majorEncoded]);else if(!0===r)e.push([21|xe.float.majorEncoded]);else if(null===r)e.push([22|xe.float.majorEncoded]);else if(void 0===r)e.push([23|xe.float.majorEncoded]);else{let t,i=!1;n&&!0===n.float64||(Et(r),t=Dt(kt,1),r===t||Number.isNaN(r)?(kt[0]=249,e.push(kt.slice(0,3)),i=!0):(Pt(r),t=Ut(kt,1),r===t&&(kt[0]=250,e.push(kt.slice(0,5)),i=!0))),i||(o=r,At.setFloat64(0,o,!1),t=It(kt,1),kt[0]=251,e.push(kt.slice(0,9)))}var o}pt.compareTokens=et.compareTokens,pt.encodedSize=function(e){return tt.encodedSize(e.value)},yt.compareTokens=et.compareTokens,yt.encodedSize=function(e){return tt.encodedSize(e.value)},bt.compareTokens=et.compareTokens,bt.encodedSize=function(e){return tt.encodedSize(e.value)},St.encodedSize=function(e,t){const n=e.value;if(!1===n||!0===n||null==n)return 1;if(!t||!0!==t.float64){Et(n);let e=Dt(kt,1);if(n===e||Number.isNaN(n))return 3;if(Pt(n),e=Ut(kt,1),n===e)return 5}return 9};const Ct=new ArrayBuffer(9),At=new DataView(Ct,1),kt=new Uint8Array(Ct,0);function Et(e){if(e===1/0)At.setUint16(0,31744,!1);else if(e===-1/0)At.setUint16(0,64512,!1);else if(Number.isNaN(e))At.setUint16(0,32256,!1);else{At.setFloat32(0,e);const t=At.getUint32(0),n=(2139095040&t)>>23,r=8388607&t;if(255===n)At.setUint16(0,31744,!1);else if(0===n)At.setUint16(0,(2147483648&e)>>16|r>>13,!1);else{const e=n-127;e<-24?At.setUint16(0,0):e<-14?At.setUint16(0,(2147483648&t)>>16|1<<24+e,!1):At.setUint16(0,(2147483648&t)>>16|e+15<<10|r>>13,!1)}}}function Dt(e,t){if(e.length-t<2)throw new Error(`${We} not enough data for float16`);const n=(e[t]<<8)+e[t+1];if(31744===n)return 1/0;if(64512===n)return-1/0;if(32256===n)return NaN;const r=n>>10&31,o=1023&n;let i;return i=0===r?o*2**-24:31!==r?(o+1024)*2**(r-25):0===o?1/0:NaN,32768&n?-i:i}function Pt(e){At.setFloat32(0,e,!1)}function Ut(e,t){if(e.length-t<4)throw new Error(`${We} not enough data for float32`);const n=(e.byteOffset||0)+t;return new DataView(e.buffer,n,4).getFloat32(0,!1)}function It(e,t){if(e.length-t<8)throw new Error(`${We} not enough data for float64`);const n=(e.byteOffset||0)+t;return new DataView(e.buffer,n,8).getFloat64(0,!1)}function _t(e,t,n){throw new Error(`${We} encountered invalid minor (${n}) for major ${e[t]>>>5}`)}function xt(e){return()=>{throw new Error(`${We} ${e}`)}}St.compareTokens=et.compareTokens;const $t=[];for(let e=0;e<=23;e++)$t[e]=_t;$t[24]=function(e,t,n,r){return new $e(xe.uint,Ye(e,t+1,r),2)},$t[25]=function(e,t,n,r){return new $e(xe.uint,Qe(e,t+1,r),3)},$t[26]=function(e,t,n,r){return new $e(xe.uint,Ze(e,t+1,r),5)},$t[27]=function(e,t,n,r){return new $e(xe.uint,Xe(e,t+1,r),9)},$t[28]=_t,$t[29]=_t,$t[30]=_t,$t[31]=_t;for(let e=32;e<=55;e++)$t[e]=_t;$t[56]=function(e,t,n,r){return new $e(xe.negint,-1-Ye(e,t+1,r),2)},$t[57]=function(e,t,n,r){return new $e(xe.negint,-1-Qe(e,t+1,r),3)},$t[58]=function(e,t,n,r){return new $e(xe.negint,-1-Ze(e,t+1,r),5)},$t[59]=function(e,t,n,r){const o=Xe(e,t+1,r);if("bigint"!=typeof o){const e=-1-o;if(e>=Number.MIN_SAFE_INTEGER)return new $e(xe.negint,e,9)}if(!0!==r.allowBigInt)throw new Error(`${We} integers outside of the safe integer range are not supported`);return new $e(xe.negint,nt-BigInt(o),9)},$t[60]=_t,$t[61]=_t,$t[62]=_t,$t[63]=_t;for(let e=64;e<=87;e++)$t[e]=st;$t[88]=function(e,t,n,r){return it(e,t,2,Ye(e,t+1,r))},$t[89]=function(e,t,n,r){return it(e,t,3,Qe(e,t+1,r))},$t[90]=function(e,t,n,r){return it(e,t,5,Ze(e,t+1,r))},$t[91]=function(e,t,n,r){const o=Xe(e,t+1,r);if("bigint"==typeof o)throw new Error(`${We} 64-bit integer bytes lengths not supported`);return it(e,t,9,o)},$t[92]=_t,$t[93]=_t,$t[94]=_t,$t[95]=xt("indefinite length bytes/strings are not supported");for(let e=96;e<=119;e++)$t[e]=ut;$t[120]=function(e,t,n,r){return lt(e,t,2,Ye(e,t+1,r),r)},$t[121]=function(e,t,n,r){return lt(e,t,3,Qe(e,t+1,r),r)},$t[122]=function(e,t,n,r){return lt(e,t,5,Ze(e,t+1,r),r)},$t[123]=function(e,t,n,r){const o=Xe(e,t+1,r);if("bigint"==typeof o)throw new Error(`${We} 64-bit integer string lengths not supported`);return lt(e,t,9,o,r)},$t[124]=_t,$t[125]=_t,$t[126]=_t,$t[127]=xt("indefinite length bytes/strings are not supported");for(let e=128;e<=151;e++)$t[e]=ft;$t[152]=function(e,t,n,r){return ht(0,0,2,Ye(e,t+1,r))},$t[153]=function(e,t,n,r){return ht(0,0,3,Qe(e,t+1,r))},$t[154]=function(e,t,n,r){return ht(0,0,5,Ze(e,t+1,r))},$t[155]=function(e,t,n,r){const o=Xe(e,t+1,r);if("bigint"==typeof o)throw new Error(`${We} 64-bit integer array lengths not supported`);return ht(0,0,9,o)},$t[156]=_t,$t[157]=_t,$t[158]=_t,$t[159]=function(e,t,n,r){if(!1===r.allowIndefinite)throw new Error(`${We} indefinite length items not allowed`);return ht(0,0,1,1/0)};for(let e=160;e<=183;e++)$t[e]=wt;$t[184]=function(e,t,n,r){return gt(0,0,2,Ye(e,t+1,r))},$t[185]=function(e,t,n,r){return gt(0,0,3,Qe(e,t+1,r))},$t[186]=function(e,t,n,r){return gt(0,0,5,Ze(e,t+1,r))},$t[187]=function(e,t,n,r){const o=Xe(e,t+1,r);if("bigint"==typeof o)throw new Error(`${We} 64-bit integer map lengths not supported`);return gt(0,0,9,o)},$t[188]=_t,$t[189]=_t,$t[190]=_t,$t[191]=function(e,t,n,r){if(!1===r.allowIndefinite)throw new Error(`${We} indefinite length items not allowed`);return gt(0,0,1,1/0)};for(let e=192;e<=215;e++)$t[e]=mt;$t[216]=function(e,t,n,r){return new $e(xe.tag,Ye(e,t+1,r),2)},$t[217]=function(e,t,n,r){return new $e(xe.tag,Qe(e,t+1,r),3)},$t[218]=function(e,t,n,r){return new $e(xe.tag,Ze(e,t+1,r),5)},$t[219]=function(e,t,n,r){return new $e(xe.tag,Xe(e,t+1,r),9)},$t[220]=_t,$t[221]=_t,$t[222]=_t,$t[223]=_t;for(let e=224;e<=243;e++)$t[e]=xt("simple values are not supported");$t[244]=_t,$t[245]=_t,$t[246]=_t,$t[247]=function(e,t,n,r){if(!1===r.allowUndefined)throw new Error(`${We} undefined values are not supported`);return!0===r.coerceUndefinedToNull?new $e(xe.null,null,1):new $e(xe.undefined,void 0,1)},$t[248]=xt("simple values are not supported"),$t[249]=function(e,t,n,r){return vt(Dt(e,t+1),3,r)},$t[250]=function(e,t,n,r){return vt(Ut(e,t+1),5,r)},$t[251]=function(e,t,n,r){return vt(It(e,t+1),9,r)},$t[252]=_t,$t[253]=_t,$t[254]=_t,$t[255]=function(e,t,n,r){if(!1===r.allowIndefinite)throw new Error(`${We} indefinite length items not allowed`);return new $e(xe.break,void 0,1)};const Mt=[];for(let e=0;e<24;e++)Mt[e]=new $e(xe.uint,e,1);for(let e=-1;e>=-24;e--)Mt[31-e]=new $e(xe.negint,e,1);Mt[64]=new $e(xe.bytes,new Uint8Array(0),1),Mt[96]=new $e(xe.string,"",1),Mt[128]=new $e(xe.array,0,1),Mt[160]=new $e(xe.map,0,1),Mt[244]=new $e(xe.false,!1,1),Mt[245]=new $e(xe.true,!0,1),Mt[246]=new $e(xe.null,null,1),function(){const e=[];e[xe.uint.major]=et,e[xe.negint.major]=ot,e[xe.bytes.major]=ct,e[xe.string.major]=dt,e[xe.array.major]=pt,e[xe.map.major]=yt,e[xe.tag.major]=bt,e[xe.float.major]=St}(),new class{constructor(e=256){this.chunkSize=e,this.cursor=0,this.maxCursor=-1,this.chunks=[],this._initReuseChunk=null}reset(){this.cursor=0,this.maxCursor=-1,this.chunks.length&&(this.chunks=[]),null!==this._initReuseChunk&&(this.chunks.push(this._initReuseChunk),this.maxCursor=this._initReuseChunk.length-1)}push(e){let t=this.chunks[this.chunks.length-1];if(this.cursor+e.length<=this.maxCursor+1){const n=t.length-(this.maxCursor-this.cursor)-1;t.set(e,n)}else{if(t){const e=t.length-(this.maxCursor-this.cursor)-1;e<t.length&&(this.chunks[this.chunks.length-1]=t.subarray(0,e),this.maxCursor=this.cursor-1)}e.length<64&&e.length<this.chunkSize?(t=Oe(this.chunkSize),this.chunks.push(t),this.maxCursor+=t.length,null===this._initReuseChunk&&(this._initReuseChunk=t),t.set(e,0)):(this.chunks.push(e),this.maxCursor+=e.length)}this.cursor+=e.length}toBytes(e=!1){let t;if(1===this.chunks.length){const n=this.chunks[0];e&&this.cursor>n.length/2?(t=this.cursor===n.length?n:n.subarray(0,this.cursor),this._initReuseChunk=null,this.chunks=[]):t=Le(n,0,this.cursor)}else t=ze(this.chunks,this.cursor);return e&&this.reset(),t}};class Bt{constructor(e,t){this.obj=e,this.parent=t}includes(e){let t=this;do{if(t.obj===e)return!0}while(t=t.parent);return!1}static createCheck(e,t){if(e&&e.includes(t))throw new Error(`${qe} object contains circular references`);return new Bt(t,e)}}const Tt={null:new $e(xe.null,null),undefined:new $e(xe.undefined,void 0),true:new $e(xe.true,!0),false:new $e(xe.false,!1),emptyArray:new $e(xe.array,0),emptyMap:new $e(xe.map,0)},Nt={number:(e,t,n,r)=>Number.isInteger(e)&&Number.isSafeInteger(e)?new $e(e>=0?xe.uint:xe.negint,e):new $e(xe.float,e),bigint:(e,t,n,r)=>e>=BigInt(0)?new $e(xe.uint,e):new $e(xe.negint,e),Uint8Array:(e,t,n,r)=>new $e(xe.bytes,e),string:(e,t,n,r)=>new $e(xe.string,e),boolean:(e,t,n,r)=>e?Tt.true:Tt.false,null:(e,t,n,r)=>Tt.null,undefined:(e,t,n,r)=>Tt.undefined,ArrayBuffer:(e,t,n,r)=>new $e(xe.bytes,new Uint8Array(e)),DataView:(e,t,n,r)=>new $e(xe.bytes,new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),Array(e,t,n,r){if(!e.length)return!0===n.addBreakTokens?[Tt.emptyArray,new $e(xe.break)]:Tt.emptyArray;r=Bt.createCheck(r,e);const o=[];let i=0;for(const t of e)o[i++]=Rt(t,n,r);return n.addBreakTokens?[new $e(xe.array,e.length),o,new $e(xe.break)]:[new $e(xe.array,e.length),o]},Object(e,t,n,r){const o="Object"!==t,i=o?e.keys():Object.keys(e),s=o?e.size:i.length;if(!s)return!0===n.addBreakTokens?[Tt.emptyMap,new $e(xe.break)]:Tt.emptyMap;r=Bt.createCheck(r,e);const a=[];let c=0;for(const t of i)a[c++]=[Rt(t,n,r),Rt(o?e.get(t):e[t],n,r)];return function(e,t){t.mapSorter&&e.sort(t.mapSorter)}(a,n),n.addBreakTokens?[new $e(xe.map,s),a,new $e(xe.break)]:[new $e(xe.map,s),a]}};Nt.Map=Nt.Object,Nt.Buffer=Nt.Uint8Array;for(const e of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))Nt[`${e}Array`]=Nt.DataView;function Rt(e,t={},n){const r=function(e){if(null===e)return"null";if(void 0===e)return"undefined";if(!0===e||!1===e)return"boolean";const t=typeof e;if(Ie.includes(t))return t;if("function"===t)return"Function";if(Array.isArray(e))return"Array";if(function(e){return e&&e.constructor&&e.constructor.isBuffer&&e.constructor.isBuffer.call(null,e)}(e))return"Buffer";return function(e){const t=Object.prototype.toString.call(e).slice(8,-1);if(_e.includes(t))return t}(e)||"Object"}(e),o=t&&t.typeEncoders&&t.typeEncoders[r]||Nt[r];if("function"==typeof o){const i=o(e,r,t,n);if(null!=i)return i}const i=Nt[r];if(!i)throw new Error(`${qe} unsupported type: ${r}`);return i(e,r,t,n)}Symbol.for("DONE"),Symbol.for("BREAK");const Ft={allowIndefinite:!1,coerceUndefinedToNull:!0,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,rejectDuplicateMapKeys:!0,tags:[]};Ft.tags[42]=function(e){if(0!==e[0])throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");return K.decode(e.subarray(1))},Ft.tags.slice();const Lt=([,e])=>e,zt=([e])=>e,Ot=e=>Lt(e).length,jt=(e,{tree:t,node:n})=>{const r=Vt(e,n);return r.error?{error:new Error(`computing root: ${r.error.message}`)}:d(r.ok,t)?{ok:{}}:{error:new Error("inclusion proof does not lead to the same root")}},Ht=63;function Vt(e,t){if(Ot(e)>Ht)return{error:new RangeError("merkle proofs with depths greater than 63 are not supported")};let n=zt(e);if(n>>BigInt(Ot(e))!==0n)return{error:new RangeError("offset greater than width of the tree")};let r=t,o=0n;for(const t of Lt(e))o=1n&n,n>>=1n,r=1n===o?qt(t,r):qt(r,t);return{ok:r}}function Wt(e,t={}){const r=t.hasher||n,{digest:o}=r.digest(e);return Gt(o)}const qt=(e,t,n)=>{const r=new Uint8Array(e.length+t.length);return r.set(e,0),r.set(t,e.length),Wt(r,n)};function Gt(e){return e[oe-1]&=63,e}const Kt=({offset:e,path:t})=>[e,t],Jt=e=>{const[t,n]=Array.isArray(e)?e:[e.offset,e.path];return Kt({offset:BigInt(t),path:n})},Yt=(e,t,n)=>{if(t<0)throw new RangeError("level can not be negative");if(t>e)throw new RangeError(`level too high: ${t} >= ${e}`);if(n>(1<<e-t)-1)throw new RangeError(`index too large for level: idx ${n}, level ${t} : ${(1<<e-t)-1}`)},Qt=e=>{return 2n**BigInt((t=(e+te-1n)/te)<=1n?0:(e=>{let t=0n;for(;e>>=1n;)t++;return Number(t)})(BigInt(t)-1n)+1);var t},Zt=e=>Xt(2n**BigInt(e)),Xt=e=>e*ie,en=4113,tn=ke,nn=10+ke,rn=j(en),on=rn+j(nn)+nn;Zt(255),BigInt(254),BigInt(256);class sn{constructor(e){this.bytes=e;const[t]=z(e);if(t!==en)throw new RangeError("Expected multihash with code 4113");let n=rn;const[r,o]=z(e,n);n+=o;const i=e.subarray(n);if(i.length!==r)throw new RangeError(`Invalid multihash size expected ${n+r} bytes, got ${e.length} bytes`);this.digest=i}get name(){return"fr32-sha2-256-trunc254-padded-binary-tree"}get code(){return en}get size(){return this.digest.length}get padding(){return(({digest:e})=>{const[t]=z(e);return BigInt(t)})(this)}get height(){return(({digest:e})=>{const[,t]=z(e);return e[t]})(this)}get root(){return(({digest:e})=>{const[,t]=z(e);return e.subarray(t+1,t+1+ke)})(this)}}const an=new class{constructor(){this.bytes=new Uint8Array(64*oe),this.bytes.set(ae(),0),this.node=ae(),this.length=oe}slice(e,t){for(;this.length<t;)this.node=qt(this.node,this.node),this.bytes.set(this.node,this.length),this.length+=oe;return this.bytes.subarray(e,t)}},cn=e=>{if(e<0||e>=64)throw new Error("Only levels between 0 and 63 inclusive are available");return an.slice(oe*e,oe*(e+1))},ln=e=>{const t=e.length/oe,n=new Array(t);for(let r=0;r<t;r++){const t=r*oe,o=e.subarray(t,t+oe);n[r]=o}return n};function un(e){const t=Math.max(e,se),n=Math.floor(Math.log2(t)),r=Math.ceil(re*2**(n+1));return t<=r?r:Math.ceil(re*2**(n+2))}const dn=(e,t=new Uint8Array((e=>un(e)/re)(e.length)))=>{const n=un(e.byteLength)/ee;for(let r=0;r<n;r++){const n=r*ee,o=128*r;t.set(e.subarray(n,n+32),o),t[o+31]&=63;for(let r=32;r<64;r++)t[o+r]=e[n+r]<<2|e[n+r-1]>>6;t[o+63]&=63;for(let r=64;r<96;r++)t[o+r]=e[n+r]<<4|e[n+r-1]>>4;t[o+95]&=63;for(let r=96;r<127;r++)t[o+r]=e[n+r]<<6|e[n+r-1]>>2;t[o+127]=e[n+126]>>2}return t},hn=Zt(255)*BigInt(254)/BigInt(256),fn=()=>new pn;class pn{constructor(){this.bytesWritten=0n,this.buffer=new Uint8Array(ee),this.offset=0,this.layers=[[]]}count(){return this.bytesWritten}digest(){const e=new Uint8Array(on),t=this.digestInto(e,0,!0);return(e=>new sn(e))(e.subarray(0,t))}digestInto(e,t=0,n=!0){const{buffer:r,layers:o,offset:i,bytesWritten:s}=this;let[a,...c]=o;(i>0||0n===s)&&(a=[...a,...ln(dn(r.fill(0,i)))]);const l=wn([a,...c]),u=l.length-1,[d]=l[u],h=Number((e=>(e=>Qt(e)*te)(e)-e)(this.bytesWritten)),f=j(h);let p=t;if(n){O(4113,e,p),p+=rn;const t=f+1+tn,n=j(t);O(t,e,p),p+=n}return O(h,e,p),p+=f,e[p]=u,p+=1,e.set(d,p),p+=d.length,p-t}write(e){const{buffer:t,offset:n,layers:r}=this,o=r[0],{length:i}=e;if(0===i)return this;if(this.bytesWritten+BigInt(i)>hn)throw new RangeError(`Writing ${i} bytes exceeds max payload size of ${hn}`);if(n+i<t.length)return t.set(e,n),this.offset+=i,this.bytesWritten+=BigInt(i),this;{const r=t.length-n;t.set(e.subarray(0,r),n),o.push(...ln(dn(t)));let s=r;for(;s+ee<i;){const t=e.subarray(s,s+ee);o.push(...ln(dn(t))),s+=ee}return this.buffer.set(e.subarray(s),0),this.offset=i-s,this.bytesWritten+=BigInt(i),gn(this.layers),this}}reset(){return this.offset=0,this.bytesWritten=0n,this.layers.length=1,this.layers[0].length=0,this}dispose(){this.reset()}get code(){return 4113}get name(){return"fr32-sha2-256-trunc254-padded-binary-tree"}}const gn=e=>yn(e,!1),wn=e=>yn([...e],!0),yn=(e,t)=>{let n=0;for(;n<e.length;){let r=e[n+1];const o=e[n];t&&o.length%2>0&&r&&o.push(cn(n)),n+=1,r=r?t?[...r]:r:[];let i=0;for(;i+1<o.length;){const e=qt(o[i],o[i+1]);delete o[i],delete o[i+1],r.push(e),i+=2}r.length&&(e[n]=r),o.splice(0,i)}return e};BigInt(256);const mn=16,bn=8,{y1:vn,tD:Sn}=o,Cn=BigInt(oe+vn+vn+Sn);BigInt(oe),Number(Cn),Zt(60),(()=>{const e=(e=>{const t=BigInt(e);return t<ne?{error:RangeError(`Minimum piece size is ${ne} bytes`)}:1!==(e=>{let t=0;for(let n=0n;n<64n;n++)0n!=(e&1n<<n)&&t++;return t})(t)?{error:RangeError("Piece size must be a power of 2")}:{ok:t}})(2n**35n);if(e.error)throw e.error;e.ok})();const An=61697,kn=4114;function En(e){return un(e)}function Dn(e){return"string"==typeof e?function(e){try{const t=K.parse(e);return t.code!==An||t.multihash.code!==kn?null:t}catch{return null}}(e):"object"==typeof e&&null!==K.asCID(e)?(t=e).code!==An||t.multihash.code!==kn?null:e:null;var t}function Pn(e){const t=H(kn,e.bytes.subarray(e.bytes.length-tn));return K.create(1,An,t)}function Un(e){const t=fn();for(let n=0;n<e.length;n+=2048)t.write(e.subarray(n,n+2048));return Pn(t.digest())}function In(){const e=fn();let t=!1,n=null;return{stream:new TransformStream({transform(t,n){e.write(t),n.enqueue(t)},flush(){const r=e.digest();n=Pn(r),t=!0}}),getCommP:()=>t?n:null}}class _n{proofSetId;storageProvider;_storedData=new Map;_signerAddress;_withCDN;constructor(e,t,n,r){this.proofSetId=e,this.storageProvider=t,this._signerAddress=n,this._withCDN=r}upload(e){console.log("[MockSynapse] StorageService.upload() called"),console.log("[MockSynapse] Data size:",e instanceof ArrayBuffer?e.byteLength:e.length,"bytes");const t=new X(e,this._withCDN);return(async()=>{console.log("[MockSynapse] Storing data internally for mock retrieval...");const n=await t.commp(),r=e instanceof ArrayBuffer?new Uint8Array(e):e;this._storedData.set(n.toString(),r),console.log("[MockSynapse] Data stored with CommP:",n.toString())})().catch((()=>{})),t}async download(e,t){const n=Dn(e);if(null==n)throw new Error("Invalid CommP provided");const r=n.toString();if(console.log("[MockSynapse] StorageService.download() called"),console.log("[MockSynapse] CommP:",r),console.log("[MockSynapse] Download options:",t),!1!==t?.withCDN&&(this._withCDN||t?.withCDN)){console.log("[MockSynapse] Using CDN for download (withCDN=true)");const e=await fetch(`https://${this._signerAddress}.calibration.filcdn.io/${r}`);return new Uint8Array(await e.arrayBuffer())}console.log("[MockSynapse] Simulating download network delay (300ms)..."),await new Promise((e=>setTimeout(e,300))),console.log("[MockSynapse] Looking up data in mock storage...");const o=this._storedData.get(r);if(null==o)throw console.log("[MockSynapse] Data not found in mock storage!"),new Error(`Data not found for CommP: ${r}`);return console.log("[MockSynapse] Data found, size:",o.length,"bytes"),!0!==t?.noVerify?(console.log("[MockSynapse] Verifying data integrity..."),console.log("[MockSynapse] Simulating verification delay (200ms)..."),await new Promise((e=>setTimeout(e,200))),console.log("[MockSynapse] Data verification complete")):console.log("[MockSynapse] Skipping verification (noVerify=true)"),console.log("[MockSynapse] Returning data copy"),new Uint8Array(o)}async delete(e){const t=Dn(e);if(null==t)throw new Error("Invalid CommP provided");const n=t.toString();console.log("[MockSynapse] StorageService.delete() called"),console.log("[MockSynapse] CommP:",n),console.log("[MockSynapse] Simulating delete network delay (500ms)..."),await new Promise((e=>setTimeout(e,500))),console.log("[MockSynapse] Removing data from mock storage..."),this._storedData.delete(n),console.log("[MockSynapse] Data deleted successfully")}async settlePayments(){console.log("[MockSynapse] StorageService.settlePayments() called"),console.log("[MockSynapse] Simulating settlement processing delay (1000ms)..."),await new Promise((e=>setTimeout(e,1e3)));const e={settledAmount:50000000000000000n,epoch:Math.floor(Date.now()/3e4)};return console.log("[MockSynapse] Settlement complete:",e),e}}class xn{apiEndpoint;serviceName;constructor(e,t="public"){if(""===e)throw new Error("PDP API endpoint is required");this.apiEndpoint=e.endsWith("/")?e.slice(0,-1):e,this.serviceName=t}async upload(e,t){const n=e instanceof ArrayBuffer?new Uint8Array(e):e,r=n.length,o=await this._createUpload(t,r);await this._uploadData(o,n)}async _createUpload(e,t){const n={check:{name:"sha2-256-trunc254-padded",hash:e.multihash.digest.reduce(((e,t)=>e+t.toString(16).padStart(2,"0")),""),size:t}},r=await fetch(`${this.apiEndpoint}/pdp/piece`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(n)});if(200===r.status){const e=await r.json();return console.log(`Piece already exists on server: ${e.pieceCID}`),""}if(201!==r.status){const e=await r.text();throw new Error(`Failed to create upload: ${r.status} ${r.statusText} - ${e}`)}const o=r.headers.get("Location");if(null==o)throw new Error("Server did not provide Location header in response (may be restricted by CORS policy)");const i=o.match(/\/(?:pdp\/)?piece\/upload\/([a-fA-F0-9-]+)/);if(null==i)throw new Error(`Invalid Location header format: ${o}`);return i[1]}async _uploadData(e,t){if(""===e)return;const n=`${this.apiEndpoint}/pdp/piece/upload/${e}`,r=await fetch(n,{method:"PUT",headers:{"Content-Type":"application/octet-stream","Content-Length":t.length.toString()},body:t});if(204!==r.status){const e=await r.text();throw new Error(`Failed to upload data: ${r.status} ${r.statusText} - ${e}`)}}getServiceName(){return this.serviceName}getApiEndpoint(){return this.apiEndpoint}}class $n{retrievalUrl;constructor(e){if(""===e)throw new Error("Retrieval URL is required");this.retrievalUrl=e.endsWith("/")?e.slice(0,-1):e}async downloadPiece(e){const t=Dn(e);if(null==t)throw new Error("Invalid CommP provided");const n=`${this.retrievalUrl}/piece/${t.toString()}`,r=await fetch(n,{method:"GET",headers:{Accept:"application/octet-stream"}});if(!r.ok){const e=await r.text();throw new Error(`Failed to download piece: ${r.status} ${r.statusText} - ${e}`)}if(null==r.body)throw new Error("Response body is null");console.log("Streaming and verifying downloaded data...");const{stream:o,getCommP:i}=In(),s=[],a=new TransformStream({transform(e,t){s.push(e),t.enqueue(e)}}),c=r.body.pipeThrough(o).pipeThrough(a).getReader();try{for(;;){const{done:e}=await c.read();if(e)break}}finally{c.releaseLock()}const l=i();if(null==l)throw new Error("Failed to calculate CommP from stream");if(l.toString()!==t.toString())throw new Error(`CommP verification failed. Expected: ${t.toString()}, Got: ${l.toString()}`);console.log("âœ… CommP verification successful");const u=s.reduce(((e,t)=>e+t.length),0),d=new Uint8Array(u);let h=0;for(const e of s)d.set(e,h),h+=e.length;return d}getRetrievalUrl(){return this.retrievalUrl}}const Mn={CreateProofSet:[{name:"clientDataSetId",type:"uint256"},{name:"withCDN",type:"bool"},{name:"payee",type:"address"}],Cid:[{name:"data",type:"bytes"}],RootData:[{name:"root",type:"Cid"},{name:"rawSize",type:"uint256"}],AddRoots:[{name:"clientDataSetId",type:"uint256"},{name:"firstAdded",type:"uint256"},{name:"rootData",type:"RootData[]"}],ScheduleRemovals:[{name:"clientDataSetId",type:"uint256"},{name:"rootIds",type:"uint256[]"}],DeleteProofSet:[{name:"clientDataSetId",type:"uint256"}]};class Bn{signer;domain;constructor(e,t,n){this.signer=t,this.domain={name:"PandoraService",version:"1",chainId:Number(n),verifyingContract:e}}async isMetaMaskSigner(){try{const e=this.signer.provider;if(null==e)return!1;if("_eip1193Provider"in e)return!0;if("undefined"!=typeof globalThis&&"window"in globalThis){const e=globalThis;if(null!=e.window?.ethereum)return!0}if("send"in e||"request"in e)return!0}catch(e){}return!1}async signWithMetaMask(e,t){const n=this.signer.provider;if(null==n)throw new Error("No provider available");const r=await this.signer.getAddress();let o="";for(const t of Object.keys(e))if("Cid"!==t&&"RootData"!==t){o=t;break}const i={types:{EIP712Domain:[{name:"name",type:"string"},{name:"version",type:"string"},{name:"chainId",type:"uint256"},{name:"verifyingContract",type:"address"}],...e},primaryType:o,domain:this.domain,message:t};let s,a;return s="_eip1193Provider"in n?n._eip1193Provider:n,a=null!=s&&"request"in s?await s.request({method:"eth_signTypedData_v4",params:[r.toLowerCase(),JSON.stringify(i)]}):await n.send("eth_signTypedData_v4",[r.toLowerCase(),JSON.stringify(i)]),a}async signCreateProofSet(e,t,n=!1){let r;if(await this.isMetaMaskSigner()){const o={clientDataSetId:e.toString(),withCDN:n,payee:t};r=await this.signWithMetaMask({CreateProofSet:Mn.CreateProofSet},o)}else{const o={clientDataSetId:BigInt(e),withCDN:n,payee:t};r=await this.signer.signTypedData(this.domain,{CreateProofSet:Mn.CreateProofSet},o)}const o=c.ethers.Signature.from(r),i=c.ethers.TypedDataEncoder.hash(this.domain,{CreateProofSet:Mn.CreateProofSet},{clientDataSetId:BigInt(e),withCDN:n,payee:t});return{signature:r,v:o.v,r:o.r,s:o.s,signedData:i}}async signAddRoots(e,t,n){const r=[];for(const e of n){const t="string"==typeof e.cid?Dn(e.cid):e.cid;if(null==t)throw new Error(`Invalid CommP: ${String(e.cid)}`);r.push({root:{data:t.bytes},rawSize:BigInt(En(e.rawSize))})}let o;if(await this.isMetaMaskSigner()){const n={clientDataSetId:e.toString(),firstAdded:t.toString(),rootData:r.map((e=>({root:{data:c.ethers.hexlify(e.root.data)},rawSize:e.rawSize.toString()})))},i={AddRoots:Mn.AddRoots,RootData:Mn.RootData,Cid:Mn.Cid};o=await this.signWithMetaMask(i,n)}else{const n={clientDataSetId:BigInt(e),firstAdded:BigInt(t),rootData:r},i={AddRoots:Mn.AddRoots,RootData:Mn.RootData,Cid:Mn.Cid};o=await this.signer.signTypedData(this.domain,i,n)}const i=c.ethers.Signature.from(o),s=c.ethers.TypedDataEncoder.hash(this.domain,{AddRoots:Mn.AddRoots,RootData:Mn.RootData,Cid:Mn.Cid},{clientDataSetId:BigInt(e),firstAdded:BigInt(t),rootData:r});return{signature:o,v:i.v,r:i.r,s:i.s,signedData:s}}async signScheduleRemovals(e,t){const n=t.map((e=>BigInt(e)));let r;if(await this.isMetaMaskSigner()){const t={clientDataSetId:e.toString(),rootIds:n.map((e=>e.toString()))};r=await this.signWithMetaMask({ScheduleRemovals:Mn.ScheduleRemovals},t)}else{const t={clientDataSetId:BigInt(e),rootIds:n};r=await this.signer.signTypedData(this.domain,{ScheduleRemovals:Mn.ScheduleRemovals},t)}const o=c.ethers.Signature.from(r),i=c.ethers.TypedDataEncoder.hash(this.domain,{ScheduleRemovals:Mn.ScheduleRemovals},{clientDataSetId:BigInt(e),rootIds:n});return{signature:r,v:o.v,r:o.r,s:o.s,signedData:i}}async signDeleteProofSet(e){let t;if(await this.isMetaMaskSigner()){const n={clientDataSetId:e.toString()};t=await this.signWithMetaMask({DeleteProofSet:Mn.DeleteProofSet},n)}else{const n={clientDataSetId:BigInt(e)};t=await this.signer.signTypedData(this.domain,{DeleteProofSet:Mn.DeleteProofSet},n)}const n=c.ethers.Signature.from(t),r=c.ethers.TypedDataEncoder.hash(this.domain,{DeleteProofSet:Mn.DeleteProofSet},{clientDataSetId:BigInt(e)});return{signature:t,v:n.v,r:n.r,s:n.s,signedData:r}}async getSignerAddress(){return await this.signer.getAddress()}}class Tn{apiEndpoint;pdpAuthHelper;constructor(e,t){if(""===e)throw new Error("PDP API endpoint is required");this.apiEndpoint=e.endsWith("/")?e.slice(0,-1):e,this.pdpAuthHelper=t}async createProofSet(e,t,n,r){const o=await this.pdpAuthHelper.signCreateProofSet(e,t,n),i={recordKeeper:r,extraData:`0x${this._encodeProofSetCreateData({metadata:"",payer:await this.pdpAuthHelper.getSignerAddress(),withCDN:n,signature:o.signature})}`},s=await fetch(`${this.apiEndpoint}/pdp/proof-sets`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(i)});if(201!==s.status){const e=await s.text();throw new Error(`Failed to create proof set: ${s.status} ${s.statusText} - ${e}`)}const a=s.headers.get("Location");if(null==a)throw new Error("Server did not provide Location header in response");const c=a.match(/\/pdp\/proof-sets\/created\/(.+)$/);if(null==c)throw new Error(`Invalid Location header format: ${a}`);return{txHash:c[1],statusUrl:`${this.apiEndpoint}${a}`}}async getProofSetCreationStatus(e){const t=await fetch(`${this.apiEndpoint}/pdp/proof-sets/created/${e}`,{method:"GET",headers:{"Content-Type":"application/json"}});if(404===t.status)throw new Error(`Proof set creation not found for transaction hash: ${e}`);if(200!==t.status){const e=await t.text();throw new Error(`Failed to get proof set creation status: ${t.status} ${t.statusText} - ${e}`)}return await t.json()}async addRoots(e,t,n,r){if(0===r.length)throw new Error("At least one root must be provided");for(const e of r)if(null==Dn(e.cid))throw new Error(`Invalid CommP: ${String(e.cid)}`);const o=await this.pdpAuthHelper.signAddRoots(t,n,r),i=this._encodeAddRootsExtraData({signature:o.signature,metadata:""}),s={roots:r.map((e=>{const t="string"==typeof e.cid?e.cid:e.cid.toString();return{rootCid:t,subroots:[{subrootCid:t}]}})),extraData:`0x${i}`},a=await fetch(`${this.apiEndpoint}/pdp/proof-sets/${e}/roots`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(s)});if(201!==a.status){const e=await a.text();throw new Error(`Failed to add roots to proof set: ${a.status} ${a.statusText} - ${e}`)}const c=await a.text();return{message:""!==c?c:`Roots added to proof set ID ${e} successfully`}}getApiEndpoint(){return this.apiEndpoint}getPDPAuthHelper(){return this.pdpAuthHelper}_encodeProofSetCreateData(e){const t=e.signature.startsWith("0x")?e.signature:`0x${e.signature}`;return c.ethers.AbiCoder.defaultAbiCoder().encode(["string","address","bool","bytes"],[e.metadata,e.payer,e.withCDN,t]).slice(2)}_encodeAddRootsExtraData(e){const t=e.signature.startsWith("0x")?e.signature:`0x${e.signature}`;return c.ethers.AbiCoder.defaultAbiCoder().encode(["bytes","string"],[t,e.metadata]).slice(2)}}function Nn(e,t,n,r){const o=`${e} ${t} failed: ${n}`;return null!=r?new Error(o,{cause:r}):new Error(o)}const Rn={USDFC:"USDFC",FIL:"FIL"},Fn={mainnet:314,calibration:314159},Ln={ERC20:["function balanceOf(address owner) view returns (uint256)","function decimals() view returns (uint8)","function symbol() view returns (string)","function approve(address spender, uint256 amount) returns (bool)","function allowance(address owner, address spender) view returns (uint256)","function transfer(address to, uint256 amount) returns (bool)"],PAYMENTS:["function deposit(address token, address to, uint256 amount)","function withdraw(address token, uint256 amount)","function accounts(address token, address owner) view returns (uint256 funds, uint256 lockedFunds, bool frozen)","function setOperatorApproval(address token, address operator, bool approved, uint256 rateAllowance, uint256 lockupAllowance)","function operatorApprovals(address token, address client, address operator) view returns (bool isApproved, uint256 rateAllowance, uint256 rateUsed, uint256 lockupAllowance, uint256 lockupUsed)"],PANDORA_SERVICE:["function registerServiceProvider(string pdpUrl, string pieceRetrievalUrl) external","function approveServiceProvider(address provider) external","function rejectServiceProvider(address provider) external","function removeServiceProvider(uint256 providerId) external","function isProviderApproved(address provider) external view returns (bool)","function getProviderIdByAddress(address provider) external view returns (uint256)","function getApprovedProvider(uint256 providerId) external view returns (tuple(address owner, string pdpUrl, string pieceRetrievalUrl, uint256 registeredAt, uint256 approvedAt))","function pendingProviders(address provider) external view returns (string pdpUrl, string pieceRetrievalUrl, uint256 registeredAt)","function approvedProviders(uint256 providerId) external view returns (address owner, string pdpUrl, string pieceRetrievalUrl, uint256 registeredAt, uint256 approvedAt)","function nextServiceProviderId() external view returns (uint256)","function owner() external view returns (address)","function approvedProvidersMap(address) external view returns (bool)","function providerToId(address) external view returns (uint256)","function getAllApprovedProviders() external view returns (tuple(address owner, string pdpUrl, string pieceRetrievalUrl, uint256 registeredAt, uint256 approvedAt)[])"]},zn={mainnet:{http:"https://api.node.glif.io/rpc/v1",websocket:"wss://wss.node.glif.io/apigw/lotus/rpc/v1"},calibration:{http:"https://api.calibration.node.glif.io/rpc/v1",websocket:"wss://wss.calibration.node.glif.io/apigw/lotus/rpc/v1"}},On={USDFC:{mainnet:"0x80B98d3aa09ffff255c3ba4A241111Ff1262F045",calibration:"0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0"},PAYMENTS:{mainnet:"",calibration:"0x0E690D3e60B0576D01352AB03b258115eb84A047"},PANDORA_SERVICE:{mainnet:"",calibration:"0x394feCa6bCB84502d93c0c5C03c620ba8897e8f4"}};class jn{contract;signer;constructor(e,t){this.signer=t,this.contract=new c.Contract(e,Ln.PANDORA_SERVICE,t)}async register(e,t){return await this.contract.registerServiceProvider(e,t)}async approve(e){return await this.contract.approveServiceProvider(e)}async reject(e){return await this.contract.rejectServiceProvider(e)}async remove(e){return await this.contract.removeServiceProvider(e)}async isApproved(e){return await this.contract.isProviderApproved(e)}async getProviderIdByAddress(e){return await this.contract.getProviderIdByAddress(e)}async getApprovedProvider(e){const t=await this.contract.getApprovedProvider(e);return{owner:t.owner,pdpUrl:t.pdpUrl,pieceRetrievalUrl:t.pieceRetrievalUrl,registeredAt:t.registeredAt,approvedAt:t.approvedAt}}async getPendingProvider(e){const[t,n,r]=await this.contract.pendingProviders(e);return{pdpUrl:t,pieceRetrievalUrl:n,registeredAt:r}}async getNextProviderId(){return await this.contract.nextServiceProviderId()}async getOwner(){return await this.contract.owner()}async getSignerAddress(){return await this.signer.getAddress()}async isOwner(){const[e,t]=await Promise.all([this.getOwner(),this.getSignerAddress()]);return e.toLowerCase()===t.toLowerCase()}async getAllApprovedProviders(){const e=await this.getNextProviderId(),t=[];for(let n=1n;n<e;n++)try{const e=await this.getApprovedProvider(n);"0x0000000000000000000000000000000000000000"!==e.owner&&t.push({id:n,info:e})}catch(e){continue}return t}getContractAddress(){return this.contract.target}}class Hn{_provider;_signer;_network;_disableNonceManager;_usdfcContract=null;_paymentsContract=null;static USDFC=Rn.USDFC;constructor(e,t,n,r){this._provider=e,this._signer=t,this._network=n,this._disableNonceManager=r}_getUsdfcContract(){if(null==this._usdfcContract){const e=On.USDFC[this._network];if(null==e)throw new Error(`USDFC contract not deployed on ${this._network} network`);this._usdfcContract=new c.ethers.Contract(e,Ln.ERC20,this._signer)}return this._usdfcContract}_getPaymentsContract(){if(null==this._paymentsContract){const e=On.PAYMENTS[this._network];if(null==e||""===e)throw new Error(`Payments contract not deployed on ${this._network} network. Currently only Calibration testnet is supported.`);this._paymentsContract=new c.ethers.Contract(e,Ln.PAYMENTS,this._signer)}return this._paymentsContract}async balance(e=Hn.USDFC){if(e!==Hn.USDFC)throw Nn("SynapsePayments","payments contract balance check",`Token "${e}" is not supported. Currently only USDFC token is supported for payments contract balance queries.`);const t=await this._signer.getAddress(),n=On.USDFC[this._network],r=this._getPaymentsContract();let o;try{o=await r.accounts(n,t)}catch(e){throw Nn("SynapsePayments","payments contract balance check","Failed to read account information from payments contract. This could indicate the contract is not properly deployed, the ABI is incorrect, or there are network connectivity issues.",e)}const[i,s]=o;return BigInt(i)-BigInt(s)}async walletBalance(e){if(null==e||e===Rn.FIL)try{const e=await this._signer.getAddress();return await this._provider.getBalance(e)}catch(e){throw Nn("SynapsePayments","wallet FIL balance check","Unable to retrieve FIL balance from wallet. This could be due to network connectivity issues, RPC endpoint problems, or wallet connection issues.",e)}if(e===Hn.USDFC)try{const e=await this._signer.getAddress(),t=this._getUsdfcContract();return await t.balanceOf(e)}catch(e){throw Nn("SynapsePayments","wallet USDFC balance check","Unexpected error while checking USDFC token balance in wallet.",e)}throw Nn("SynapsePayments","wallet balance check",`Token "${e}" is not supported. Currently only USDFC token is supported for balance queries.`)}decimals(e=Hn.USDFC){return 18}async allowance(e,t){if(e!==Hn.USDFC)throw Nn("SynapsePayments","allowance",`Token "${e}" is not supported. Currently only USDFC token is supported.`);const n=await this._signer.getAddress(),r=this._getUsdfcContract();try{return await r.allowance(n,t)}catch(e){throw Nn("SynapsePayments","allowance check","Failed to check token allowance. This could indicate network connectivity issues or an invalid spender address.",e)}}async approve(e,t,n){if(e!==Hn.USDFC)throw Nn("SynapsePayments","approve",`Token "${e}" is not supported. Currently only USDFC token is supported.`);const r="bigint"==typeof n?n:BigInt(n);if(r<0n)throw Nn("SynapsePayments","approve","Approval amount cannot be negative");const o=await this._signer.getAddress(),i=this._getUsdfcContract(),s={};if(this._disableNonceManager){const e=await this._provider.getTransactionCount(o,"pending");s.nonce=e}try{const e=await i.approve(t,r,s);return await e.wait(),e.hash}catch(n){throw Nn("SynapsePayments","approve",`Failed to approve ${t} to spend ${r.toString()} ${e}`,n)}}async approveService(e,t,n,r=Hn.USDFC){if(r!==Hn.USDFC)throw Nn("SynapsePayments","approveService",`Token "${r}" is not supported. Currently only USDFC token is supported.`);const o="bigint"==typeof t?t:BigInt(t),i="bigint"==typeof n?n:BigInt(n);if(o<0n||i<0n)throw Nn("SynapsePayments","approveService","Allowance values cannot be negative");const s=await this._signer.getAddress(),a=On.USDFC[this._network],c=this._getPaymentsContract(),l={};if(this._disableNonceManager){const e=await this._provider.getTransactionCount(s,"pending");l.nonce=e}try{const t=await c.setOperatorApproval(a,e,!0,o,i,l);return await t.wait(),t.hash}catch(t){throw Nn("SynapsePayments","approveService",`Failed to approve service ${e} as operator for ${r}`,t)}}async revokeService(e,t=Hn.USDFC){if(t!==Hn.USDFC)throw Nn("SynapsePayments","revokeService",`Token "${t}" is not supported. Currently only USDFC token is supported.`);const n=await this._signer.getAddress(),r=On.USDFC[this._network],o=this._getPaymentsContract(),i={};if(this._disableNonceManager){const e=await this._provider.getTransactionCount(n,"pending");i.nonce=e}try{const t=await o.setOperatorApproval(r,e,!1,0n,0n,i);return await t.wait(),t.hash}catch(n){throw Nn("SynapsePayments","revokeService",`Failed to revoke service ${e} as operator for ${t}`,n)}}async serviceApproval(e,t=Hn.USDFC){if(t!==Hn.USDFC)throw Nn("SynapsePayments","serviceApproval",`Token "${t}" is not supported. Currently only USDFC token is supported.`);const n=await this._signer.getAddress(),r=On.USDFC[this._network],o=this._getPaymentsContract();try{const t=await o.operatorApprovals(r,n,e);return{isApproved:t[0],rateAllowance:t[1],lockupAllowance:t[2],rateUsed:t[3],lockupUsed:t[4]}}catch(t){throw Nn("SynapsePayments","serviceApproval",`Failed to check service approval status for ${e}`,t)}}async deposit(e,t=Hn.USDFC){if(t!==Hn.USDFC)throw Nn("SynapsePayments","deposit",`Unsupported token: ${t}`);const n="bigint"==typeof e?e:BigInt(e);if(n<=0n)throw Nn("SynapsePayments","deposit","Invalid amount");const r=await this._signer.getAddress(),o=On.USDFC[this._network],i=this._getUsdfcContract(),s=this._getPaymentsContract(),a=await i.balanceOf(r);if(a<n)throw Nn("SynapsePayments","deposit",`Insufficient USDFC: have ${BigInt(a).toString()}, need ${n.toString()}`);const c=On.PAYMENTS[this._network];if(null==c)throw Nn("SynapsePayments","deposit",`Payments contract not deployed on ${this._network}`);await this.allowance(t,c)<n&&await this.approve(t,c,n);const l=await s.accounts(o,r),[,,u]=l;if(!0===u)throw Nn("SynapsePayments","deposit","Account is frozen");const d={};if(this._disableNonceManager){const e=await this._provider.getTransactionCount(r,"pending");d.nonce=e}const h=await s.deposit(o,r,n,d);return await h.wait(),h.hash}async withdraw(e,t=Hn.USDFC){if(t!==Hn.USDFC)throw Nn("SynapsePayments","withdraw",`Unsupported token: ${t}`);const n="bigint"==typeof e?e:BigInt(e);if(n<=0n)throw Nn("SynapsePayments","withdraw","Invalid amount");const r=await this._signer.getAddress(),o=On.USDFC[this._network],i=this._getPaymentsContract(),s=await i.accounts(o,r),[a,c,l]=s,u=BigInt(a)-BigInt(c);if(!0===l)throw Nn("SynapsePayments","withdraw","Account is frozen");if(u<n)throw Nn("SynapsePayments","withdraw",`Insufficient balance: have ${u.toString()}, need ${n.toString()}`);const d={};if(this._disableNonceManager){const e=await this._provider.getTransactionCount(r,"pending");d.nonce=e}const h=await i.withdraw(o,n,d);return await h.wait(),h.hash}}class Vn{_signer;_network;_withCDN;_payments;_pdpAuthHelper=null;static async create(e){if(1!==[e.privateKey,e.provider,e.signer].filter(Boolean).length)throw new Error("Must provide exactly one of: privateKey, provider, or signer");if(null!=e.privateKey&&null==e.rpcURL)throw new Error("rpcURL is required when using privateKey");let t,n,r;if(null!=e.privateKey&&null!=e.rpcURL){if(e.rpcURL.startsWith("ws://")||e.rpcURL.startsWith("wss://"))t=new c.ethers.WebSocketProvider(e.rpcURL);else if(null!=e.authorization){const n=new c.ethers.FetchRequest(e.rpcURL);n.setHeader("Authorization",e.authorization),t=new c.ethers.JsonRpcProvider(n)}else t=new c.ethers.JsonRpcProvider(e.rpcURL);const r=new c.ethers.Wallet(e.privateKey,t);n=!0!==e.disableNonceManager?new c.ethers.NonceManager(r):r}else if(null!=e.provider){if(t=e.provider,!("getSigner"in t)||"function"!=typeof t.getSigner)throw new Error("Provider must support getSigner() method");{const r=await t.getSigner();n=!0!==e.disableNonceManager?new c.ethers.NonceManager(r):r}}else{if(null==e.signer)throw new Error("Invalid configuration");if(n=e.signer,null==n.provider)throw new Error("Signer must have a provider attached");t=n.provider,!0!==e.disableNonceManager&&(n=new c.ethers.NonceManager(n))}try{const e=await t.getNetwork(),n=Number(e.chainId);if(n===Fn.mainnet)r="mainnet";else{if(n!==Fn.calibration)throw new Error(`Unsupported network with chain ID ${n}. Synapse SDK only supports Filecoin mainnet (${Fn.mainnet}) and calibration (${Fn.calibration}) networks.`);r="calibration"}}catch(e){throw new Error("Failed to detect network from provider. Please ensure your RPC endpoint is accessible and responds to network queries. "+(e instanceof Error?`Underlying error: ${e.message}`:""))}return new Vn(t,n,r,!0===e.disableNonceManager,!0===e.withCDN)}constructor(e,t,n,r,o){this._signer=t,this._network=n,this._withCDN=o,this._payments=new Hn(e,t,n,r)}get payments(){return this._payments}async createStorage(e){console.log("[MockSynapse] Creating storage service..."),console.log("[MockSynapse] Options:",e),console.log("[MockSynapse] Simulating network delay (500ms)..."),await new Promise((e=>setTimeout(e,500)));const t=e?.proofSetId??"ps_"+Math.random().toString(36).substring(2,15),n=e?.storageProvider??"f01234";return console.log(`[MockSynapse] Storage service created with proofSetId: ${t}, SP: ${n}`),console.log("[MockSynapse] Storage service ready for operations"),new _n(t,n,await this._signer.getAddress(),this._withCDN)}getPDPAuthHelper(){if(null==this._pdpAuthHelper){const e=On.PANDORA_SERVICE[this._network];if(""===e)throw Nn("Synapse","getPDPAuthHelper",`PDP service contract not deployed on ${this._network} network`);const t=BigInt(Fn[this._network]);this._pdpAuthHelper=new Bn(e,this._signer,t)}return this._pdpAuthHelper}}const Wn={...a,...i,...s};export{Wn as default};