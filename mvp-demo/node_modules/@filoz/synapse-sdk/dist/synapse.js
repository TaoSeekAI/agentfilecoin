import { ethers } from 'ethers';
import { MockStorageService } from './storage-service.js';
import { PDPAuthHelper } from './pdp/index.js';
import { SynapsePayments } from './payments/index.js';
import { createError, CHAIN_IDS, CONTRACT_ADDRESSES } from './utils/index.js';
export class Synapse {
    _signer;
    _network;
    _withCDN;
    _payments;
    _pdpAuthHelper = null;
    static async create(options) {
        const providedOptions = [options.privateKey, options.provider, options.signer].filter(Boolean).length;
        if (providedOptions !== 1) {
            throw new Error('Must provide exactly one of: privateKey, provider, or signer');
        }
        if (options.privateKey != null && options.rpcURL == null) {
            throw new Error('rpcURL is required when using privateKey');
        }
        let provider;
        let signer;
        if (options.privateKey != null && options.rpcURL != null) {
            if (options.rpcURL.startsWith('ws://') || options.rpcURL.startsWith('wss://')) {
                provider = new ethers.WebSocketProvider(options.rpcURL);
            }
            else {
                if (options.authorization != null) {
                    const fetchRequest = new ethers.FetchRequest(options.rpcURL);
                    fetchRequest.setHeader('Authorization', options.authorization);
                    provider = new ethers.JsonRpcProvider(fetchRequest);
                }
                else {
                    provider = new ethers.JsonRpcProvider(options.rpcURL);
                }
            }
            const wallet = new ethers.Wallet(options.privateKey, provider);
            if (options.disableNonceManager !== true) {
                signer = new ethers.NonceManager(wallet);
            }
            else {
                signer = wallet;
            }
        }
        else if (options.provider != null) {
            provider = options.provider;
            if ('getSigner' in provider && typeof provider.getSigner === 'function') {
                const providerSigner = await provider.getSigner();
                if (options.disableNonceManager !== true) {
                    signer = new ethers.NonceManager(providerSigner);
                }
                else {
                    signer = providerSigner;
                }
            }
            else {
                throw new Error('Provider must support getSigner() method');
            }
        }
        else if (options.signer != null) {
            signer = options.signer;
            if (signer.provider != null) {
                provider = signer.provider;
            }
            else {
                throw new Error('Signer must have a provider attached');
            }
            if (options.disableNonceManager !== true) {
                signer = new ethers.NonceManager(signer);
            }
        }
        else {
            throw new Error('Invalid configuration');
        }
        let network;
        try {
            const ethersNetwork = await provider.getNetwork();
            const chainId = Number(ethersNetwork.chainId);
            if (chainId === CHAIN_IDS.mainnet) {
                network = 'mainnet';
            }
            else if (chainId === CHAIN_IDS.calibration) {
                network = 'calibration';
            }
            else {
                throw new Error(`Unsupported network with chain ID ${chainId}. Synapse SDK only supports Filecoin mainnet (${CHAIN_IDS.mainnet}) and calibration (${CHAIN_IDS.calibration}) networks.`);
            }
        }
        catch (error) {
            throw new Error(`Failed to detect network from provider. Please ensure your RPC endpoint is accessible and responds to network queries. ${error instanceof Error ? `Underlying error: ${error.message}` : ''}`);
        }
        return new Synapse(provider, signer, network, options.disableNonceManager === true, options.withCDN === true);
    }
    constructor(provider, signer, network, disableNonceManager, withCDN) {
        this._signer = signer;
        this._network = network;
        this._withCDN = withCDN;
        this._payments = new SynapsePayments(provider, signer, network, disableNonceManager);
    }
    get payments() {
        return this._payments;
    }
    async createStorage(options) {
        console.log('[MockSynapse] Creating storage service...');
        console.log('[MockSynapse] Options:', options);
        console.log('[MockSynapse] Simulating network delay (500ms)...');
        await new Promise((resolve) => setTimeout(resolve, 500));
        const proofSetId = options?.proofSetId ?? 'ps_' + Math.random().toString(36).substring(2, 15);
        const storageProvider = options?.storageProvider ?? 'f01234';
        console.log(`[MockSynapse] Storage service created with proofSetId: ${proofSetId}, SP: ${storageProvider}`);
        console.log('[MockSynapse] Storage service ready for operations');
        return new MockStorageService(proofSetId, storageProvider, await this._signer.getAddress(), this._withCDN);
    }
    getPDPAuthHelper() {
        if (this._pdpAuthHelper == null) {
            const pdpServiceContractAddress = CONTRACT_ADDRESSES.PANDORA_SERVICE[this._network];
            if (pdpServiceContractAddress === '') {
                throw createError('Synapse', 'getPDPAuthHelper', `PDP service contract not deployed on ${this._network} network`);
            }
            const chainId = BigInt(CHAIN_IDS[this._network]);
            this._pdpAuthHelper = new PDPAuthHelper(pdpServiceContractAddress, this._signer, chainId);
        }
        return this._pdpAuthHelper;
    }
}
export { Synapse as default };
//# sourceMappingURL=synapse.js.map