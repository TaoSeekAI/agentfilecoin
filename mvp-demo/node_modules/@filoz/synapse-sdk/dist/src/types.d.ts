import type { ethers } from 'ethers';
import type { PieceCID } from './piece/index.ts';
import type { ProviderInfo } from './sp-registry/types.ts';
export type { PieceCID, ProviderInfo };
export type PrivateKey = string;
export type Address = string;
export type TokenAmount = number | bigint;
export type DataSetId = string;
export type ServiceProvider = string;
export type FilecoinNetworkType = 'mainnet' | 'calibration';
export type TokenIdentifier = 'USDFC' | string;
export interface SynapseOptions {
    privateKey?: PrivateKey;
    provider?: ethers.Provider;
    signer?: ethers.Signer;
    rpcURL?: string;
    authorization?: string;
    withCDN?: boolean;
    withIpni?: boolean;
    dev?: boolean;
    pieceRetriever?: PieceRetriever;
    disableNonceManager?: boolean;
    warmStorageAddress?: string;
    pdpVerifierAddress?: string;
    subgraphService?: SubgraphRetrievalService;
    subgraphConfig?: SubgraphConfig;
}
export interface StorageOptions {
    dataSetId?: DataSetId;
    serviceProvider?: ServiceProvider;
}
export interface UploadTask {
    pieceCid: () => Promise<PieceCID>;
    store: () => Promise<ServiceProvider>;
    done: () => Promise<string>;
}
export type DownloadOptions = {};
export interface PieceRetriever {
    fetchPiece: (pieceCid: PieceCID, client: string, options?: {
        providerAddress?: string;
        withCDN?: boolean;
        signal?: AbortSignal;
    }) => Promise<Response>;
}
export interface SubgraphConfig {
    endpoint?: string;
    goldsky?: {
        projectId: string;
        subgraphName: string;
        version: string;
    };
    apiKey?: string;
}
export interface SubgraphRetrievalService {
    getApprovedProvidersForPieceCID: (pieceCid: PieceCID) => Promise<ProviderInfo[]>;
    getProviderByAddress: (address: string) => Promise<ProviderInfo | null>;
}
export interface AuthSignature {
    signature: string;
    v: number;
    r: string;
    s: string;
    signedData: string;
}
export interface DataSetInfo {
    pdpRailId: number;
    cacheMissRailId: number;
    cdnRailId: number;
    payer: string;
    payee: string;
    serviceProvider: string;
    commissionBps: number;
    clientDataSetId: number;
    pdpEndEpoch: number;
    providerId: number;
    cdnEndEpoch: number;
    paymentEndEpoch?: number;
}
export interface EnhancedDataSetInfo extends DataSetInfo {
    pdpVerifierDataSetId: number;
    nextPieceId: number;
    currentPieceCount: number;
    isLive: boolean;
    isManaged: boolean;
    withCDN: boolean;
    metadata: Record<string, string>;
}
export interface RailInfo {
    railId: number;
    isTerminated: boolean;
    endEpoch: number;
}
export interface SettlementResult {
    totalSettledAmount: bigint;
    totalNetPayeeAmount: bigint;
    totalOperatorCommission: bigint;
    finalSettledEpoch: bigint;
    note: string;
}
export interface StorageCreationCallbacks {
    onProviderSelected?: (provider: ProviderInfo) => void;
    onDataSetResolved?: (info: {
        isExisting: boolean;
        dataSetId: number;
        provider: ProviderInfo;
    }) => void;
    onDataSetCreationStarted?: (transaction: ethers.TransactionResponse, statusUrl?: string) => void;
    onDataSetCreationProgress?: (status: {
        transactionMined: boolean;
        transactionSuccess: boolean;
        dataSetLive: boolean;
        serverConfirmed: boolean;
        dataSetId?: number;
        elapsedMs: number;
        receipt?: ethers.TransactionReceipt;
    }) => void;
}
export interface StorageServiceOptions {
    providerId?: number;
    providerAddress?: string;
    dataSetId?: number;
    withCDN?: boolean;
    withIpni?: boolean;
    dev?: boolean;
    forceCreateDataSet?: boolean;
    uploadBatchSize?: number;
    callbacks?: StorageCreationCallbacks;
    metadata?: Record<string, string>;
}
export interface PreflightInfo {
    estimatedCost: {
        perEpoch: bigint;
        perDay: bigint;
        perMonth: bigint;
    };
    allowanceCheck: {
        sufficient: boolean;
        message?: string;
    };
    selectedProvider: ProviderInfo | null;
    selectedDataSetId: number | null;
}
export interface UploadCallbacks {
    onUploadComplete?: (pieceCid: PieceCID) => void;
    onPieceAdded?: (transaction?: ethers.TransactionResponse) => void;
    onPieceConfirmed?: (pieceIds: number[]) => void;
}
export interface UploadOptions extends UploadCallbacks {
    metadata?: Record<string, string>;
}
export interface UploadResult {
    pieceCid: PieceCID;
    size: number;
    pieceId?: number;
}
export interface StorageInfo {
    pricing: {
        noCDN: {
            perTiBPerMonth: bigint;
            perTiBPerDay: bigint;
            perTiBPerEpoch: bigint;
        };
        withCDN: {
            perTiBPerMonth: bigint;
            perTiBPerDay: bigint;
            perTiBPerEpoch: bigint;
        };
        tokenAddress: string;
        tokenSymbol: string;
    };
    providers: ProviderInfo[];
    serviceParameters: {
        network: FilecoinNetworkType;
        epochsPerMonth: bigint;
        epochsPerDay: bigint;
        epochDuration: number;
        minUploadSize: number;
        maxUploadSize: number;
        warmStorageAddress: string;
        paymentsAddress: string;
        pdpVerifierAddress: string;
    };
    allowances: {
        service: string;
        rateAllowance: bigint;
        lockupAllowance: bigint;
        rateUsed: bigint;
        lockupUsed: bigint;
    } | null;
}
export interface DataSetData {
    id: number;
    pieces: DataSetPieceData[];
    nextChallengeEpoch: number;
}
export interface DataSetPieceData {
    pieceId: number;
    pieceCid: PieceCID;
    subPieceCid: PieceCID;
    subPieceOffset: number;
}
export interface PieceStatus {
    exists: boolean;
    dataSetLastProven: Date | null;
    dataSetNextProofDue: Date | null;
    retrievalUrl: string | null;
    pieceId?: number;
    inChallengeWindow?: boolean;
    hoursUntilChallengeWindow?: number;
    isProofOverdue?: boolean;
}
export interface ProviderSelectionResult {
    provider: ProviderInfo;
    dataSetId: number;
    isNewDataSet?: boolean;
    isExisting?: boolean;
    dataSetMetadata: Record<string, string>;
}
export type MetadataEntry = {
    key: string;
    value: string;
};
//# sourceMappingURL=types.d.ts.map