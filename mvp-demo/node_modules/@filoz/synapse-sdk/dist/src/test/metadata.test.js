import { assert } from 'chai';
import { ethers } from 'ethers';
import { setup } from 'iso-web/msw';
import { PDPAuthHelper } from "../pdp/auth.js";
import { PDPServer } from "../pdp/server.js";
import { asPieceCID } from "../piece/index.js";
import { METADATA_KEYS } from "../utils/constants.js";
import { addPiecesWithMetadataCapture, createDataSetWithMetadataCapture, } from "./mocks/pdp/handlers.js";
const server = setup([]);
describe('Metadata Support', () => {
    const TEST_PRIVATE_KEY = '0x0101010101010101010101010101010101010101010101010101010101010101';
    const TEST_CONTRACT_ADDRESS = '0x1234567890123456789012345678901234567890';
    const TEST_CHAIN_ID = 1n;
    const SERVER_URL = 'http://pdp.local';
    let authHelper;
    let pdpServer;
    before(async () => {
        await server.start({ quiet: true });
    });
    after(() => {
        server.stop();
    });
    beforeEach(() => {
        server.resetHandlers();
        authHelper = new PDPAuthHelper(TEST_CONTRACT_ADDRESS, new ethers.Wallet(TEST_PRIVATE_KEY), TEST_CHAIN_ID);
        pdpServer = new PDPServer(authHelper, SERVER_URL);
    });
    describe('PDPServer', () => {
        it('should handle metadata in createDataSet', async () => {
            const dataSetMetadata = [
                { key: 'project', value: 'my-project' },
                { key: 'environment', value: 'production' },
                { key: METADATA_KEYS.WITH_CDN, value: '' },
            ];
            const mockTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
            let capturedMetadata = null;
            server.use(createDataSetWithMetadataCapture(mockTxHash, (metadata) => {
                capturedMetadata = metadata;
            }, { baseUrl: SERVER_URL }));
            const result = await pdpServer.createDataSet(1, '0x70997970C51812dc3A010C7d01b50e0d17dc79C8', '0x70997970C51812dc3A010C7d01b50e0d17dc79C8', dataSetMetadata, TEST_CONTRACT_ADDRESS);
            assert.equal(result.txHash, mockTxHash);
            assert.exists(capturedMetadata);
            assert.isNotNull(capturedMetadata);
            assert.deepEqual(capturedMetadata.keys, ['project', 'environment', METADATA_KEYS.WITH_CDN]);
            assert.deepEqual(capturedMetadata.values, ['my-project', 'production', '']);
        });
        it('should handle metadata in addPieces', async () => {
            const pieces = [asPieceCID('bafkzcibcd4bdomn3tgwgrh3g532zopskstnbrd2n3sxfqbze7rxt7vqn7veigmy')];
            const metadata = [
                [
                    { key: 'contentType', value: 'application/json' },
                    { key: 'version', value: '1.0.0' },
                ],
            ];
            const dataSetId = 123;
            const mockTxHash = '0x1234567890abcdef';
            let capturedPieceMetadata = null;
            server.use(addPiecesWithMetadataCapture(dataSetId, mockTxHash, (metadata) => {
                capturedPieceMetadata = metadata;
            }, { baseUrl: SERVER_URL }));
            const result = await pdpServer.addPieces(dataSetId, 1, 1, pieces, metadata);
            assert.equal(result.txHash, mockTxHash);
            assert.exists(capturedPieceMetadata);
            assert.isNotNull(capturedPieceMetadata);
            assert.deepEqual(capturedPieceMetadata.keys[0], ['contentType', 'version']);
            assert.deepEqual(capturedPieceMetadata.values[0], ['application/json', '1.0.0']);
            const mismatchedMetadata = [
                [{ key: 'contentType', value: 'application/json' }],
                [{ key: 'version', value: '1.0.0' }],
            ];
            try {
                await pdpServer.addPieces(dataSetId, 1, 1, pieces, mismatchedMetadata);
                assert.fail('Should have thrown an error');
            }
            catch (error) {
                assert.match(error.message, /Metadata length \(2\) must match pieces length \(1\)/);
            }
            capturedPieceMetadata = null;
            const resultNoMetadata = await pdpServer.addPieces(dataSetId, 1, 1, pieces);
            assert.equal(resultNoMetadata.txHash, mockTxHash);
            assert.exists(capturedPieceMetadata);
            assert.isNotNull(capturedPieceMetadata);
            assert.deepEqual(capturedPieceMetadata.keys[0], []);
            assert.deepEqual(capturedPieceMetadata.values[0], []);
        });
    });
    describe('Backward Compatibility', () => {
        it('should convert withCDN boolean to metadata', async () => {
            const mockTxHash = '0xabcdef1234567890';
            let capturedMetadata = null;
            server.use(createDataSetWithMetadataCapture(mockTxHash, (metadata) => {
                capturedMetadata = metadata;
            }, { baseUrl: SERVER_URL }));
            const metadataWithCDN = [
                { key: 'project', value: 'test' },
                { key: METADATA_KEYS.WITH_CDN, value: '' },
            ];
            await pdpServer.createDataSet(1, '0x70997970C51812dc3A010C7d01b50e0d17dc79C8', '0x70997970C51812dc3A010C7d01b50e0d17dc79C8', metadataWithCDN, TEST_CONTRACT_ADDRESS);
            assert.isNotNull(capturedMetadata);
            assert.deepEqual(capturedMetadata.keys, ['project', METADATA_KEYS.WITH_CDN]);
            assert.deepEqual(capturedMetadata.values, ['test', '']);
            capturedMetadata = null;
            const metadataWithoutCDN = [{ key: 'project', value: 'test' }];
            await pdpServer.createDataSet(1, '0x70997970C51812dc3A010C7d01b50e0d17dc79C8', '0x70997970C51812dc3A010C7d01b50e0d17dc79C8', metadataWithoutCDN, TEST_CONTRACT_ADDRESS);
            assert.isNotNull(capturedMetadata);
            assert.deepEqual(capturedMetadata.keys, ['project']);
            assert.deepEqual(capturedMetadata.values, ['test']);
        });
        it('should handle StorageContext withCDN backward compatibility', async () => {
            const metadata = [{ key: 'test', value: 'value' }];
            const withCDN = true;
            const finalMetadata = [...metadata];
            if (withCDN && !finalMetadata.some((m) => m.key === METADATA_KEYS.WITH_CDN)) {
                finalMetadata.push({ key: METADATA_KEYS.WITH_CDN, value: '' });
            }
            assert.equal(finalMetadata.length, 2);
            assert.equal(finalMetadata[1].key, METADATA_KEYS.WITH_CDN);
            assert.equal(finalMetadata[1].value, '');
        });
        it('should not duplicate withCDN in metadata', async () => {
            const metadata = [
                { key: 'test', value: 'value' },
                { key: METADATA_KEYS.WITH_CDN, value: '' },
            ];
            const withCDN = true;
            const finalMetadata = [...metadata];
            if (withCDN && !finalMetadata.some((m) => m.key === METADATA_KEYS.WITH_CDN)) {
                finalMetadata.push({ key: METADATA_KEYS.WITH_CDN, value: '' });
            }
            assert.equal(finalMetadata.length, 2);
            const cdnEntries = finalMetadata.filter((m) => m.key === METADATA_KEYS.WITH_CDN);
            assert.equal(cdnEntries.length, 1);
        });
    });
    describe('StorageManager preflightUpload with metadata', () => {
        it('should extract withCDN from metadata when provided', async () => {
            const metadataWithCDN = [
                { key: 'test', value: 'value' },
                { key: METADATA_KEYS.WITH_CDN, value: '' },
            ];
            let withCDN = false;
            const withCDNEntry = metadataWithCDN.find((m) => m.key === METADATA_KEYS.WITH_CDN);
            if (withCDNEntry != null) {
                withCDN = true;
            }
            assert.isTrue(withCDN, 'Should detect withCDN in metadata');
            const metadataWithoutCDN = [{ key: 'test', value: 'value' }];
            withCDN = false;
            const withCDNEntry2 = metadataWithoutCDN.find((m) => m.key === METADATA_KEYS.WITH_CDN);
            if (withCDNEntry2 != null) {
                withCDN = true;
            }
            assert.isFalse(withCDN, 'Should not detect withCDN when not in metadata');
            const emptyMetadata = [];
            withCDN = true;
            const withCDNEntry3 = emptyMetadata.find((m) => m.key === METADATA_KEYS.WITH_CDN);
            if (withCDNEntry3 != null) {
                withCDN = true;
            }
            assert.isTrue(withCDN, 'Should preserve existing withCDN when metadata is empty');
            const metadataWithNonEmptyValue = [{ key: METADATA_KEYS.WITH_CDN, value: 'unexpected-value' }];
            withCDN = false;
            const withCDNEntry4 = metadataWithNonEmptyValue.find((m) => m.key === METADATA_KEYS.WITH_CDN);
            if (withCDNEntry4 != null) {
                if (withCDNEntry4.value !== '') {
                    assert.equal(withCDNEntry4.value, 'unexpected-value', 'Should detect non-empty value');
                }
                withCDN = true;
            }
            assert.isTrue(withCDN, 'Should enable CDN when key exists, regardless of value (contract behavior)');
        });
        it('should follow precedence: metadata > option > default', async () => {
            const defaultWithCDN = false;
            let options = {
                withCDN: false,
                metadata: [{ key: METADATA_KEYS.WITH_CDN, value: '' }],
            };
            let withCDN = options.withCDN ?? defaultWithCDN;
            if (options.metadata != null) {
                const withCDNEntry = options.metadata.find((m) => m.key === METADATA_KEYS.WITH_CDN);
                if (withCDNEntry != null) {
                    withCDN = true;
                }
            }
            assert.isTrue(withCDN, 'Metadata should override option');
            options = {
                withCDN: true,
                metadata: [{ key: 'other', value: 'value' }],
            };
            withCDN = options.withCDN ?? defaultWithCDN;
            if (options.metadata != null) {
                const withCDNEntry = options.metadata.find((m) => m.key === METADATA_KEYS.WITH_CDN);
                if (withCDNEntry != null) {
                    withCDN = true;
                }
            }
            assert.isTrue(withCDN, 'Option should be used when metadata lacks withCDN');
            options = {
                withCDN: false,
                metadata: [{ key: METADATA_KEYS.WITH_CDN, value: 'non-empty' }],
            };
            withCDN = options.withCDN ?? defaultWithCDN;
            if (options.metadata != null) {
                const withCDNEntry = options.metadata.find((m) => m.key === METADATA_KEYS.WITH_CDN);
                if (withCDNEntry != null) {
                    if (withCDNEntry.value !== '') {
                    }
                    withCDN = true;
                }
            }
            assert.isTrue(withCDN, 'Metadata with withCDN key should override option, even with non-empty value');
            options = {
                metadata: [{ key: 'other', value: 'value' }],
            };
            withCDN = options.withCDN ?? defaultWithCDN;
            if (options.metadata != null) {
                const withCDNEntry = options.metadata.find((m) => m.key === METADATA_KEYS.WITH_CDN);
                if (withCDNEntry != null) {
                    withCDN = true;
                }
            }
            assert.isFalse(withCDN, 'Default should be used when no withCDN specified');
        });
    });
});
//# sourceMappingURL=metadata.test.js.map