import { assert } from 'chai';
import { ethers } from 'ethers';
import { filecoinWarmStorageServiceAbi, filecoinWarmStorageServiceStateViewAbi } from "../abis/gen.js";
import { CONTRACT_ADDRESSES, SIZE_CONSTANTS, TIME_CONSTANTS } from "../utils/constants.js";
import { WarmStorageService } from "../warm-storage/index.js";
import { createMockProvider, extendMockProviderCall, MOCK_ADDRESSES } from "./test-utils.js";
describe('WarmStorageService', () => {
    let mockProvider;
    let cleanup;
    const mockWarmStorageAddress = MOCK_ADDRESSES.WARM_STORAGE;
    const mockViewAddress = MOCK_ADDRESSES.WARM_STORAGE_VIEW;
    const clientAddress = '0x1234567890123456789012345678901234567890';
    const viewInterface = new ethers.Interface(filecoinWarmStorageServiceStateViewAbi);
    const warmInterface = new ethers.Interface(filecoinWarmStorageServiceAbi);
    const handleViewContractAddress = (data) => {
        if (data?.startsWith('0x7a9ebc15') === true) {
            return ethers.AbiCoder.defaultAbiCoder().encode(['address'], [mockViewAddress]);
        }
        return null;
    };
    const createWarmStorageService = async () => {
        return await WarmStorageService.create(mockProvider, mockWarmStorageAddress);
    };
    const mockProviderWithView = (customHandler) => {
        return extendMockProviderCall(mockProvider, async (transaction) => {
            const data = transaction.data;
            const viewResult = handleViewContractAddress(data);
            if (viewResult != null)
                return viewResult;
            const customResult = await customHandler(data);
            if (customResult != null)
                return customResult;
            return `0x${'0'.repeat(64)}`;
        });
    };
    beforeEach(() => {
        mockProvider = createMockProvider();
        cleanup = undefined;
    });
    afterEach(() => {
        if (cleanup) {
            cleanup();
        }
    });
    describe('Instantiation', () => {
        it('should create instance with required parameters', async () => {
            const warmStorageService = await createWarmStorageService();
            assert.exists(warmStorageService);
            assert.isFunction(warmStorageService.getClientDataSets);
        });
    });
    describe('getDataSet', () => {
        it('should return a single data set by ID', async () => {
            const warmStorageService = await createWarmStorageService();
            const dataSetId = 123;
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0xbdaac056') === true) {
                    const dataSetInfo = {
                        pdpRailId: 456,
                        cacheMissRailId: 457,
                        cdnRailId: 458,
                        payer: '0x1234567890123456789012345678901234567890',
                        payee: '0x2345678901234567890123456789012345678901',
                        serviceProvider: '0x3456789012345678901234567890123456789012',
                        commissionBps: 100,
                        clientDataSetId: 5,
                        pdpEndEpoch: 0,
                        providerId: 1,
                        cdnEndEpoch: 0,
                    };
                    return viewInterface.encodeFunctionResult('getDataSet', [dataSetInfo]);
                }
                return null;
            });
            const result = await warmStorageService.getDataSet(dataSetId);
            assert.exists(result);
            assert.equal(result?.pdpRailId, 456);
            assert.equal(result?.cacheMissRailId, 457);
            assert.equal(result?.cdnRailId, 458);
            assert.equal(result?.payer, '0x1234567890123456789012345678901234567890');
            assert.equal(result?.clientDataSetId, 5);
        });
        it('should throw for non-existent data set', async () => {
            const warmStorageService = await createWarmStorageService();
            const dataSetId = 999;
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0xbdaac056') === true) {
                    const emptyDataSet = {
                        pdpRailId: 0,
                        cacheMissRailId: 0,
                        cdnRailId: 0,
                        payer: ethers.ZeroAddress,
                        payee: ethers.ZeroAddress,
                        serviceProvider: ethers.ZeroAddress,
                        commissionBps: 0,
                        clientDataSetId: 0,
                        pdpEndEpoch: 0,
                        providerId: 0,
                        cdnEndEpoch: 0,
                    };
                    return viewInterface.encodeFunctionResult('getDataSet', [emptyDataSet]);
                }
                return null;
            });
            try {
                await warmStorageService.getDataSet(dataSetId);
                assert.fail('Should have thrown error for non-existent data set');
            }
            catch (error) {
                assert.include(error.message, 'Data set 999 does not exist');
            }
        });
        it('should handle contract revert gracefully', async () => {
            const warmStorageService = await createWarmStorageService();
            const dataSetId = 999;
            const originalCall = mockProvider.call;
            mockProvider.call = async (transaction) => {
                const data = transaction.data;
                const viewResult = handleViewContractAddress(data);
                if (viewResult != null)
                    return viewResult;
                if (data?.startsWith('0xbdaac056') === true) {
                    throw new Error('execution reverted: Contract error');
                }
                return originalCall.call(mockProvider, transaction);
            };
            try {
                await warmStorageService.getDataSet(dataSetId);
                assert.fail('Should have thrown error for contract revert');
            }
            catch (error) {
                assert.include(error.message, 'execution reverted');
            }
            mockProvider.call = originalCall;
        });
    });
    describe('getClientDataSets', () => {
        it('should return empty array when client has no data sets', async () => {
            const warmStorageService = await createWarmStorageService();
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0x967c6f21') === true) {
                    return viewInterface.encodeFunctionResult('getClientDataSets', [[]]);
                }
                return null;
            });
            const dataSets = await warmStorageService.getClientDataSets(clientAddress);
            assert.isArray(dataSets);
            assert.lengthOf(dataSets, 0);
        });
        it('should return data sets for a client', async () => {
            const warmStorageService = await createWarmStorageService();
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0x967c6f21') === true) {
                    const dataSet1 = {
                        pdpRailId: 123n,
                        cacheMissRailId: 0n,
                        cdnRailId: 0n,
                        payer: '0x1234567890123456789012345678901234567890',
                        payee: '0xabcdef1234567890123456789012345678901234',
                        commissionBps: 100n,
                        clientDataSetId: 0n,
                        paymentEndEpoch: 0n,
                        providerId: 1n,
                    };
                    const dataSet2 = {
                        pdpRailId: 456n,
                        cacheMissRailId: 457n,
                        cdnRailId: 458n,
                        payer: '0x1234567890123456789012345678901234567890',
                        payee: '0x9876543210987654321098765432109876543210',
                        commissionBps: 200n,
                        clientDataSetId: 1n,
                        paymentEndEpoch: 0n,
                        providerId: 2n,
                    };
                    const dataSets = [
                        [
                            dataSet1.pdpRailId,
                            dataSet1.cacheMissRailId,
                            dataSet1.cdnRailId,
                            dataSet1.payer,
                            dataSet1.payee,
                            dataSet1.payee,
                            dataSet1.commissionBps,
                            dataSet1.clientDataSetId,
                            dataSet1.paymentEndEpoch,
                            dataSet1.providerId,
                            0,
                        ],
                        [
                            dataSet2.pdpRailId,
                            dataSet2.cacheMissRailId,
                            dataSet2.cdnRailId,
                            dataSet2.payer,
                            dataSet2.payee,
                            dataSet2.payee,
                            dataSet2.commissionBps,
                            dataSet2.clientDataSetId,
                            dataSet2.paymentEndEpoch,
                            dataSet2.providerId,
                            0,
                        ],
                    ];
                    return viewInterface.encodeFunctionResult('getClientDataSets', [dataSets]);
                }
                return null;
            });
            const dataSets = await warmStorageService.getClientDataSets(clientAddress);
            assert.isArray(dataSets);
            assert.lengthOf(dataSets, 2);
            assert.equal(dataSets[0].pdpRailId, 123);
            assert.equal(dataSets[0].payer.toLowerCase(), '0x1234567890123456789012345678901234567890'.toLowerCase());
            assert.equal(dataSets[0].payee.toLowerCase(), '0xabcdef1234567890123456789012345678901234'.toLowerCase());
            assert.equal(dataSets[0].commissionBps, 100);
            assert.equal(dataSets[0].clientDataSetId, 0);
            assert.equal(dataSets[0].cdnRailId, 0);
            assert.equal(dataSets[1].pdpRailId, 456);
            assert.equal(dataSets[1].payer.toLowerCase(), '0x1234567890123456789012345678901234567890'.toLowerCase());
            assert.equal(dataSets[1].payee.toLowerCase(), '0x9876543210987654321098765432109876543210'.toLowerCase());
            assert.equal(dataSets[1].commissionBps, 200);
            assert.equal(dataSets[1].clientDataSetId, 1);
            assert.isAbove(dataSets[1].cdnRailId, 0);
        });
        it('should handle contract call errors gracefully', async () => {
            const warmStorageService = await createWarmStorageService();
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0x967c6f21') === true) {
                    throw new Error('Contract call failed');
                }
                return null;
            });
            try {
                await warmStorageService.getClientDataSets(clientAddress);
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'Failed to get client data sets');
                assert.include(error.message, 'Contract call failed');
            }
        });
    });
    describe('getClientDataSetsWithDetails', () => {
        it('should enhance data sets with PDPVerifier details', async () => {
            const warmStorageService = await createWarmStorageService();
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0x7dab7c40') === true) {
                    return viewInterface.encodeFunctionResult('clientDataSets', [[242n]]);
                }
                if (data?.startsWith('0xca759f27') === true) {
                    return ethers.zeroPadValue('0x01', 32);
                }
                if (data?.startsWith('0x1c5ae80f') === true) {
                    return ethers.zeroPadValue('0x02', 32);
                }
                if (data?.startsWith('0x2b3129bb') === true) {
                    return ethers.zeroPadValue(mockWarmStorageAddress, 32);
                }
                if (data?.startsWith('0xbdaac056') === true) {
                    const dataSetInfo = {
                        pdpRailId: 48,
                        cacheMissRailId: 0,
                        cdnRailId: 0,
                        payer: clientAddress,
                        payee: '0xabcdef1234567890123456789012345678901234',
                        serviceProvider: '0xabcdef1234567890123456789012345678901234',
                        commissionBps: 100,
                        clientDataSetId: 0,
                        pdpEndEpoch: 0,
                        providerId: 1,
                        cdnEndEpoch: 0,
                    };
                    return viewInterface.encodeFunctionResult('getDataSet', [dataSetInfo]);
                }
                return null;
            });
            const originalGetNetwork = mockProvider.getNetwork;
            mockProvider.getNetwork = async () => ({ chainId: 314159n, name: 'calibration' });
            const detailedDataSets = await warmStorageService.getClientDataSetsWithDetails(clientAddress);
            assert.lengthOf(detailedDataSets, 1);
            assert.equal(detailedDataSets[0].pdpRailId, 48);
            assert.equal(detailedDataSets[0].pdpVerifierDataSetId, 242);
            assert.equal(detailedDataSets[0].nextPieceId, 2);
            assert.equal(detailedDataSets[0].currentPieceCount, 2);
            assert.isTrue(detailedDataSets[0].isLive);
            assert.isTrue(detailedDataSets[0].isManaged);
            mockProvider.getNetwork = originalGetNetwork;
        });
        it('should filter unmanaged data sets when onlyManaged is true', async () => {
            const warmStorageService = await createWarmStorageService();
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0x7dab7c40') === true) {
                    return viewInterface.encodeFunctionResult('clientDataSets', [[242n, 243n]]);
                }
                if (data?.startsWith('0xca759f27') === true) {
                    return ethers.zeroPadValue('0x01', 32);
                }
                if (data?.startsWith('0x2b3129bb') === true) {
                    const dataSetIdHex = data.slice(10, 74);
                    if (dataSetIdHex === ethers.zeroPadValue('0xf2', 32).slice(2)) {
                        return ethers.zeroPadValue(mockWarmStorageAddress, 32);
                    }
                    else if (dataSetIdHex === ethers.zeroPadValue('0xf3', 32).slice(2)) {
                        return ethers.zeroPadValue('0x1234567890123456789012345678901234567890', 32);
                    }
                    return ethers.zeroPadValue('0x0000000000000000000000000000000000000000', 32);
                }
                if (data?.startsWith('0x1c5ae80f') === true) {
                    return ethers.zeroPadValue('0x01', 32);
                }
                if (data?.startsWith('0xbdaac056') === true) {
                    const dataSetIdHex = data.slice(10, 74);
                    const baseInfo = (id) => ({
                        pdpRailId: id === 242 ? 48 : 49,
                        cacheMissRailId: 0,
                        cdnRailId: 0,
                        payer: clientAddress,
                        payee: id === 242 ? '0xabc1234567890123456789012345678901234567' : '0xdef1234567890123456789012345678901234567',
                        serviceProvider: id === 242 ? '0xabc1234567890123456789012345678901234567' : '0xdef1234567890123456789012345678901234567',
                        commissionBps: 100,
                        clientDataSetId: id === 242 ? 0 : 1,
                        pdpEndEpoch: 0,
                        providerId: id === 242 ? 1 : 2,
                        cdnEndEpoch: 0,
                    });
                    const id = dataSetIdHex === ethers.zeroPadValue('0xf2', 32).slice(2) ? 242 : 243;
                    return viewInterface.encodeFunctionResult('getDataSet', [baseInfo(id)]);
                }
                return null;
            });
            mockProvider.getNetwork = async () => ({ chainId: 314159n, name: 'calibration' });
            const allDataSets = await warmStorageService.getClientDataSetsWithDetails(clientAddress, false);
            assert.lengthOf(allDataSets, 2);
            const managedDataSets = await warmStorageService.getClientDataSetsWithDetails(clientAddress, true);
            assert.lengthOf(managedDataSets, 1);
            assert.equal(managedDataSets[0].pdpRailId, 48);
            assert.isTrue(managedDataSets[0].isManaged);
        });
        it('should throw error when contract calls fail', async () => {
            const warmStorageService = await createWarmStorageService();
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0x7dab7c40') === true) {
                    return viewInterface.encodeFunctionResult('clientDataSets', [[242n]]);
                }
                if (data?.startsWith('0xbdaac056') === true) {
                    throw new Error('Contract call failed');
                }
                return null;
            });
            mockProvider.getNetwork = async () => ({ chainId: 314159n, name: 'calibration' });
            try {
                await warmStorageService.getClientDataSetsWithDetails(clientAddress);
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'Failed to get details for data set');
                assert.include(error.message, 'Contract call failed');
            }
        });
    });
    describe('getManagedDataSets', () => {
        it('should return only managed data sets', async () => {
            const warmStorageService = await createWarmStorageService();
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0x7dab7c40') === true) {
                    return viewInterface.encodeFunctionResult('clientDataSets', [[242n]]);
                }
                if (data?.startsWith('0xca759f27') === true) {
                    return ethers.zeroPadValue('0x01', 32);
                }
                if (data?.startsWith('0x2b3129bb') === true) {
                    return ethers.zeroPadValue(mockWarmStorageAddress, 32);
                }
                if (data?.startsWith('0x1c5ae80f') === true) {
                    return ethers.zeroPadValue('0x01', 32);
                }
                if (data?.startsWith('0xbdaac056') === true) {
                    const info = {
                        pdpRailId: 48,
                        cacheMissRailId: 0,
                        cdnRailId: 0,
                        payer: clientAddress,
                        payee: '0xabc1234567890123456789012345678901234567',
                        serviceProvider: '0xabc1234567890123456789012345678901234567',
                        commissionBps: 100,
                        clientDataSetId: 0,
                        pdpEndEpoch: 0,
                        providerId: 1,
                        cdnEndEpoch: 0,
                    };
                    return viewInterface.encodeFunctionResult('getDataSet', [info]);
                }
                return null;
            });
            mockProvider.getNetwork = async () => ({ chainId: 314159n, name: 'calibration' });
            const dataSets = await warmStorageService.getClientDataSetsWithDetails(clientAddress);
            const managedDataSets = dataSets.filter((ps) => ps.isManaged);
            assert.lengthOf(managedDataSets, 1);
            assert.isTrue(managedDataSets[0].isManaged);
        });
    });
    describe('getAddPiecesInfo', () => {
        it('should return correct add pieces information', async () => {
            const warmStorageService = await createWarmStorageService();
            const dataSetId = 48;
            cleanup = mockProviderWithView((data) => {
                if (data?.includes('railToDataSet') === true || data?.startsWith('0x2ad6e6b5') === true) {
                    return ethers.zeroPadValue('0x30', 32);
                }
                if (data?.startsWith('0xca759f27') === true) {
                    return ethers.zeroPadValue('0x01', 32);
                }
                if (data?.startsWith('0x1c5ae80f') === true) {
                    return ethers.zeroPadValue('0x05', 32);
                }
                if (data?.startsWith('0x2b3129bb') === true) {
                    return ethers.zeroPadValue(mockWarmStorageAddress, 32);
                }
                if (data?.startsWith('0x967c6f21') === true) {
                    const dataSet = [
                        48n,
                        0n,
                        0n,
                        clientAddress,
                        '0xabc1234567890123456789012345678901234567',
                        '0xabc1234567890123456789012345678901234567',
                        100n,
                        3n,
                        0n,
                        1n,
                        0n,
                    ];
                    return viewInterface.encodeFunctionResult('getClientDataSets', [[dataSet]]);
                }
                if (data?.startsWith('0xbdaac056') === true) {
                    const info = {
                        pdpRailId: 48n,
                        cacheMissRailId: 0n,
                        cdnRailId: 0n,
                        payer: clientAddress,
                        payee: '0xabc1234567890123456789012345678901234567',
                        serviceProvider: '0xabc1234567890123456789012345678901234567',
                        commissionBps: 100n,
                        clientDataSetId: 0n,
                        pdpEndEpoch: 0n,
                        providerId: 1n,
                        cdnEndEpoch: 0n,
                    };
                    return viewInterface.encodeFunctionResult('getDataSet', [info]);
                }
                return null;
            });
            mockProvider.getNetwork = async () => ({ chainId: 314159n, name: 'calibration' });
            const addPiecesInfo = await warmStorageService.getAddPiecesInfo(dataSetId);
            assert.equal(addPiecesInfo.nextPieceId, 5);
            assert.equal(addPiecesInfo.clientDataSetId, 0);
            assert.equal(addPiecesInfo.currentPieceCount, 5);
        });
        it('should throw error if data set is not managed by this WarmStorage', async () => {
            const warmStorageService = await createWarmStorageService();
            const dataSetId = 48;
            cleanup = mockProviderWithView((data) => {
                if (data?.includes('railToDataSet') === true || data?.startsWith('0x2ad6e6b5') === true) {
                    return ethers.zeroPadValue('0x63', 32);
                }
                if (data?.startsWith('0x967c6f21') === true) {
                    const dataSet = [
                        48n,
                        0n,
                        0n,
                        clientAddress,
                        '0xabc1234567890123456789012345678901234567',
                        '0xabc1234567890123456789012345678901234567',
                        100n,
                        3n,
                        0n,
                        1n,
                        0n,
                    ];
                    return viewInterface.encodeFunctionResult('getClientDataSets', [[dataSet]]);
                }
                if (data?.startsWith('0xca759f27') === true) {
                    return ethers.zeroPadValue('0x01', 32);
                }
                if (data?.startsWith('0x2b3129bb') === true) {
                    return ethers.zeroPadValue('0x1234567890123456789012345678901234567890', 32);
                }
                if (data?.startsWith('0x1c5ae80f') === true) {
                    return ethers.zeroPadValue('0x01', 32);
                }
                if (data?.startsWith('0xbdaac056') === true) {
                    const info = {
                        pdpRailId: 48n,
                        cacheMissRailId: 0n,
                        cdnRailId: 0n,
                        payer: clientAddress,
                        payee: '0xabc1234567890123456789012345678901234567',
                        serviceProvider: '0xabc1234567890123456789012345678901234567',
                        commissionBps: 100n,
                        clientDataSetId: 3n,
                        pdpEndEpoch: 0n,
                        providerId: 1n,
                        cdnEndEpoch: 0n,
                    };
                    return viewInterface.encodeFunctionResult('getDataSet', [info]);
                }
                return null;
            });
            mockProvider.getNetwork = async () => ({ chainId: 314159n, name: 'calibration' });
            try {
                await warmStorageService.getAddPiecesInfo(dataSetId);
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'Failed to get add pieces info');
            }
        });
    });
    describe('getNextClientDataSetId', () => {
        it('should return the next client dataset ID', async () => {
            const warmStorageService = await createWarmStorageService();
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0x196ed89b') === true) {
                    return ethers.zeroPadValue('0x05', 32);
                }
                return null;
            });
            const nextId = await warmStorageService.getNextClientDataSetId(clientAddress);
            assert.equal(nextId, 5);
        });
    });
    describe('verifyDataSetCreation', () => {
        it('should verify successful data set creation', async () => {
            const warmStorageService = await createWarmStorageService();
            const mockTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
            const originalGetTransaction = mockProvider.getTransaction;
            mockProvider.getTransaction = async (txHash) => {
                assert.strictEqual(txHash, mockTxHash);
                return {
                    hash: mockTxHash,
                    wait: async () => await mockProvider.getTransactionReceipt(mockTxHash),
                };
            };
            const originalGetTransactionReceipt = mockProvider.getTransactionReceipt;
            mockProvider.getTransactionReceipt = async (txHash) => {
                assert.strictEqual(txHash, mockTxHash);
                return {
                    status: 1,
                    blockNumber: 12345,
                    gasUsed: 100000n,
                    logs: [
                        {
                            serviceProvider: '0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC',
                            topics: [
                                ethers.id('DataSetCreated(uint256,address)'),
                                ethers.zeroPadValue('0x7b', 32),
                                ethers.zeroPadValue(clientAddress, 32),
                            ],
                            data: '0x',
                        },
                    ],
                };
            };
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0xca759f27') === true) {
                    return ethers.zeroPadValue('0x01', 32);
                }
                return null;
            });
            mockProvider.getNetwork = async () => ({ chainId: 314159n, name: 'calibration' });
            const result = await warmStorageService.verifyDataSetCreation(mockTxHash);
            assert.isTrue(result.transactionMined);
            assert.isTrue(result.transactionSuccess);
            assert.equal(result.dataSetId, 123);
            assert.exists(result.dataSetId);
            assert.isTrue(result.dataSetLive);
            assert.exists(result.blockNumber);
            assert.exists(result.gasUsed);
            mockProvider.getTransactionReceipt = originalGetTransactionReceipt;
            mockProvider.getTransaction = originalGetTransaction;
        });
        it('should handle transaction not mined yet', async () => {
            const warmStorageService = await createWarmStorageService();
            const mockTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
            const originalGetTransaction = mockProvider.getTransaction;
            mockProvider.getTransaction = async (txHash) => {
                assert.strictEqual(txHash, mockTxHash);
                return {
                    hash: mockTxHash,
                    wait: async () => null,
                };
            };
            const originalGetTransactionReceipt = mockProvider.getTransactionReceipt;
            mockProvider.getTransactionReceipt = async () => null;
            const result = await warmStorageService.verifyDataSetCreation(mockTxHash);
            assert.isFalse(result.transactionMined);
            assert.isFalse(result.transactionSuccess);
            assert.isUndefined(result.dataSetId);
            assert.isFalse(result.dataSetLive);
            mockProvider.getTransactionReceipt = originalGetTransactionReceipt;
            mockProvider.getTransaction = originalGetTransaction;
        });
    });
    describe('Service Provider ID Operations', () => {
        it('should get list of approved provider IDs', async () => {
            const warmStorageService = await createWarmStorageService();
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0x266afe1b') === true) {
                    return viewInterface.encodeFunctionResult('getApprovedProviders', [[1n, 4n, 7n]]);
                }
                return null;
            });
            const providerIds = await warmStorageService.getApprovedProviderIds();
            assert.lengthOf(providerIds, 3);
            assert.equal(providerIds[0], 1);
            assert.equal(providerIds[1], 4);
            assert.equal(providerIds[2], 7);
        });
        it('should return empty array when no providers are approved', async () => {
            const warmStorageService = await createWarmStorageService();
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0x266afe1b') === true) {
                    return viewInterface.encodeFunctionResult('getApprovedProviders', [[]]);
                }
                return null;
            });
            const providerIds = await warmStorageService.getApprovedProviderIds();
            assert.lengthOf(providerIds, 0);
        });
        it('should check if a provider ID is approved', async () => {
            const warmStorageService = await createWarmStorageService();
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0xb6133b7a') === true) {
                    return viewInterface.encodeFunctionResult('isProviderApproved', [true]);
                }
                return null;
            });
            const isApproved = await warmStorageService.isProviderIdApproved(4);
            assert.isTrue(isApproved);
        });
        it('should check if a provider ID is not approved', async () => {
            const warmStorageService = await createWarmStorageService();
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0xb6133b7a') === true) {
                    return viewInterface.encodeFunctionResult('isProviderApproved', [false]);
                }
                return null;
            });
            const isApproved = await warmStorageService.isProviderIdApproved(99);
            assert.isFalse(isApproved);
        });
        it('should get owner address', async () => {
            const warmStorageService = await createWarmStorageService();
            const ownerAddress = '0xabcdef1234567890123456789012345678901234';
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0x8da5cb5b') === true) {
                    return ethers.zeroPadValue(ownerAddress, 32);
                }
                return null;
            });
            const owner = await warmStorageService.getOwner();
            assert.equal(owner.toLowerCase(), ownerAddress.toLowerCase());
        });
        it('should check if signer is owner', async () => {
            const warmStorageService = await createWarmStorageService();
            const signerAddress = '0x1234567890123456789012345678901234567890';
            const mockSigner = {
                getAddress: async () => signerAddress,
            };
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0x8da5cb5b') === true) {
                    return ethers.zeroPadValue(signerAddress, 32);
                }
                return null;
            });
            const isOwner = await warmStorageService.isOwner(mockSigner);
            assert.isTrue(isOwner);
        });
        it('should check if signer is not owner', async () => {
            const warmStorageService = await createWarmStorageService();
            const signerAddress = '0x1234567890123456789012345678901234567890';
            const ownerAddress = '0xabcdef1234567890123456789012345678901234';
            const mockSigner = {
                getAddress: async () => signerAddress,
            };
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0x8da5cb5b') === true) {
                    return ethers.zeroPadValue(ownerAddress, 32);
                }
                return null;
            });
            const isOwner = await warmStorageService.isOwner(mockSigner);
            assert.isFalse(isOwner);
        });
        it('should get service provider registry address', async () => {
            const warmStorageService = await createWarmStorageService();
            const registryAddress = warmStorageService.getServiceProviderRegistryAddress();
            assert.equal(registryAddress, '0x0000000000000000000000000000000000000001');
        });
        it('should add approved provider (mock transaction)', async () => {
            const warmStorageService = await createWarmStorageService();
            const mockSigner = {
                getAddress: async () => '0x1234567890123456789012345678901234567890',
            };
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0xe4f77d7f') === true) {
                    return `0x${'0'.repeat(64)}`;
                }
                return null;
            });
            const originalGetWarmStorageContract = warmStorageService._getWarmStorageContract;
            warmStorageService._getWarmStorageContract = () => ({
                connect: () => ({
                    addApprovedProvider: async () => ({
                        hash: '0xmocktxhash',
                        wait: async () => ({ status: 1 }),
                    }),
                }),
            });
            const tx = await warmStorageService.addApprovedProvider(mockSigner, 4);
            assert.equal(tx.hash, '0xmocktxhash');
            warmStorageService._getWarmStorageContract = originalGetWarmStorageContract;
        });
        it('should terminate dataset (mock tx)', async () => {
            const warmStorageService = await createWarmStorageService();
            const mockSigner = {
                getAddress: async () => '0x1234567890123456789012345678901234567890',
            };
            const originalGetWarmStorageContract = warmStorageService._getWarmStorageContract;
            warmStorageService._getWarmStorageContract = () => ({
                connect: () => ({
                    terminateService: async (id) => {
                        assert.equal(id, 4);
                        return {
                            hash: '0xmocktxhash',
                            wait: async () => ({ status: 1 }),
                        };
                    },
                }),
            });
            const tx = await warmStorageService.terminateDataSet(mockSigner, 4);
            assert.equal(tx.hash, '0xmocktxhash');
            warmStorageService._getWarmStorageContract = originalGetWarmStorageContract;
        });
        it('should remove approved provider with correct index', async () => {
            const warmStorageService = await createWarmStorageService();
            const mockSigner = {
                getAddress: async () => '0x1234567890123456789012345678901234567890',
            };
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0x266afe1b') === true) {
                    return viewInterface.encodeFunctionResult('getApprovedProviders', [[1n, 4n, 7n]]);
                }
                return null;
            });
            const originalGetWarmStorageContract = warmStorageService._getWarmStorageContract;
            warmStorageService._getWarmStorageContract = () => ({
                connect: () => ({
                    removeApprovedProvider: async (id, index) => {
                        assert.equal(id, 4);
                        assert.equal(index, 1);
                        return {
                            hash: '0xmocktxhash',
                            wait: async () => ({ status: 1 }),
                        };
                    },
                }),
            });
            const tx = await warmStorageService.removeApprovedProvider(mockSigner, 4);
            assert.equal(tx.hash, '0xmocktxhash');
            warmStorageService._getWarmStorageContract = originalGetWarmStorageContract;
        });
        it('should throw when removing non-existent provider', async () => {
            const warmStorageService = await createWarmStorageService();
            const mockSigner = {
                getAddress: async () => '0x1234567890123456789012345678901234567890',
            };
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0x266afe1b') === true) {
                    return viewInterface.encodeFunctionResult('getApprovedProviders', [[1n, 4n, 7n]]);
                }
                return null;
            });
            try {
                await warmStorageService.removeApprovedProvider(mockSigner, 99);
                assert.fail('Should have thrown an error');
            }
            catch (error) {
                assert.include(error.message, 'Provider 99 is not in the approved list');
            }
        });
    });
    describe('Storage Cost Operations', () => {
        describe('calculateStorageCost', () => {
            it('should calculate storage costs correctly for 1 GiB', async () => {
                const warmStorageService = await createWarmStorageService();
                mockProvider.call = async (transaction) => {
                    const data = transaction.data;
                    const viewResult = handleViewContractAddress(data);
                    if (viewResult != null)
                        return viewResult;
                    if (data?.startsWith('0x5482bdf9') === true) {
                        const pricePerTiBPerMonthNoCDN = ethers.parseUnits('2', 18);
                        const pricePerTiBPerMonthWithCDN = ethers.parseUnits('3', 18);
                        const tokenAddress = CONTRACT_ADDRESSES.USDFC.calibration;
                        const epochsPerMonth = TIME_CONSTANTS.EPOCHS_PER_MONTH;
                        const servicePriceInfo = {
                            pricePerTiBPerMonthNoCDN: pricePerTiBPerMonthNoCDN,
                            pricePerTiBPerMonthWithCDN: pricePerTiBPerMonthWithCDN,
                            tokenAddress: tokenAddress,
                            epochsPerMonth: epochsPerMonth,
                        };
                        return warmInterface.encodeFunctionResult('getServicePrice', [servicePriceInfo]);
                    }
                    return `0x${'0'.repeat(64)}`;
                };
                const sizeInBytes = Number(SIZE_CONSTANTS.GiB);
                const costs = await warmStorageService.calculateStorageCost(sizeInBytes);
                assert.exists(costs.perEpoch);
                assert.exists(costs.perDay);
                assert.exists(costs.perMonth);
                assert.exists(costs.withCDN);
                assert.exists(costs.withCDN.perEpoch);
                assert.exists(costs.withCDN.perDay);
                assert.exists(costs.withCDN.perMonth);
                assert.isTrue(costs.perEpoch > 0n);
                assert.isTrue(costs.perDay > costs.perEpoch);
                assert.isTrue(costs.perMonth > costs.perDay);
                assert.isTrue(costs.withCDN.perEpoch > costs.perEpoch);
                assert.isTrue(costs.withCDN.perDay > costs.perDay);
                assert.isTrue(costs.withCDN.perMonth > costs.perMonth);
                assert.equal((costs.withCDN.perEpoch * 2n) / costs.perEpoch, 3n);
            });
            it('should scale costs linearly with size', async () => {
                const warmStorageService = await createWarmStorageService();
                mockProvider.call = async (transaction) => {
                    const data = transaction.data;
                    const viewResult = handleViewContractAddress(data);
                    if (viewResult != null)
                        return viewResult;
                    if (data?.startsWith('0x5482bdf9') === true) {
                        const pricePerTiBPerMonthNoCDN = ethers.parseUnits('2', 18);
                        const pricePerTiBPerMonthWithCDN = ethers.parseUnits('3', 18);
                        const tokenAddress = CONTRACT_ADDRESSES.USDFC.calibration;
                        const epochsPerMonth = TIME_CONSTANTS.EPOCHS_PER_MONTH;
                        const servicePriceInfo = {
                            pricePerTiBPerMonthNoCDN: pricePerTiBPerMonthNoCDN,
                            pricePerTiBPerMonthWithCDN: pricePerTiBPerMonthWithCDN,
                            tokenAddress: tokenAddress,
                            epochsPerMonth: epochsPerMonth,
                        };
                        return warmInterface.encodeFunctionResult('getServicePrice', [servicePriceInfo]);
                    }
                    return `0x${'0'.repeat(64)}`;
                };
                const costs1GiB = await warmStorageService.calculateStorageCost(Number(SIZE_CONSTANTS.GiB));
                const costs10GiB = await warmStorageService.calculateStorageCost(Number(10n * SIZE_CONSTANTS.GiB));
                const ratio = Number(costs10GiB.perEpoch) / Number(costs1GiB.perEpoch);
                assert.closeTo(ratio, 10, 0.01);
                assert.equal(costs10GiB.perDay.toString(), (costs10GiB.perEpoch * 2880n).toString());
                const expectedMonth = costs10GiB.perEpoch * TIME_CONSTANTS.EPOCHS_PER_MONTH;
                const monthRatio = Number(costs10GiB.perMonth) / Number(expectedMonth);
                assert.closeTo(monthRatio, 1, 0.0001);
            });
            it('should fetch pricing from WarmStorage contract', async () => {
                const warmStorageService = await createWarmStorageService();
                let getServicePriceCalled = false;
                const originalCall = mockProvider.call;
                mockProvider.call = async (transaction) => {
                    const data = transaction.data;
                    const viewResult = handleViewContractAddress(data);
                    if (viewResult != null)
                        return viewResult;
                    if (data?.startsWith('0x5482bdf9') === true) {
                        getServicePriceCalled = true;
                        const pricePerTiBPerMonthNoCDN = ethers.parseUnits('2', 18);
                        const pricePerTiBPerMonthWithCDN = ethers.parseUnits('3', 18);
                        const tokenAddress = CONTRACT_ADDRESSES.USDFC.calibration;
                        const epochsPerMonth = TIME_CONSTANTS.EPOCHS_PER_MONTH;
                        const servicePriceInfo = {
                            pricePerTiBPerMonthNoCDN: pricePerTiBPerMonthNoCDN,
                            pricePerTiBPerMonthWithCDN: pricePerTiBPerMonthWithCDN,
                            tokenAddress: tokenAddress,
                            epochsPerMonth: epochsPerMonth,
                        };
                        return warmInterface.encodeFunctionResult('getServicePrice', [servicePriceInfo]);
                    }
                    return await originalCall.call(mockProvider, transaction);
                };
                await warmStorageService.calculateStorageCost(Number(SIZE_CONSTANTS.GiB));
                assert.isTrue(getServicePriceCalled, 'Should have called getServicePrice on WarmStorage contract');
            });
        });
        describe('checkAllowanceForStorage', () => {
            it('should check allowances for storage operations', async () => {
                const warmStorageService = await createWarmStorageService();
                const mockPaymentsService = {
                    serviceApproval: async (serviceAddress) => {
                        assert.strictEqual(serviceAddress, mockWarmStorageAddress);
                        return {
                            isApproved: false,
                            rateAllowance: 0n,
                            lockupAllowance: 0n,
                            rateUsed: 0n,
                            lockupUsed: 0n,
                        };
                    },
                };
                mockProvider.call = async (transaction) => {
                    const data = transaction.data;
                    const viewResult = handleViewContractAddress(data);
                    if (viewResult != null)
                        return viewResult;
                    if (data?.startsWith('0x5482bdf9') === true) {
                        const pricePerTiBPerMonthNoCDN = ethers.parseUnits('2', 18);
                        const pricePerTiBPerMonthWithCDN = ethers.parseUnits('3', 18);
                        const tokenAddress = CONTRACT_ADDRESSES.USDFC.calibration;
                        const epochsPerMonth = TIME_CONSTANTS.EPOCHS_PER_MONTH;
                        const servicePriceInfo = {
                            pricePerTiBPerMonthNoCDN: pricePerTiBPerMonthNoCDN,
                            pricePerTiBPerMonthWithCDN: pricePerTiBPerMonthWithCDN,
                            tokenAddress: tokenAddress,
                            epochsPerMonth: epochsPerMonth,
                        };
                        return warmInterface.encodeFunctionResult('getServicePrice', [servicePriceInfo]);
                    }
                    return `0x${'0'.repeat(64)}`;
                };
                const check = await warmStorageService.checkAllowanceForStorage(Number(10n * SIZE_CONSTANTS.GiB), false, mockPaymentsService);
                assert.exists(check.rateAllowanceNeeded);
                assert.exists(check.lockupAllowanceNeeded);
                assert.exists(check.currentRateAllowance);
                assert.exists(check.currentLockupAllowance);
                assert.exists(check.currentRateUsed);
                assert.exists(check.currentLockupUsed);
                assert.exists(check.sufficient);
                assert.exists(check.costs);
                assert.exists(check.costs.perEpoch);
                assert.exists(check.costs.perDay);
                assert.exists(check.costs.perMonth);
                assert.isAbove(Number(check.costs.perEpoch), 0);
                assert.isAbove(Number(check.costs.perDay), 0);
                assert.isAbove(Number(check.costs.perMonth), 0);
                assert.exists(check.lockupAllowanceNeeded);
                assert.isTrue(check.lockupAllowanceNeeded > 0n);
                assert.isFalse(check.sufficient);
            });
            it('should return sufficient when allowances are adequate', async () => {
                const warmStorageService = await createWarmStorageService();
                const mockPaymentsService = {
                    serviceApproval: async (serviceAddress) => {
                        assert.strictEqual(serviceAddress, mockWarmStorageAddress);
                        return {
                            isApproved: true,
                            rateAllowance: ethers.parseUnits('100', 18),
                            lockupAllowance: ethers.parseUnits('10000', 18),
                            rateUsed: 0n,
                            lockupUsed: 0n,
                        };
                    },
                };
                mockProvider.call = async (transaction) => {
                    const data = transaction.data;
                    const viewResult = handleViewContractAddress(data);
                    if (viewResult != null)
                        return viewResult;
                    if (data?.startsWith('0x5482bdf9') === true) {
                        const pricePerTiBPerMonthNoCDN = ethers.parseUnits('2', 18);
                        const pricePerTiBPerMonthWithCDN = ethers.parseUnits('3', 18);
                        const tokenAddress = CONTRACT_ADDRESSES.USDFC.calibration;
                        const epochsPerMonth = TIME_CONSTANTS.EPOCHS_PER_MONTH;
                        const servicePriceInfo = {
                            pricePerTiBPerMonthNoCDN: pricePerTiBPerMonthNoCDN,
                            pricePerTiBPerMonthWithCDN: pricePerTiBPerMonthWithCDN,
                            tokenAddress: tokenAddress,
                            epochsPerMonth: epochsPerMonth,
                        };
                        return warmInterface.encodeFunctionResult('getServicePrice', [servicePriceInfo]);
                    }
                    return `0x${'0'.repeat(64)}`;
                };
                const check = await warmStorageService.checkAllowanceForStorage(Number(SIZE_CONSTANTS.MiB), false, mockPaymentsService);
                assert.isTrue(check.sufficient);
                assert.exists(check.costs);
                assert.exists(check.costs.perEpoch);
                assert.exists(check.costs.perDay);
                assert.exists(check.costs.perMonth);
                assert.exists(check.lockupAllowanceNeeded);
                assert.equal(check.lockupAllowanceNeeded, 0n);
            });
            it('should include depositAmountNeeded in response', async () => {
                const warmStorageService = await createWarmStorageService();
                const mockPaymentsService = {
                    serviceApproval: async (serviceAddress) => {
                        assert.strictEqual(serviceAddress, mockWarmStorageAddress);
                        return {
                            isApproved: false,
                            rateAllowance: 0n,
                            lockupAllowance: 0n,
                            rateUsed: 0n,
                            lockupUsed: 0n,
                        };
                    },
                };
                mockProvider.call = async (transaction) => {
                    const data = transaction.data;
                    const viewResult = handleViewContractAddress(data);
                    if (viewResult != null)
                        return viewResult;
                    if (data?.startsWith('0x5482bdf9') === true) {
                        const pricePerTiBPerMonthNoCDN = ethers.parseUnits('2', 18);
                        const pricePerTiBPerMonthWithCDN = ethers.parseUnits('3', 18);
                        const tokenAddress = CONTRACT_ADDRESSES.USDFC.calibration;
                        const epochsPerMonth = TIME_CONSTANTS.EPOCHS_PER_MONTH;
                        const servicePriceInfo = {
                            pricePerTiBPerMonthNoCDN: pricePerTiBPerMonthNoCDN,
                            pricePerTiBPerMonthWithCDN: pricePerTiBPerMonthWithCDN,
                            tokenAddress: tokenAddress,
                            epochsPerMonth: epochsPerMonth,
                        };
                        return warmInterface.encodeFunctionResult('getServicePrice', [servicePriceInfo]);
                    }
                    return `0x${'0'.repeat(64)}`;
                };
                const check = await warmStorageService.checkAllowanceForStorage(Number(SIZE_CONSTANTS.GiB), false, mockPaymentsService);
                assert.exists(check.lockupAllowanceNeeded);
                assert.isTrue(check.lockupAllowanceNeeded > 0n);
                assert.exists(check.depositAmountNeeded);
                assert.isTrue(check.depositAmountNeeded > 0n);
                const expectedDeposit = check.costs.perEpoch * BigInt(10) * BigInt(TIME_CONSTANTS.EPOCHS_PER_DAY);
                assert.equal(check.depositAmountNeeded.toString(), expectedDeposit.toString());
            });
            it('should use custom lockup days when provided', async () => {
                const warmStorageService = await createWarmStorageService();
                const mockPaymentsService = {
                    serviceApproval: async (serviceAddress) => {
                        assert.strictEqual(serviceAddress, mockWarmStorageAddress);
                        return {
                            isApproved: false,
                            rateAllowance: 0n,
                            lockupAllowance: 0n,
                            rateUsed: 0n,
                            lockupUsed: 0n,
                        };
                    },
                };
                mockProvider.call = async (transaction) => {
                    const data = transaction.data;
                    const viewResult = handleViewContractAddress(data);
                    if (viewResult != null)
                        return viewResult;
                    if (data?.startsWith('0x5482bdf9') === true) {
                        const pricePerTiBPerMonthNoCDN = ethers.parseUnits('2', 18);
                        const pricePerTiBPerMonthWithCDN = ethers.parseUnits('3', 18);
                        const tokenAddress = CONTRACT_ADDRESSES.USDFC.calibration;
                        const epochsPerMonth = TIME_CONSTANTS.EPOCHS_PER_MONTH;
                        const servicePriceInfo = {
                            pricePerTiBPerMonthNoCDN: pricePerTiBPerMonthNoCDN,
                            pricePerTiBPerMonthWithCDN: pricePerTiBPerMonthWithCDN,
                            tokenAddress: tokenAddress,
                            epochsPerMonth: epochsPerMonth,
                        };
                        return warmInterface.encodeFunctionResult('getServicePrice', [servicePriceInfo]);
                    }
                    return `0x${'0'.repeat(64)}`;
                };
                const customLockupDays = 20;
                const check = await warmStorageService.checkAllowanceForStorage(Number(SIZE_CONSTANTS.GiB), false, mockPaymentsService, customLockupDays);
                const expectedDeposit = check.costs.perEpoch * BigInt(customLockupDays) * BigInt(TIME_CONSTANTS.EPOCHS_PER_DAY);
                assert.equal(check.depositAmountNeeded.toString(), expectedDeposit.toString());
                const defaultCheck = await warmStorageService.checkAllowanceForStorage(Number(SIZE_CONSTANTS.GiB), false, mockPaymentsService);
                assert.equal(check.depositAmountNeeded.toString(), (defaultCheck.depositAmountNeeded * 2n).toString());
            });
        });
        describe('prepareStorageUpload', () => {
            it('should prepare storage upload with required actions', async () => {
                const warmStorageService = await createWarmStorageService();
                let approveServiceCalled = false;
                const mockPaymentsService = {
                    serviceApproval: async () => ({
                        isApproved: false,
                        rateAllowance: 0n,
                        lockupAllowance: 0n,
                        rateUsed: 0n,
                        lockupUsed: 0n,
                    }),
                    accountInfo: async () => ({
                        funds: ethers.parseUnits('10000', 18),
                        lockupCurrent: 0n,
                        lockupRate: 0n,
                        lockupLastSettledAt: 1000000,
                        availableFunds: ethers.parseUnits('10000', 18),
                    }),
                    approveService: async (serviceAddress, rateAllowance, lockupAllowance) => {
                        assert.strictEqual(serviceAddress, mockWarmStorageAddress);
                        assert.isTrue(rateAllowance > 0n);
                        assert.isTrue(lockupAllowance > 0n);
                        approveServiceCalled = true;
                        return '0xmocktxhash';
                    },
                };
                mockProvider.call = async (transaction) => {
                    const data = transaction.data;
                    const viewResult = handleViewContractAddress(data);
                    if (viewResult != null)
                        return viewResult;
                    if (data?.startsWith('0x5482bdf9') === true) {
                        const pricePerTiBPerMonthNoCDN = ethers.parseUnits('2', 18);
                        const pricePerTiBPerMonthWithCDN = ethers.parseUnits('3', 18);
                        const tokenAddress = CONTRACT_ADDRESSES.USDFC.calibration;
                        const epochsPerMonth = TIME_CONSTANTS.EPOCHS_PER_MONTH;
                        const servicePriceInfo = {
                            pricePerTiBPerMonthNoCDN: pricePerTiBPerMonthNoCDN,
                            pricePerTiBPerMonthWithCDN: pricePerTiBPerMonthWithCDN,
                            tokenAddress: tokenAddress,
                            epochsPerMonth: epochsPerMonth,
                        };
                        return warmInterface.encodeFunctionResult('getServicePrice', [servicePriceInfo]);
                    }
                    return `0x${'0'.repeat(64)}`;
                };
                const prep = await warmStorageService.prepareStorageUpload({
                    dataSize: Number(10n * SIZE_CONSTANTS.GiB),
                    withCDN: false,
                }, mockPaymentsService);
                assert.exists(prep.estimatedCost);
                assert.exists(prep.estimatedCost.perEpoch);
                assert.exists(prep.estimatedCost.perDay);
                assert.exists(prep.estimatedCost.perMonth);
                assert.exists(prep.allowanceCheck);
                assert.isArray(prep.actions);
                assert.isAtLeast(prep.actions.length, 1);
                const approvalAction = prep.actions.find((a) => a.type === 'approveService');
                assert.exists(approvalAction);
                assert.include(approvalAction.description, 'Approve service');
                assert.isFunction(approvalAction.execute);
                await approvalAction.execute();
                assert.isTrue(approveServiceCalled);
            });
            it('should include deposit action when balance insufficient', async () => {
                const warmStorageService = await createWarmStorageService();
                let depositCalled = false;
                const mockPaymentsService = {
                    serviceApproval: async () => ({
                        isApproved: false,
                        rateAllowance: 0n,
                        lockupAllowance: 0n,
                        rateUsed: 0n,
                        lockupUsed: 0n,
                    }),
                    accountInfo: async () => ({
                        funds: ethers.parseUnits('0.001', 18),
                        lockupCurrent: 0n,
                        lockupRate: 0n,
                        lockupLastSettledAt: 1000000,
                        availableFunds: ethers.parseUnits('0.001', 18),
                    }),
                    deposit: async (amount) => {
                        assert.isTrue(amount > 0n);
                        depositCalled = true;
                        return '0xmockdeposittxhash';
                    },
                    approveService: async () => '0xmocktxhash',
                };
                mockProvider.call = async (transaction) => {
                    const data = transaction.data;
                    const viewResult = handleViewContractAddress(data);
                    if (viewResult != null)
                        return viewResult;
                    if (data?.startsWith('0x5482bdf9') === true) {
                        const pricePerTiBPerMonthNoCDN = ethers.parseUnits('2', 18);
                        const pricePerTiBPerMonthWithCDN = ethers.parseUnits('3', 18);
                        const tokenAddress = CONTRACT_ADDRESSES.USDFC.calibration;
                        const epochsPerMonth = TIME_CONSTANTS.EPOCHS_PER_MONTH;
                        const servicePriceInfo = {
                            pricePerTiBPerMonthNoCDN: pricePerTiBPerMonthNoCDN,
                            pricePerTiBPerMonthWithCDN: pricePerTiBPerMonthWithCDN,
                            tokenAddress: tokenAddress,
                            epochsPerMonth: epochsPerMonth,
                        };
                        return warmInterface.encodeFunctionResult('getServicePrice', [servicePriceInfo]);
                    }
                    return `0x${'0'.repeat(64)}`;
                };
                const prep = await warmStorageService.prepareStorageUpload({
                    dataSize: Number(10n * SIZE_CONSTANTS.GiB),
                    withCDN: false,
                }, mockPaymentsService);
                assert.isAtLeast(prep.actions.length, 2);
                const depositAction = prep.actions.find((a) => a.type === 'deposit');
                assert.exists(depositAction);
                assert.include(depositAction.description, 'Deposit');
                assert.include(depositAction.description, 'USDFC');
                const approvalAction = prep.actions.find((a) => a.type === 'approveService');
                assert.exists(approvalAction);
                await depositAction.execute();
                assert.isTrue(depositCalled);
            });
            it('should return no actions when everything is ready', async () => {
                const warmStorageService = await createWarmStorageService();
                const mockPaymentsService = {
                    serviceApproval: async () => ({
                        isApproved: true,
                        rateAllowance: ethers.parseUnits('1000', 18),
                        lockupAllowance: ethers.parseUnits('100000', 18),
                        rateUsed: 0n,
                        lockupUsed: 0n,
                    }),
                    accountInfo: async () => ({
                        funds: ethers.parseUnits('10000', 18),
                        lockupCurrent: 0n,
                        lockupRate: 0n,
                        lockupLastSettledAt: 1000000,
                        availableFunds: ethers.parseUnits('10000', 18),
                    }),
                };
                mockProvider.call = async (transaction) => {
                    const data = transaction.data;
                    const viewResult = handleViewContractAddress(data);
                    if (viewResult != null)
                        return viewResult;
                    if (data?.startsWith('0x5482bdf9') === true) {
                        const pricePerTiBPerMonthNoCDN = ethers.parseUnits('2', 18);
                        const pricePerTiBPerMonthWithCDN = ethers.parseUnits('3', 18);
                        const tokenAddress = CONTRACT_ADDRESSES.USDFC.calibration;
                        const epochsPerMonth = TIME_CONSTANTS.EPOCHS_PER_MONTH;
                        const servicePriceInfo = {
                            pricePerTiBPerMonthNoCDN: pricePerTiBPerMonthNoCDN,
                            pricePerTiBPerMonthWithCDN: pricePerTiBPerMonthWithCDN,
                            tokenAddress: tokenAddress,
                            epochsPerMonth: epochsPerMonth,
                        };
                        return warmInterface.encodeFunctionResult('getServicePrice', [servicePriceInfo]);
                    }
                    return `0x${'0'.repeat(64)}`;
                };
                const prep = await warmStorageService.prepareStorageUpload({
                    dataSize: Number(SIZE_CONSTANTS.MiB),
                    withCDN: false,
                }, mockPaymentsService);
                assert.lengthOf(prep.actions, 0);
                assert.isTrue(prep.allowanceCheck.sufficient);
            });
        });
    });
    describe('Comprehensive Status Methods', () => {
        it('should combine PDP server and chain verification status', async () => {
            const warmStorageService = await createWarmStorageService();
            const mockTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
            const mockPDPServer = {
                getDataSetCreationStatus: async (txHash) => {
                    assert.strictEqual(txHash, mockTxHash);
                    return {
                        createMessageHash: mockTxHash,
                        dataSetCreated: true,
                        service: 'test-service',
                        txStatus: 'confirmed',
                        ok: true,
                        dataSetId: 123,
                    };
                },
            };
            const originalGetTransaction = mockProvider.getTransaction;
            mockProvider.getTransaction = async (txHash) => {
                assert.strictEqual(txHash, mockTxHash);
                return {
                    hash: mockTxHash,
                    wait: async () => await mockProvider.getTransactionReceipt(mockTxHash),
                };
            };
            const originalGetTransactionReceipt = mockProvider.getTransactionReceipt;
            mockProvider.getTransactionReceipt = async (txHash) => {
                assert.strictEqual(txHash, mockTxHash);
                return {
                    status: 1,
                    blockNumber: 12345,
                    gasUsed: 100000n,
                    logs: [
                        {
                            serviceProvider: '0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC',
                            topics: [
                                ethers.id('DataSetCreated(uint256,address)'),
                                ethers.zeroPadValue('0x7b', 32),
                                ethers.zeroPadValue(clientAddress, 32),
                            ],
                            data: '0x',
                        },
                    ],
                };
            };
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0xca759f27') === true) {
                    return ethers.zeroPadValue('0x01', 32);
                }
                return null;
            });
            mockProvider.getNetwork = async () => ({ chainId: 314159n, name: 'calibration' });
            const result = await warmStorageService.getComprehensiveDataSetStatus(mockTxHash, mockPDPServer);
            assert.strictEqual(result.txHash, mockTxHash);
            assert.exists(result.serverStatus);
            assert.exists(result.chainStatus);
            assert.isTrue(result.serverStatus?.dataSetCreated);
            assert.isTrue(result.serverStatus?.ok);
            assert.strictEqual(result.serverStatus?.dataSetId, 123);
            assert.isTrue(result.chainStatus.transactionMined);
            assert.isTrue(result.chainStatus.transactionSuccess);
            assert.exists(result.chainStatus.dataSetId);
            assert.strictEqual(result.chainStatus.dataSetId, 123);
            assert.isTrue(result.chainStatus.dataSetLive);
            assert.isTrue(result.summary.isComplete);
            assert.strictEqual(result.summary.dataSetId, 123);
            assert.isNull(result.summary.error);
            mockProvider.getTransactionReceipt = originalGetTransactionReceipt;
            mockProvider.getTransaction = originalGetTransaction;
        });
        it('should handle PDP server failure gracefully', async () => {
            const warmStorageService = await createWarmStorageService();
            const mockTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
            const mockPDPServer = {
                getDataSetCreationStatus: async () => {
                    throw new Error('Server unavailable');
                },
            };
            const originalGetTransaction = mockProvider.getTransaction;
            mockProvider.getTransaction = async (txHash) => {
                assert.strictEqual(txHash, mockTxHash);
                return {
                    hash: mockTxHash,
                    wait: async () => await mockProvider.getTransactionReceipt(mockTxHash),
                };
            };
            const originalGetTransactionReceipt = mockProvider.getTransactionReceipt;
            mockProvider.getTransactionReceipt = async () => {
                return {
                    status: 1,
                    blockNumber: 12345,
                    gasUsed: 100000n,
                    logs: [
                        {
                            serviceProvider: '0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC',
                            topics: [
                                ethers.id('DataSetCreated(uint256,address)'),
                                ethers.zeroPadValue('0x7b', 32),
                                ethers.zeroPadValue(clientAddress, 32),
                            ],
                            data: '0x',
                        },
                    ],
                };
            };
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0xca759f27') === true) {
                    return ethers.zeroPadValue('0x01', 32);
                }
                return null;
            });
            mockProvider.getNetwork = async () => ({ chainId: 314159n, name: 'calibration' });
            const result = await warmStorageService.getComprehensiveDataSetStatus(mockTxHash, mockPDPServer);
            assert.isNull(result.serverStatus);
            assert.isTrue(result.chainStatus.transactionMined);
            assert.isTrue(result.chainStatus.transactionSuccess);
            assert.strictEqual(result.chainStatus.dataSetId, 123);
            assert.isTrue(result.chainStatus.dataSetLive);
            assert.isFalse(result.summary.isComplete, 'isComplete should be false when server status is unavailable');
            assert.strictEqual(result.summary.dataSetId, 123);
            assert.isNull(result.summary.error);
            mockProvider.getTransactionReceipt = originalGetTransactionReceipt;
            mockProvider.getTransaction = originalGetTransaction;
        });
        it('should NOT mark as complete when server has not caught up yet', async () => {
            const warmStorageService = await createWarmStorageService();
            const mockTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
            const mockPDPServer = {
                getDataSetCreationStatus: async () => {
                    throw new Error('Data set creation status not found');
                },
            };
            const originalGetTransaction = mockProvider.getTransaction;
            mockProvider.getTransaction = async (txHash) => {
                assert.strictEqual(txHash, mockTxHash);
                return {
                    hash: mockTxHash,
                    wait: async () => await mockProvider.getTransactionReceipt(mockTxHash),
                };
            };
            const originalGetTransactionReceipt = mockProvider.getTransactionReceipt;
            mockProvider.getTransactionReceipt = async () => {
                return {
                    status: 1,
                    blockNumber: 12345,
                    gasUsed: 100000n,
                    logs: [
                        {
                            serviceProvider: '0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC',
                            topics: [
                                ethers.id('DataSetCreated(uint256,address)'),
                                ethers.zeroPadValue('0x7b', 32),
                                ethers.zeroPadValue(clientAddress, 32),
                            ],
                            data: '0x',
                        },
                    ],
                };
            };
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0xca759f27') === true) {
                    return ethers.zeroPadValue('0x01', 32);
                }
                return null;
            });
            mockProvider.getNetwork = async () => ({ chainId: 314159n, name: 'calibration' });
            const result = await warmStorageService.getComprehensiveDataSetStatus(mockTxHash, mockPDPServer);
            assert.isTrue(result.chainStatus.transactionMined);
            assert.isTrue(result.chainStatus.transactionSuccess);
            assert.isTrue(result.chainStatus.dataSetLive);
            assert.strictEqual(result.chainStatus.dataSetId, 123);
            assert.isNull(result.serverStatus);
            assert.isFalse(result.summary.isComplete, 'isComplete should be false when server has not caught up');
            mockProvider.getTransactionReceipt = originalGetTransactionReceipt;
            mockProvider.getTransaction = originalGetTransaction;
        });
        it('should wait for data set to become live', async () => {
            const warmStorageService = await createWarmStorageService();
            const mockTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
            let callCount = 0;
            const mockPDPServer = {
                getDataSetCreationStatus: async () => {
                    callCount++;
                    if (callCount === 1) {
                        return {
                            createMessageHash: mockTxHash,
                            dataSetCreated: false,
                            service: 'test-service',
                            txStatus: 'pending',
                            ok: null,
                            dataSetId: undefined,
                        };
                    }
                    else {
                        return {
                            createMessageHash: mockTxHash,
                            dataSetCreated: true,
                            service: 'test-service',
                            txStatus: 'confirmed',
                            ok: true,
                            dataSetId: 123,
                        };
                    }
                },
            };
            const originalGetTransaction = mockProvider.getTransaction;
            mockProvider.getTransaction = async (txHash) => {
                assert.strictEqual(txHash, mockTxHash);
                return {
                    hash: mockTxHash,
                    wait: async () => await mockProvider.getTransactionReceipt(mockTxHash),
                };
            };
            const originalGetTransactionReceipt = mockProvider.getTransactionReceipt;
            mockProvider.getTransactionReceipt = async () => {
                if (callCount === 1) {
                    return null;
                }
                else {
                    return {
                        status: 1,
                        blockNumber: 12345,
                        gasUsed: 100000n,
                        logs: [
                            {
                                serviceProvider: '0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC',
                                topics: [
                                    ethers.id('DataSetCreated(uint256,address)'),
                                    ethers.zeroPadValue('0x7b', 32),
                                    ethers.zeroPadValue(clientAddress, 32),
                                ],
                                data: '0x',
                            },
                        ],
                    };
                }
            };
            cleanup = mockProviderWithView((data) => {
                if (data?.startsWith('0xca759f27') === true) {
                    return ethers.zeroPadValue('0x01', 32);
                }
                return null;
            });
            mockProvider.getNetwork = async () => ({ chainId: 314159n, name: 'calibration' });
            const mockTransaction = {
                hash: mockTxHash,
                wait: async () => await mockProvider.getTransactionReceipt(mockTxHash),
            };
            const result = await warmStorageService.waitForDataSetCreationWithStatus(mockTransaction, mockPDPServer, 5000, 100);
            assert.isTrue(result.summary.isComplete);
            assert.strictEqual(result.summary.dataSetId, 123);
            assert.isTrue(callCount >= 2);
            mockProvider.getTransactionReceipt = originalGetTransactionReceipt;
            mockProvider.getTransaction = originalGetTransaction;
        });
        it('should timeout if data set takes too long', async () => {
            const warmStorageService = await createWarmStorageService();
            const mockTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
            const mockPDPServer = {
                getDataSetCreationStatus: async () => {
                    return {
                        createMessageHash: mockTxHash,
                        dataSetCreated: false,
                        service: 'test-service',
                        txStatus: 'pending',
                        ok: null,
                        dataSetId: undefined,
                    };
                },
            };
            const originalGetTransactionReceipt = mockProvider.getTransactionReceipt;
            mockProvider.getTransactionReceipt = async () => null;
            mockProvider.getNetwork = async () => ({ chainId: 314159n, name: 'calibration' });
            try {
                const mockTransaction = { hash: mockTxHash };
                await warmStorageService.waitForDataSetCreationWithStatus(mockTransaction, mockPDPServer, 300, 100);
                assert.fail('Should have thrown timeout error');
            }
            catch (error) {
                assert.include(error.message, 'Data set creation timed out after');
            }
            mockProvider.getTransactionReceipt = originalGetTransactionReceipt;
        });
    });
    describe('getMaxProvingPeriod() and getChallengeWindow()', () => {
        it('should return max proving period from WarmStorage contract', async () => {
            const warmStorageService = await createWarmStorageService();
            const originalCall = mockProvider.call;
            mockProvider.call = async ({ data }) => {
                if (typeof data === 'string' && data.includes('0x')) {
                    return '0x0000000000000000000000000000000000000000000000000000000000000b40';
                }
                return '0x';
            };
            const result = await warmStorageService.getMaxProvingPeriod();
            assert.equal(result, 2880);
            mockProvider.call = originalCall;
        });
        it('should return challenge window from WarmStorage contract', async () => {
            const warmStorageService = await createWarmStorageService();
            const originalCall = mockProvider.call;
            mockProvider.call = async ({ data }) => {
                if (typeof data === 'string' && data.includes('0x')) {
                    return '0x000000000000000000000000000000000000000000000000000000000000003c';
                }
                return '0x';
            };
            const result = await warmStorageService.getChallengeWindow();
            assert.equal(result, 60);
            mockProvider.call = originalCall;
        });
        it('should handle contract call failures', async () => {
            const warmStorageService = await createWarmStorageService();
            const originalCall = mockProvider.call;
            mockProvider.call = async () => {
                throw new Error('Contract call failed');
            };
            try {
                await warmStorageService.getMaxProvingPeriod();
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'Contract call failed');
            }
            mockProvider.call = originalCall;
        });
    });
});
//# sourceMappingURL=warm-storage-service.test.js.map