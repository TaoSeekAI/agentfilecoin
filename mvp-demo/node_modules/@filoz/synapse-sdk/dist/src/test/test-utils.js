import { ethers } from 'ethers';
import { CONTRACT_ABIS, CONTRACT_ADDRESSES, SIZE_CONSTANTS, TIME_CONSTANTS } from "../utils/constants.js";
import { ProviderResolver } from "../utils/provider-resolver.js";
export const MOCK_ADDRESSES = {
    PAYMENTS: '0x80Df863d84eFaa0aaC8da2E9B08D14A7236ff4D0',
    PDP_VERIFIER: '0x3ce3C62C4D405d69738530A6A65E4b13E8700C48',
    SIGNER: '0x1234567890123456789012345678901234567890',
    SESSION_KEY: '0x5555555555555555555555555555555555555555',
    WARM_STORAGE: '0xEB022abbaa66D9F459F3EC2FeCF81a6D03c2Cb6F',
    WARM_STORAGE_VIEW: '0x1996B60838871D0bc7980Bc02DD6Eb920535bE54',
    SESSION_KEY_REGISTRY: '0x97Dd879F5a97A8c761B94746d7F5cfF50AAd4452',
};
export function createMockSigner(address = MOCK_ADDRESSES.SIGNER, provider) {
    const signer = {
        provider: provider ?? null,
        async getAddress() {
            return address;
        },
        async signTransaction() {
            return '0xsignedtransaction';
        },
        async signMessage() {
            return '0xsignedmessage';
        },
        async signTypedData() {
            const r = '11'.repeat(32);
            const s = '22'.repeat(32);
            const v = '1b';
            return `0x${r}${s}${v}`;
        },
        connect(newProvider) {
            return createMockSigner(address, newProvider);
        },
        async sendTransaction(transaction) {
            if (provider != null) {
                return provider.sendTransaction(transaction);
            }
            throw new Error('No provider for sendTransaction');
        },
    };
    return signer;
}
export function createMockProvider(chainId = 314159) {
    const network = new ethers.Network('calibration', chainId);
    const provider = {
        getNetwork: async () => network,
        getSigner: async function () {
            return createMockSigner(MOCK_ADDRESSES.SIGNER, this);
        },
        getBalance: async (_address) => ethers.parseEther('100'),
        getTransactionCount: async (_address, _blockTag) => 0,
        getBlock: async (_blockHashOrBlockTag) => {
            return {
                number: 1000000,
                timestamp: Math.floor(Date.now() / 1000),
                hash: `0x${Math.random().toString(16).substring(2).padEnd(64, '0')}`,
            };
        },
        call: async (transaction) => {
            const data = transaction.data;
            const to = transaction.to?.toLowerCase();
            if (data == null)
                return '0x';
            if (to === CONTRACT_ADDRESSES.MULTICALL3.calibration.toLowerCase() && data?.startsWith('0x82ad56cb')) {
                const multicallInterface = new ethers.Interface([
                    'function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) returns (tuple(bool success, bytes returnData)[])',
                ]);
                const decoded = multicallInterface.decodeFunctionData('aggregate3', data);
                const calls = decoded[0];
                const resultPromises = calls.map(async (call) => {
                    try {
                        const result = await provider.call({ to: call.target, data: call.callData });
                        return {
                            success: true,
                            returnData: result,
                        };
                    }
                    catch (error) {
                        if (call.allowFailure) {
                            return {
                                success: false,
                                returnData: '0x',
                            };
                        }
                        throw error;
                    }
                });
                return Promise.all(resultPromises).then((resolvedResults) => {
                    return ethers.AbiCoder.defaultAbiCoder().encode(['tuple(bool success, bytes returnData)[]'], [resolvedResults]);
                });
            }
            if (to === MOCK_ADDRESSES.WARM_STORAGE.toLowerCase()) {
                if (data?.startsWith('0xde4b6b71') === true) {
                    return ethers.AbiCoder.defaultAbiCoder().encode(['address'], [MOCK_ADDRESSES.PDP_VERIFIER]);
                }
                if (data?.startsWith('0xbc471469') === true) {
                    return ethers.AbiCoder.defaultAbiCoder().encode(['address'], [MOCK_ADDRESSES.PAYMENTS]);
                }
                if (data?.startsWith('0xd39b33ab') === true) {
                    return ethers.AbiCoder.defaultAbiCoder().encode(['address'], [CONTRACT_ADDRESSES.USDFC.calibration]);
                }
                if (data?.startsWith('0xce4f8d8b') === true) {
                    return ethers.AbiCoder.defaultAbiCoder().encode(['address'], ['0x0000000000000000000000000000000000000000']);
                }
                if (data?.startsWith('0x7a9ebc15') === true) {
                    return ethers.AbiCoder.defaultAbiCoder().encode(['address'], [MOCK_ADDRESSES.WARM_STORAGE_VIEW]);
                }
                if (data?.startsWith('0x05f892ec') === true) {
                    return ethers.AbiCoder.defaultAbiCoder().encode(['address'], ['0x0000000000000000000000000000000000000001']);
                }
                if (data?.startsWith('0x9f6aa572') === true) {
                    return ethers.AbiCoder.defaultAbiCoder().encode(['address'], [MOCK_ADDRESSES.SESSION_KEY_REGISTRY]);
                }
            }
            if (data?.startsWith('0x7bca0328') === true &&
                (to === '0x394feca6bcb84502d93c0c5c03c620ba8897e8f4' ||
                    to === '0xbfdc4454c2b573079c6c5ea1ddef6b8defc03dd5')) {
                const pricePerTiBPerMonth = ethers.parseUnits('2', 18);
                const tokenAddress = CONTRACT_ADDRESSES.USDFC.calibration;
                const epochsPerMonth = TIME_CONSTANTS.EPOCHS_PER_MONTH;
                return ethers.AbiCoder.defaultAbiCoder().encode(['uint256', 'address', 'uint256'], [pricePerTiBPerMonth, tokenAddress, epochsPerMonth]);
            }
            if (data.includes('70a08231') === true) {
                return ethers.zeroPadValue(ethers.toBeHex(ethers.parseUnits('1000', 18)), 32);
            }
            if (data.includes('313ce567') === true) {
                return ethers.zeroPadValue(ethers.toBeHex(18), 32);
            }
            if (data.startsWith('0x06fdde03') === true) {
                return ethers.AbiCoder.defaultAbiCoder().encode(['string'], ['USDFC']);
            }
            if (data.startsWith('0x7ecebe00') === true) {
                return ethers.zeroPadValue(ethers.toBeHex(0), 32);
            }
            if (data.startsWith('0x54fd4d50') === true) {
                return ethers.AbiCoder.defaultAbiCoder().encode(['string'], ['1']);
            }
            if (data.includes('dd62ed3e') === true) {
                return ethers.zeroPadValue(ethers.toBeHex(0), 32);
            }
            if (data.includes('095ea7b3') === true) {
                return ethers.zeroPadValue(ethers.toBeHex(1), 32);
            }
            if (data.includes('ad74b775') === true) {
                const paymentsInterface = new ethers.Interface(CONTRACT_ABIS.PAYMENTS);
                return paymentsInterface.encodeFunctionResult('accounts', [
                    ethers.parseUnits('500', 18),
                    0n,
                    0n,
                    1000000n,
                ]);
            }
            if (data.includes('5482bdf9') === true) {
                const pricePerTiBPerMonthNoCDN = ethers.parseUnits('2', 18);
                const pricePerTiBPerMonthWithCDN = ethers.parseUnits('3', 18);
                const tokenAddress = CONTRACT_ADDRESSES.USDFC.calibration;
                const epochsPerMonth = TIME_CONSTANTS.EPOCHS_PER_MONTH;
                return ethers.AbiCoder.defaultAbiCoder().encode(['tuple(uint256,uint256,address,uint256)'], [[pricePerTiBPerMonthNoCDN, pricePerTiBPerMonthWithCDN, tokenAddress, epochsPerMonth]]);
            }
            if (data.includes('89c6a46f') === true) {
                return ethers.AbiCoder.defaultAbiCoder().encode(['uint256[]'], [[1n, 2n]]);
            }
            if (data.includes('7a8fa2f1') === true) {
                return ethers.AbiCoder.defaultAbiCoder().encode(['uint256[]'], [[3n, 4n]]);
            }
            if (to === MOCK_ADDRESSES.PAYMENTS.toLowerCase() && data?.includes('9be5c024') === true) {
                return ethers.AbiCoder.defaultAbiCoder().encode(['uint256'], [ethers.parseEther('0.0013')]);
            }
            if (data.includes('22e440b3') === true) {
                const paymentsInterface = new ethers.Interface(CONTRACT_ABIS.PAYMENTS);
                const railData = {
                    token: CONTRACT_ADDRESSES.USDFC.calibration,
                    from: MOCK_ADDRESSES.SIGNER,
                    to: '0xaabbccddaabbccddaabbccddaabbccddaabbccdd',
                    operator: '0x394feCa6bCB84502d93c0c5C03c620ba8897e8f4',
                    validator: '0x394feCa6bCB84502d93c0c5C03c620ba8897e8f4',
                    paymentRate: ethers.parseUnits('1', 18),
                    lockupPeriod: 2880n,
                    lockupFixed: 0n,
                    settledUpTo: 1000000n,
                    endEpoch: 0n,
                    commissionRateBps: 500n,
                    serviceFeeRecipient: '0x394feCa6bCB84502d93c0c5C03c620ba8897e8f4',
                };
                return paymentsInterface.encodeFunctionResult('getRail', [railData]);
            }
            if (data.includes('e3d4c69e') === true) {
                const paymentsInterface = new ethers.Interface(CONTRACT_ABIS.PAYMENTS);
                return paymentsInterface.encodeFunctionResult('operatorApprovals', [
                    false,
                    0n,
                    0n,
                    0n,
                    0n,
                    TIME_CONSTANTS.EPOCHS_PER_MONTH,
                ]);
            }
            if (data.includes('9b85e253') === true) {
                const paymentsInterface = new ethers.Interface(CONTRACT_ABIS.PAYMENTS);
                const rails = [
                    { railId: 1n, isTerminated: false, endEpoch: 0n },
                    { railId: 2n, isTerminated: true, endEpoch: 999999n },
                ];
                return paymentsInterface.encodeFunctionResult('getRailsForPayerAndToken', [rails]);
            }
            if (data.includes('2ecfb2bf') === true) {
                const paymentsInterface = new ethers.Interface(CONTRACT_ABIS.PAYMENTS);
                const rails = [{ railId: 3n, isTerminated: false, endEpoch: 0n }];
                return paymentsInterface.encodeFunctionResult('getRailsForPayeeAndToken', [rails]);
            }
            if (data.includes('bcd40bf8') === true) {
                const paymentsInterface = new ethers.Interface(CONTRACT_ABIS.PAYMENTS);
                return paymentsInterface.encodeFunctionResult('settleRail', [
                    ethers.parseUnits('100', 18),
                    ethers.parseUnits('95', 18),
                    ethers.parseUnits('5', 18),
                    1000000n,
                    'Settlement successful',
                ]);
            }
            if (data.includes('4341325c') === true) {
                const paymentsInterface = new ethers.Interface(CONTRACT_ABIS.PAYMENTS);
                return paymentsInterface.encodeFunctionResult('settleTerminatedRailWithoutValidation', [
                    ethers.parseUnits('200', 18),
                    ethers.parseUnits('190', 18),
                    ethers.parseUnits('10', 18),
                    999999n,
                    'Terminated rail settlement',
                ]);
            }
            return '0x';
        },
        getBlockNumber: async () => 1000000,
        getCode: async (_address) => '0x1234',
        estimateGas: async (_transaction) => 21000n,
        getFeeData: async () => new ethers.FeeData(ethers.parseUnits('1', 'gwei'), ethers.parseUnits('1', 'gwei'), ethers.parseUnits('1', 'gwei')),
        getLogs: async (_filter) => [],
        resolveName: async (_name) => null,
        lookupAddress: async (_address) => null,
        broadcastTransaction: async (_signedTx) => {
            throw new Error('Not implemented in mock');
        },
        getTransaction: async (_hash) => {
            throw new Error('Not implemented in mock');
        },
        getTransactionReceipt: async (hash) => {
            return {
                hash,
                from: MOCK_ADDRESSES.SIGNER,
                to: null,
                contractAddress: null,
                index: 0,
                root: '',
                gasUsed: 50000n,
                gasPrice: 1000000000n,
                cumulativeGasUsed: 50000n,
                effectiveGasPrice: 1000000000n,
                logsBloom: '',
                blockHash: '',
                blockNumber: 1000000,
                logs: [],
                status: 1,
            };
        },
        waitForTransaction: async (_hash, _confirmations, _timeout) => {
            throw new Error('Not implemented in mock');
        },
        sendTransaction: async (transaction) => {
            const hash = `0x${Math.random().toString(16).substring(2).padEnd(64, '0')}`;
            return {
                hash,
                from: transaction.from ?? '',
                to: transaction.to ?? null,
                data: transaction.data ?? '',
                value: transaction.value != null ? BigInt(transaction.value) : 0n,
                chainId: 314159n,
                gasLimit: 100000n,
                gasPrice: 1000000000n,
                nonce: 0,
                wait: async () => ({
                    hash,
                    from: transaction.from ?? '',
                    to: transaction.to ?? null,
                    contractAddress: null,
                    index: 0,
                    root: '',
                    gasUsed: 50000n,
                    gasPrice: 1000000000n,
                    cumulativeGasUsed: 50000n,
                    effectiveGasPrice: 1000000000n,
                    logsBloom: '',
                    blockHash: '',
                    blockNumber: 1000000,
                    logs: [],
                    status: 1,
                }),
            };
        },
    };
    return provider;
}
export function extendMockProviderCall(provider, customMockFn) {
    const originalCall = provider.call;
    provider.call = async (transaction) => {
        const customResult = await customMockFn(transaction);
        if (customResult !== null) {
            return customResult;
        }
        if (originalCall && typeof originalCall === 'function') {
            return originalCall.call(provider, transaction);
        }
        return '0x';
    };
    return () => {
        provider.call = originalCall;
    };
}
export function createViewContractAddressMock(viewAddress = MOCK_ADDRESSES.WARM_STORAGE_VIEW) {
    return (data) => {
        if (data?.startsWith('0x7a9ebc15') === true) {
            return ethers.AbiCoder.defaultAbiCoder().encode(['address'], [viewAddress]);
        }
        return null;
    };
}
export function createCustomMulticall3Mock(provider, customAddresses) {
    return extendMockProviderCall(provider, async (transaction) => {
        const data = transaction.data;
        const to = transaction.to?.toLowerCase();
        if (to === CONTRACT_ADDRESSES.MULTICALL3.calibration.toLowerCase() && data?.startsWith('0x82ad56cb')) {
            const mockAddresses = [
                customAddresses?.pdpVerifier ?? MOCK_ADDRESSES.PDP_VERIFIER,
                customAddresses?.payments ?? MOCK_ADDRESSES.PAYMENTS,
                customAddresses?.usdfcToken ?? CONTRACT_ADDRESSES.USDFC.calibration,
                customAddresses?.filCDN ?? '0x0000000000000000000000000000000000000000',
                customAddresses?.viewContract ?? MOCK_ADDRESSES.WARM_STORAGE_VIEW,
                customAddresses?.spRegistry ?? '0x0000000000000000000000000000000000000001',
                customAddresses?.sessionKeyRegistry ?? MOCK_ADDRESSES.SESSION_KEY_REGISTRY,
            ];
            const results = mockAddresses.map((addr) => ({
                success: true,
                returnData: ethers.AbiCoder.defaultAbiCoder().encode(['address'], [addr]),
            }));
            return ethers.AbiCoder.defaultAbiCoder().encode(['tuple(bool success, bytes returnData)[]'], [results]);
        }
        return null;
    });
}
export function createMockSPRegistryService(providers = []) {
    const providerMap = new Map();
    const addressMap = new Map();
    providers.forEach((p) => {
        providerMap.set(p.id, p);
        addressMap.set(p.serviceProvider.toLowerCase(), p);
    });
    const mock = {
        getProvider: async (id) => providerMap.get(id) ?? null,
        getProviderByAddress: async (address) => addressMap.get(address.toLowerCase()) ?? null,
        getProviders: async (ids) => {
            return ids.map((id) => providerMap.get(id)).filter((p) => p != null);
        },
        getAllActiveProviders: async () => {
            return Array.from(providerMap.values()).filter((p) => p.active);
        },
        getProviderCount: async () => providerMap.size,
    };
    return mock;
}
export function createMockProviderResolver(approvedIds, providers = []) {
    const mockWarmStorage = {
        getApprovedProviderIds: async () => approvedIds,
        isProviderIdApproved: async (id) => approvedIds.includes(id),
    };
    const mockSPRegistry = createMockSPRegistryService(providers);
    return new ProviderResolver(mockWarmStorage, mockSPRegistry);
}
export function setupProviderRegistryMocks(provider, options = {}) {
    const { approvedIds = [1, 2], providers = [
        createMockProviderInfo({ id: 1 }),
        createMockProviderInfo({
            id: 2,
            serviceProvider: '0x2222222222222222222222222222222222222222',
            products: {
                PDP: {
                    type: 'PDP',
                    isActive: true,
                    capabilities: {},
                    data: {
                        serviceURL: 'https://pdp2.example.com',
                        minPieceSizeInBytes: BigInt(1024),
                        maxPieceSizeInBytes: BigInt(32) * BigInt(1024) * BigInt(1024) * BigInt(1024),
                        ipniPiece: false,
                        ipniIpfs: false,
                        storagePricePerTibPerMonth: BigInt(2000000),
                        minProvingPeriodInEpochs: 2880,
                        location: 'EU-WEST',
                        paymentTokenAddress: ethers.ZeroAddress,
                    },
                },
            },
        }),
    ], throwOnApproval = false, } = options;
    const originalCall = provider.call;
    provider.call = async (transaction) => {
        const data = transaction.data;
        const to = transaction.to?.toLowerCase();
        if (to === CONTRACT_ADDRESSES.MULTICALL3.calibration.toLowerCase() && data?.startsWith('0x82ad56cb')) {
            const defaultResult = await originalCall.call(provider, transaction);
            if (defaultResult && defaultResult !== '0x') {
                try {
                    const decoded = ethers.AbiCoder.defaultAbiCoder().decode(['tuple(bool success, bytes returnData)[]'], defaultResult);
                    if (decoded[0]?.length > 0) {
                        return defaultResult;
                    }
                }
                catch {
                }
            }
            const iface = new ethers.Interface(CONTRACT_ABIS.MULTICALL3);
            const decoded = iface.decodeFunctionData('aggregate3', data);
            const calls = decoded[0];
            const results = calls.map((call) => {
                const callData = call.callData;
                const target = call.target?.toLowerCase();
                if (target === CONTRACT_ADDRESSES.WARM_STORAGE.calibration.toLowerCase() ||
                    target === '0xe6cd6d7becd21fbf72452cf8371e505b02134669') {
                    if (callData.startsWith('0xe5c9821e')) {
                        return {
                            success: true,
                            returnData: ethers.AbiCoder.defaultAbiCoder().encode(['address'], [MOCK_ADDRESSES.PDP_VERIFIER]),
                        };
                    }
                    if (callData.startsWith('0x8b893d6f')) {
                        return {
                            success: true,
                            returnData: ethers.AbiCoder.defaultAbiCoder().encode(['address'], [MOCK_ADDRESSES.PAYMENTS]),
                        };
                    }
                    if (callData.startsWith('0x8e2bc1ea')) {
                        return {
                            success: true,
                            returnData: ethers.AbiCoder.defaultAbiCoder().encode(['address'], [CONTRACT_ADDRESSES.USDFC.calibration]),
                        };
                    }
                    if (callData.startsWith('0xf699dd7e')) {
                        return {
                            success: true,
                            returnData: ethers.AbiCoder.defaultAbiCoder().encode(['address'], [ethers.ZeroAddress]),
                        };
                    }
                    if (callData.startsWith('0x7a9ebc15')) {
                        return {
                            success: true,
                            returnData: ethers.AbiCoder.defaultAbiCoder().encode(['address'], [MOCK_ADDRESSES.WARM_STORAGE_VIEW]),
                        };
                    }
                    if (callData.startsWith('0xab2b3ae5')) {
                        return {
                            success: true,
                            returnData: ethers.AbiCoder.defaultAbiCoder().encode(['address'], ['0x0000000000000000000000000000000000000001']),
                        };
                    }
                }
                if (target === MOCK_ADDRESSES.WARM_STORAGE_VIEW.toLowerCase()) {
                    if (callData.startsWith('0x266afe1b')) {
                        return {
                            success: true,
                            returnData: ethers.AbiCoder.defaultAbiCoder().encode(['uint256[]'], [approvedIds.map(BigInt)]),
                        };
                    }
                }
                if (callData.startsWith('0x5c42d079') && target === '0x0000000000000000000000000000000000000001') {
                    const providerId = parseInt(callData.slice(10, 74), 16);
                    const provider = providers.find((p) => p.id === providerId);
                    if (provider) {
                        const encoded = ethers.AbiCoder.defaultAbiCoder().encode(['tuple(address serviceProvider, address payee, string name, string description, bool isActive)'], [[provider.serviceProvider, provider.payee, provider.name, provider.description || '', provider.active]]);
                        return { success: true, returnData: encoded };
                    }
                    const encoded = ethers.AbiCoder.defaultAbiCoder().encode(['tuple(address serviceProvider, address payee, string name, string description, bool isActive)'], [[ethers.ZeroAddress, ethers.ZeroAddress, '', '', false]]);
                    return { success: true, returnData: encoded };
                }
                if (callData.startsWith('0xc439fd57') && target === '0x0000000000000000000000000000000000000001') {
                    const providerId = parseInt(callData.slice(10, 74), 16);
                    const provider = providers.find((p) => p.id === providerId);
                    if (provider?.products?.PDP) {
                        const pdp = provider.products.PDP;
                        const encoded = ethers.AbiCoder.defaultAbiCoder().encode([
                            'tuple(tuple(string serviceURL, uint256 minPieceSizeInBytes, uint256 maxPieceSizeInBytes, bool ipniPiece, bool ipniIpfs, uint256 storagePricePerTibPerMonth, uint256 minProvingPeriodInEpochs, string location, address paymentTokenAddress) pdpOffering, string[] capabilityKeys, bool isActive)',
                        ], [
                            [
                                [
                                    pdp.data.serviceURL,
                                    pdp.data.minPieceSizeInBytes,
                                    pdp.data.maxPieceSizeInBytes,
                                    pdp.data.ipniPiece,
                                    pdp.data.ipniIpfs,
                                    pdp.data.storagePricePerTibPerMonth,
                                    pdp.data.minProvingPeriodInEpochs,
                                    pdp.data.location || '',
                                    pdp.data.paymentTokenAddress,
                                ],
                                Object.keys(pdp.capabilities || []),
                                pdp.isActive,
                            ],
                        ]);
                        return { success: true, returnData: encoded };
                    }
                    const encoded = ethers.AbiCoder.defaultAbiCoder().encode([
                        'tuple(tuple(string serviceURL, uint256 minPieceSizeInBytes, uint256 maxPieceSizeInBytes, bool ipniPiece, bool ipniIpfs, uint256 storagePricePerTibPerMonth, uint256 minProvingPeriodInEpochs, string location, address paymentTokenAddress) pdpOffering, string[] capabilityKeys, bool isActive)',
                    ], [[['', BigInt(0), BigInt(0), false, false, BigInt(0), BigInt(0), '', ethers.ZeroAddress], [], false]]);
                    return { success: true, returnData: encoded };
                }
                return { success: false, returnData: '0x' };
            });
            return ethers.AbiCoder.defaultAbiCoder().encode(['tuple(bool success, bytes returnData)[]'], [results]);
        }
        if (data?.startsWith('0x266afe1b')) {
            return ethers.AbiCoder.defaultAbiCoder().encode(['uint256[]'], [approvedIds.map(BigInt)]);
        }
        if (data?.startsWith('0x5c42d079')) {
            const providerId = parseInt(data.slice(10, 74), 16);
            const provider = providers.find((p) => p.id === providerId);
            if (provider) {
                return ethers.AbiCoder.defaultAbiCoder().encode(['tuple(address serviceProvider, address payee, string name, string description, bool isActive)'], [[provider.serviceProvider, provider.payee, provider.name, provider.description || '', provider.active]]);
            }
            return ethers.AbiCoder.defaultAbiCoder().encode(['tuple(address serviceProvider, address payee, string name, string description, bool isActive)'], [[ethers.ZeroAddress, ethers.ZeroAddress, '', '', false]]);
        }
        if (data?.startsWith('0xc439fd57')) {
            const providerId = parseInt(data.slice(10, 74), 16);
            const provider = providers.find((p) => p.id === providerId);
            if (provider?.products?.PDP) {
                const pdp = provider.products.PDP;
                const pdpOffering = {
                    serviceURL: pdp.data.serviceURL,
                    minPieceSizeInBytes: pdp.data.minPieceSizeInBytes,
                    maxPieceSizeInBytes: pdp.data.maxPieceSizeInBytes,
                    ipniPiece: pdp.data.ipniPiece,
                    ipniIpfs: pdp.data.ipniIpfs,
                    storagePricePerTibPerMonth: pdp.data.storagePricePerTibPerMonth,
                    minProvingPeriodInEpochs: pdp.data.minProvingPeriodInEpochs,
                    location: pdp.data.location || '',
                    paymentTokenAddress: pdp.data.paymentTokenAddress,
                };
                return ethers.AbiCoder.defaultAbiCoder().encode([
                    'tuple(string serviceURL, uint256 minPieceSizeInBytes, uint256 maxPieceSizeInBytes, bool ipniPiece, bool ipniIpfs, uint256 storagePricePerTibPerMonth, uint256 minProvingPeriodInEpochs, string location, address paymentTokenAddress)',
                    'string[]',
                    'bool',
                ], [pdpOffering, Object.keys(pdp.capabilities ?? []), pdp.isActive]);
            }
            const emptyPdpOffering = {
                serviceURL: '',
                minPieceSizeInBytes: BigInt(0),
                maxPieceSizeInBytes: BigInt(0),
                ipniPiece: false,
                ipniIpfs: false,
                storagePricePerTibPerMonth: BigInt(0),
                minProvingPeriodInEpochs: BigInt(0),
                location: '',
                paymentTokenAddress: ethers.ZeroAddress,
            };
            return ethers.AbiCoder.defaultAbiCoder().encode([
                'tuple(string serviceURL, uint256 minPieceSizeInBytes, uint256 maxPieceSizeInBytes, bool ipniPiece, bool ipniIpfs, uint256 storagePricePerTibPerMonth, uint256 minProvingPeriodInEpochs, string location, address paymentTokenAddress)',
                'string[]',
                'bool',
            ], [emptyPdpOffering, [], false]);
        }
        if (data?.startsWith('0xb5eb46e1')) {
            const providerId = parseInt(data.slice(10, 74), 16);
            const provider = providers.find((p) => p.id === providerId);
            if (provider?.products?.PDP) {
                const pdp = provider.products.PDP;
                const encodedPDP = ethers.AbiCoder.defaultAbiCoder().encode(['string', 'uint256', 'uint256', 'bool', 'bool', 'uint256', 'uint256', 'string', 'address'], [
                    pdp.data.serviceURL,
                    pdp.data.minPieceSizeInBytes,
                    pdp.data.maxPieceSizeInBytes,
                    pdp.data.ipniPiece,
                    pdp.data.ipniIpfs,
                    pdp.data.storagePricePerTibPerMonth,
                    pdp.data.minProvingPeriodInEpochs,
                    pdp.data.location || '',
                    pdp.data.paymentTokenAddress,
                ]);
                return ethers.AbiCoder.defaultAbiCoder().encode(['tuple(uint8,bool,bytes32[],bytes)[]'], [
                    [
                        [
                            0,
                            pdp.isActive,
                            pdp.capabilities ?? [],
                            encodedPDP,
                        ],
                    ],
                ]);
            }
            return ethers.AbiCoder.defaultAbiCoder().encode(['tuple(uint8,bool,bytes32[],bytes)[]'], [[]]);
        }
        if (data?.startsWith('0xdeb0e462')) {
            const provider = providers[0];
            if (provider?.products?.PDP) {
                const pdp = provider.products.PDP;
                return ethers.AbiCoder.defaultAbiCoder().encode(['tuple(string,uint256,uint256,bool,bool,uint256,uint256,string,address)'], [
                    [
                        pdp.data.serviceURL,
                        pdp.data.minPieceSizeInBytes,
                        pdp.data.maxPieceSizeInBytes,
                        pdp.data.ipniPiece,
                        pdp.data.ipniIpfs,
                        pdp.data.storagePricePerTibPerMonth,
                        pdp.data.minProvingPeriodInEpochs,
                        pdp.data.location || '',
                        pdp.data.paymentTokenAddress,
                    ],
                ]);
            }
        }
        if (data?.startsWith('0x93ecb91e')) {
            const addressParam = `0x${data.slice(34, 74)}`;
            const provider = providers.find((p) => p.serviceProvider.toLowerCase() === addressParam.toLowerCase());
            if (provider) {
                return ethers.zeroPadValue(ethers.toBeHex(provider.id), 32);
            }
            return ethers.zeroPadValue('0x00', 32);
        }
        if (data?.startsWith('0x2335bde0')) {
            const addressParam = `0x${data.slice(34, 74)}`;
            const provider = providers.find((p) => p.serviceProvider.toLowerCase() === addressParam.toLowerCase());
            if (provider) {
                return ethers.AbiCoder.defaultAbiCoder().encode(['tuple(address serviceProvider, address payee, string name, string description, bool isActive)'], [[provider.serviceProvider, provider.payee, provider.name, provider.description || '', provider.active]]);
            }
            return ethers.AbiCoder.defaultAbiCoder().encode(['tuple(address serviceProvider, address payee, string name, string description, bool isActive)'], [[ethers.ZeroAddress, ethers.ZeroAddress, '', '', false]]);
        }
        if (data?.startsWith('0xb6133b7a')) {
            const providerId = parseInt(data.slice(10, 74), 16);
            const isApproved = approvedIds.includes(providerId);
            return ethers.AbiCoder.defaultAbiCoder().encode(['bool'], [isApproved]);
        }
        if (data?.startsWith('0xe3d4c69e')) {
            if (throwOnApproval) {
                throw new Error('No wallet connected');
            }
            return ethers.AbiCoder.defaultAbiCoder().encode(['bool', 'uint256', 'uint256', 'uint256', 'uint256', 'uint256'], [
                true,
                BigInt(1000000),
                BigInt(10000000),
                BigInt(500000),
                BigInt(5000000),
                BigInt(86400),
            ]);
        }
        return originalCall.call(provider, transaction);
    };
    return () => {
        provider.call = originalCall;
    };
}
export function createMockProviderInfo(overrides) {
    const defaults = {
        id: 1,
        serviceProvider: MOCK_ADDRESSES.SIGNER,
        payee: MOCK_ADDRESSES.SIGNER,
        name: 'Test Provider',
        description: 'A test storage provider',
        active: true,
        products: {
            PDP: {
                type: 'PDP',
                isActive: true,
                capabilities: {},
                data: {
                    serviceURL: 'https://provider.example.com',
                    minPieceSizeInBytes: SIZE_CONSTANTS.KiB,
                    maxPieceSizeInBytes: SIZE_CONSTANTS.GiB,
                    ipniPiece: false,
                    ipniIpfs: false,
                    storagePricePerTibPerMonth: BigInt(1000000),
                    minProvingPeriodInEpochs: 2880,
                    location: 'US',
                    paymentTokenAddress: '0x0000000000000000000000000000000000000000',
                },
            },
        },
    };
    return { ...defaults, ...overrides };
}
export function createSimpleProvider(props) {
    return createMockProviderInfo({
        serviceProvider: props.serviceProvider ?? props.address ?? MOCK_ADDRESSES.SIGNER,
        products: {
            PDP: {
                type: 'PDP',
                isActive: true,
                capabilities: {},
                data: {
                    serviceURL: props.serviceURL,
                    minPieceSizeInBytes: SIZE_CONSTANTS.KiB,
                    maxPieceSizeInBytes: SIZE_CONSTANTS.GiB,
                    ipniPiece: false,
                    ipniIpfs: false,
                    storagePricePerTibPerMonth: BigInt(1000000),
                    minProvingPeriodInEpochs: 2880,
                    location: 'US',
                    paymentTokenAddress: '0x0000000000000000000000000000000000000000',
                },
            },
        },
    });
}
//# sourceMappingURL=test-utils.js.map