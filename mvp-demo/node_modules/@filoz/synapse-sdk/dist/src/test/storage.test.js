import { assert } from 'chai';
import { ethers } from 'ethers';
import { StorageContext } from "../storage/context.js";
import { SIZE_CONSTANTS } from "../utils/constants.js";
import { createMockProviderInfo, createSimpleProvider, setupProviderRegistryMocks } from "./test-utils.js";
const mockEthProvider = {
    getTransaction: async (_hash) => null,
    getNetwork: async () => ({ chainId: BigInt(314159), name: 'calibration' }),
    call: async (_tx) => {
        return '0x';
    },
};
const mockSynapse = {
    getSigner: () => new ethers.Wallet(ethers.hexlify(ethers.randomBytes(32))),
    getClient: () => new ethers.Wallet(ethers.hexlify(ethers.randomBytes(32))),
    getProvider: () => mockEthProvider,
    getWarmStorageAddress: () => '0x1234567890123456789012345678901234567890',
    getChainId: () => BigInt(314159),
    payments: {
        serviceApproval: async () => ({
            service: '0x1234567890123456789012345678901234567890',
            rateAllowance: BigInt(1000000),
            lockupAllowance: BigInt(10000000),
            rateUsed: BigInt(0),
            lockupUsed: BigInt(0),
        }),
    },
    download: async (_pieceCid, _options) => {
        return new Uint8Array(127).fill(42);
    },
    getProviderInfo: async (_providerAddress) => {
        throw new Error('getProviderInfo not mocked');
    },
};
const TEST_PROVIDERS = {
    provider1: createMockProviderInfo({
        id: 1,
        serviceProvider: '0x1111111111111111111111111111111111111111',
        name: 'Test Provider 1',
        products: {
            PDP: {
                type: 'PDP',
                isActive: true,
                capabilities: { dev: '' },
                data: {
                    serviceURL: 'https://provider.example.com',
                    minPieceSizeInBytes: SIZE_CONSTANTS.KiB,
                    maxPieceSizeInBytes: SIZE_CONSTANTS.GiB,
                    ipniPiece: false,
                    ipniIpfs: false,
                    storagePricePerTibPerMonth: BigInt(1000000),
                    minProvingPeriodInEpochs: 2880,
                    location: 'US',
                    paymentTokenAddress: '0x0000000000000000000000000000000000000000',
                },
            },
        },
    }),
    provider2: createMockProviderInfo({
        id: 2,
        serviceProvider: '0x2222222222222222222222222222222222222222',
        name: 'Test Provider 2',
        products: {
            PDP: {
                type: 'PDP',
                isActive: true,
                capabilities: {},
                data: {
                    serviceURL: 'https://provider.example.com',
                    minPieceSizeInBytes: SIZE_CONSTANTS.KiB,
                    maxPieceSizeInBytes: SIZE_CONSTANTS.GiB,
                    ipniPiece: true,
                    ipniIpfs: true,
                    storagePricePerTibPerMonth: BigInt(1000000),
                    minProvingPeriodInEpochs: 2880,
                    location: 'US',
                    paymentTokenAddress: '0x0000000000000000000000000000000000000000',
                },
            },
        },
    }),
    provider3: createMockProviderInfo({
        id: 3,
        serviceProvider: '0x3333333333333333333333333333333333333333',
        name: 'Test Provider 3',
    }),
    provider4: createMockProviderInfo({
        id: 4,
        serviceProvider: '0x4444444444444444444444444444444444444444',
        name: 'Test Provider 4',
    }),
    provider5: createMockProviderInfo({
        id: 5,
        serviceProvider: '0x5555555555555555555555555555555555555555',
        name: 'Test Provider 5',
    }),
    provider7: createMockProviderInfo({
        id: 7,
        serviceProvider: '0x7777777777777777777777777777777777777777',
        name: 'Test Provider 7',
    }),
    provider9: createMockProviderInfo({
        id: 9,
        serviceProvider: '0x9999999999999999999999999999999999999999',
        name: 'Test Provider 9',
    }),
};
const mockProvider = createSimpleProvider({
    serviceProvider: '0xabcdef1234567890123456789012345678901234',
    serviceURL: 'https://pdp.example.com',
});
function createMockWarmStorageService(providers, dataSets = [], overrides = {}) {
    return {
        getAllApprovedProviders: async () => providers,
        getClientDataSetsWithDetails: async () => dataSets,
        getNextClientDataSetId: async () => dataSets.length > 0 ? Math.max(...dataSets.map((d) => d.clientDataSetId)) + 1 : 1,
        getProviderIdByAddress: async (address) => {
            const provider = providers.find((p) => p.serviceProvider.toLowerCase() === address.toLowerCase());
            return provider?.id ?? 0;
        },
        getApprovedProvider: async (id) => providers.find((p) => p.id === id) ?? null,
        getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
        getApprovedProviderIds: async () => providers.map((p) => p.id),
        isProviderIdApproved: async (id) => providers.some((p) => p.id === id),
        getDataSetMetadata: async (dataSetId) => {
            const dataSet = dataSets.find((d) => d.pdpVerifierDataSetId === dataSetId);
            return dataSet?.metadata ?? {};
        },
        ...overrides,
    };
}
function mockAddPieces(serviceAny, options = {}) {
    const txHash = options.txHash || `0x${'0'.repeat(64)}`;
    serviceAny._pdpServer.addPieces = async (dataSetId, clientDataSetId, nextPieceId, pieceCids) => {
        if (options.shouldFail) {
            throw new Error(options.failureMessage || 'Network error during addPieces');
        }
        if (options.onCall) {
            await options.onCall(dataSetId, clientDataSetId, nextPieceId, pieceCids);
        }
        const pieceIds = Array.from({ length: pieceCids.length }, (_, i) => nextPieceId + i);
        serviceAny._pdpServer._lastPieceIds = pieceIds;
        if (options.addDelay) {
            await new Promise((resolve) => setTimeout(resolve, options.addDelay));
        }
        return {
            message: 'success',
            txHash,
            ...(options.txHash && {
                statusUrl: `https://pdp.example.com/pdp/data-sets/123/pieces/added/${txHash}`,
            }),
        };
    };
    return txHash;
}
function mockGetPieceAdditionStatus(serviceAny, options = {}) {
    serviceAny._pdpServer.getPieceAdditionStatus = async (dataSetId, txHash) => {
        if (options.shouldFail) {
            throw new Error(options.failureMessage || 'Piece addition status not found');
        }
        if (options.onCall) {
            options.onCall(dataSetId, txHash);
        }
        if (options.customResponse) {
            return options.customResponse;
        }
        const pieceIds = serviceAny._pdpServer._lastPieceIds || [];
        return {
            txStatus: 'confirmed',
            addMessageOk: true,
            confirmedPieceIds: pieceIds,
        };
    };
}
describe('StorageService', () => {
    describe('create() factory method', () => {
        let cleanupMocks = null;
        let originalFetch;
        beforeEach(() => {
            originalFetch = global.fetch;
            global.fetch = async (input) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                if (url.includes('/ping')) {
                    return { status: 200, statusText: 'OK' };
                }
                throw new Error(`Unexpected URL: ${url}`);
            };
        });
        afterEach(() => {
            global.fetch = originalFetch;
            if (cleanupMocks) {
                cleanupMocks();
                cleanupMocks = null;
            }
        });
        it('should select a random provider when no providerId specified', async () => {
            const mockProviders = [TEST_PROVIDERS.provider1, TEST_PROVIDERS.provider2];
            const dataSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProviders[0].serviceProvider,
                    providerId: 1,
                    pdpVerifierDataSetId: 100,
                    nextPieceId: 0,
                    currentPieceCount: 0,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 1,
                },
                {
                    railId: 2,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProviders[1].serviceProvider,
                    providerId: 2,
                    pdpVerifierDataSetId: 101,
                    nextPieceId: 0,
                    currentPieceCount: 0,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 2,
                },
            ];
            cleanupMocks = setupProviderRegistryMocks(mockEthProvider, {
                providers: mockProviders,
                approvedIds: [1, 2],
            });
            const mockWarmStorageService = createMockWarmStorageService(mockProviders, dataSets);
            const service = await StorageContext.create(mockSynapse, mockWarmStorageService);
            assert.isTrue(service.serviceProvider === mockProviders[0].serviceProvider ||
                service.serviceProvider === mockProviders[1].serviceProvider);
        });
        it('should select a random provider but filter allow IPNI providers', async () => {
            const mockProviders = [TEST_PROVIDERS.provider1, TEST_PROVIDERS.provider2];
            const dataSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProviders[0].serviceProvider,
                    providerId: 1,
                    pdpVerifierDataSetId: 100,
                    nextPieceId: 0,
                    currentPieceCount: 0,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 1,
                },
                {
                    railId: 2,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProviders[1].serviceProvider,
                    providerId: 2,
                    pdpVerifierDataSetId: 101,
                    nextPieceId: 0,
                    currentPieceCount: 0,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 2,
                },
            ];
            cleanupMocks = setupProviderRegistryMocks(mockEthProvider, {
                providers: mockProviders,
                approvedIds: [1, 2],
            });
            const mockWarmStorageService = createMockWarmStorageService(mockProviders, dataSets);
            const service = await StorageContext.create(mockSynapse, mockWarmStorageService, {
                withIpni: true,
            });
            assert.isTrue(service.serviceProvider === mockProviders[1].serviceProvider);
        });
        it('should never select a dev provider by default', async () => {
            const mockProviders = [TEST_PROVIDERS.provider1, TEST_PROVIDERS.provider2];
            const dataSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProviders[0].serviceProvider,
                    providerId: 1,
                    pdpVerifierDataSetId: 100,
                    nextPieceId: 0,
                    currentPieceCount: 0,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 1,
                },
                {
                    railId: 2,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProviders[1].serviceProvider,
                    providerId: 2,
                    pdpVerifierDataSetId: 101,
                    nextPieceId: 0,
                    currentPieceCount: 0,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 2,
                },
            ];
            cleanupMocks = setupProviderRegistryMocks(mockEthProvider, {
                providers: mockProviders,
                approvedIds: [1, 2],
            });
            const mockWarmStorageService = createMockWarmStorageService(mockProviders, dataSets);
            const service = await StorageContext.create(mockSynapse, mockWarmStorageService);
            assert.isTrue(service.serviceProvider === mockProviders[1].serviceProvider);
        });
        it('should use specific provider when providerId specified', async () => {
            const mockProvider = TEST_PROVIDERS.provider3;
            const dataSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: '0x3333333333333333333333333333333333333333',
                    providerId: 3,
                    pdpVerifierDataSetId: 100,
                    nextPieceId: 0,
                    currentPieceCount: 0,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 1,
                },
            ];
            cleanupMocks = setupProviderRegistryMocks(mockEthProvider, {
                providers: [mockProvider],
                approvedIds: [3],
            });
            const mockWarmStorageService = createMockWarmStorageService([mockProvider], dataSets, {
                getApprovedProvider: async (id) => {
                    assert.equal(id, 3);
                    return mockProvider;
                },
            });
            const service = await StorageContext.create(mockSynapse, mockWarmStorageService, {
                providerId: 3,
            });
            assert.equal(service.serviceProvider, mockProvider.serviceProvider);
        });
        it('should skip existing datasets and return -1 with providerId when forceCreateDataSet is true', async () => {
            const mockProvider = TEST_PROVIDERS.provider3;
            const dataSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProvider.serviceProvider,
                    providerId: 3,
                    pdpVerifierDataSetId: 100,
                    nextPieceId: 0,
                    currentPieceCount: 5,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 1,
                },
            ];
            cleanupMocks = setupProviderRegistryMocks(mockEthProvider, {
                providers: [mockProvider],
                approvedIds: [3],
            });
            const mockWarmStorageService = createMockWarmStorageService([mockProvider], dataSets, {
                getApprovedProvider: async (id) => {
                    assert.equal(id, 3);
                    return mockProvider;
                },
            });
            let fetchedDataSets = false;
            const originalGetClientDataSets = mockWarmStorageService.getClientDataSetsWithDetails;
            mockWarmStorageService.getClientDataSetsWithDetails = async (address) => {
                fetchedDataSets = true;
                return await originalGetClientDataSets(address);
            };
            const resolution = await StorageContext.resolveProviderAndDataSet(mockSynapse, mockWarmStorageService, {
                getApprovedProvider: async () => mockProvider,
                getApprovedProviders: async () => [mockProvider],
                getApprovedProviderByAddress: async () => mockProvider,
            }, { providerId: 3, forceCreateDataSet: true });
            assert.equal(resolution.dataSetId, -1, 'Should return -1 to signal new data set creation');
            assert.equal(resolution.provider.id, 3, 'Should select the requested provider');
            assert.isFalse(fetchedDataSets, 'Should not have fetched existing data sets when forceCreateDataSet is true');
        });
        it('should skip existing datasets and return -1 with providerAddress when forceCreateDataSet is true', async () => {
            const mockProvider = TEST_PROVIDERS.provider3;
            const dataSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProvider.serviceProvider,
                    providerId: 3,
                    pdpVerifierDataSetId: 100,
                    nextPieceId: 0,
                    currentPieceCount: 5,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 1,
                },
            ];
            cleanupMocks = setupProviderRegistryMocks(mockEthProvider, {
                providers: [mockProvider],
                approvedIds: [3],
            });
            const mockWarmStorageService = createMockWarmStorageService([mockProvider], dataSets, {
                getApprovedProviderByAddress: async (address) => {
                    assert.equal(address.toLowerCase(), mockProvider.serviceProvider.toLowerCase());
                    return mockProvider;
                },
                getApprovedProvider: async (id) => {
                    assert.equal(id, 3);
                    return mockProvider;
                },
            });
            let fetchedDataSets = false;
            const originalGetClientDataSets = mockWarmStorageService.getClientDataSetsWithDetails;
            mockWarmStorageService.getClientDataSetsWithDetails = async (address) => {
                fetchedDataSets = true;
                return await originalGetClientDataSets(address);
            };
            const resolution = await StorageContext.resolveProviderAndDataSet(mockSynapse, mockWarmStorageService, {
                getApprovedProvider: async () => mockProvider,
                getApprovedProviders: async () => [mockProvider],
                getApprovedProviderByAddress: async () => mockProvider,
            }, { providerAddress: mockProvider.serviceProvider, forceCreateDataSet: true });
            assert.equal(resolution.dataSetId, -1, 'Should return -1 to signal new data set creation');
            assert.equal(resolution.provider.serviceProvider.toLowerCase(), mockProvider.serviceProvider.toLowerCase(), 'Should select the requested provider');
            assert.isFalse(fetchedDataSets, 'Should not have fetched existing data sets when forceCreateDataSet is true');
        });
        it('should reuse existing data set with providerId when forceCreateDataSet is not set', async () => {
            const mockProvider = TEST_PROVIDERS.provider3;
            const dataSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProvider.serviceProvider,
                    providerId: 3,
                    pdpVerifierDataSetId: 100,
                    nextPieceId: 0,
                    currentPieceCount: 5,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 1,
                },
            ];
            cleanupMocks = setupProviderRegistryMocks(mockEthProvider, {
                providers: [mockProvider],
                approvedIds: [3],
            });
            const mockWarmStorageService = createMockWarmStorageService([mockProvider], dataSets, {
                getApprovedProvider: async (id) => {
                    assert.equal(id, 3);
                    return mockProvider;
                },
            });
            let createdDataSet = false;
            mockWarmStorageService.getNextClientDataSetId = async () => {
                createdDataSet = true;
                return 2;
            };
            const service = await StorageContext.create(mockSynapse, mockWarmStorageService, {
                providerId: 3,
            });
            assert.equal(service.serviceProvider, mockProvider.serviceProvider);
            assert.equal(service.dataSetId, 100, 'Should reuse existing data set ID');
            assert.isFalse(createdDataSet, 'Should not have created a new data set');
        });
        it('should throw when no approved providers available', async () => {
            cleanupMocks = setupProviderRegistryMocks(mockEthProvider, {
                providers: [],
                approvedIds: [],
            });
            const mockWarmStorageService = createMockWarmStorageService([], []);
            try {
                await StorageContext.create(mockSynapse, mockWarmStorageService, {});
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'No approved service providers available');
            }
        });
        it('should throw when specified provider not found', async () => {
            const mockProviders = [TEST_PROVIDERS.provider1, TEST_PROVIDERS.provider2];
            cleanupMocks = setupProviderRegistryMocks(mockEthProvider, {
                providers: mockProviders,
                approvedIds: [1, 2],
            });
            const mockWarmStorageService = createMockWarmStorageService(mockProviders, [], {
                getApprovedProvider: async () => ({
                    serviceProvider: '0x0000000000000000000000000000000000000000',
                    serviceURL: '',
                }),
            });
            try {
                await StorageContext.create(mockSynapse, mockWarmStorageService, {
                    providerId: 999,
                });
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'Provider ID 999 is not currently approved');
            }
        });
        it('should select existing data set when available', async () => {
            const mockProvider = TEST_PROVIDERS.provider3;
            const mockDataSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: '0x3333333333333333333333333333333333333333',
                    providerId: 3,
                    pdpVerifierDataSetId: 100,
                    nextPieceId: 5,
                    currentPieceCount: 5,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 1,
                },
            ];
            cleanupMocks = setupProviderRegistryMocks(mockEthProvider, {
                providers: [mockProvider],
                approvedIds: [3],
            });
            const mockWarmStorageService = createMockWarmStorageService([mockProvider], mockDataSets, {
                getApprovedProvider: async () => mockProvider,
            });
            const service = await StorageContext.create(mockSynapse, mockWarmStorageService, {
                providerId: 3,
            });
            assert.equal(service.dataSetId, 100);
        });
        it.skip('should create new data set when none exist', async () => {
        });
        it('should prefer data sets with existing pieces', async () => {
            const mockProvider = TEST_PROVIDERS.provider3;
            const mockDataSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: '0x3333333333333333333333333333333333333333',
                    providerId: 3,
                    pdpVerifierDataSetId: 100,
                    nextPieceId: 0,
                    currentPieceCount: 0,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 1,
                },
                {
                    railId: 2,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: '0x3333333333333333333333333333333333333333',
                    providerId: 3,
                    pdpVerifierDataSetId: 101,
                    nextPieceId: 5,
                    currentPieceCount: 5,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 2,
                },
            ];
            cleanupMocks = setupProviderRegistryMocks(mockEthProvider, {
                providers: [mockProvider],
                approvedIds: [3],
            });
            const mockWarmStorageService = createMockWarmStorageService([mockProvider], mockDataSets, {
                getApprovedProvider: async () => mockProvider,
            });
            const service = await StorageContext.create(mockSynapse, mockWarmStorageService, {
                providerId: 3,
            });
            assert.equal(service.dataSetId, 101);
        });
        it('should handle provider selection callbacks', async () => {
            const mockProvider = TEST_PROVIDERS.provider3;
            let providerCallbackFired = false;
            let dataSetCallbackFired = false;
            const dataSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProvider.serviceProvider,
                    providerId: 3,
                    pdpVerifierDataSetId: 100,
                    nextPieceId: 0,
                    currentPieceCount: 0,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 1,
                },
            ];
            cleanupMocks = setupProviderRegistryMocks(mockEthProvider, {
                providers: [mockProvider],
                approvedIds: [3],
            });
            const mockWarmStorageService = createMockWarmStorageService([mockProvider], dataSets, {
                getApprovedProvider: async () => mockProvider,
            });
            await StorageContext.create(mockSynapse, mockWarmStorageService, {
                providerId: 3,
                callbacks: {
                    onProviderSelected: (provider) => {
                        assert.equal(provider.serviceProvider, mockProvider.serviceProvider);
                        providerCallbackFired = true;
                    },
                    onDataSetResolved: (info) => {
                        assert.isTrue(info.isExisting);
                        assert.equal(info.dataSetId, 100);
                        dataSetCallbackFired = true;
                    },
                },
            });
            assert.isTrue(providerCallbackFired, 'onProviderSelected should have been called');
            assert.isTrue(dataSetCallbackFired, 'onDataSetResolved should have been called');
        });
        it('should select by explicit dataSetId', async () => {
            const mockProvider = TEST_PROVIDERS.provider3;
            const mockDataSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProvider.serviceProvider,
                    providerId: 3,
                    pdpVerifierDataSetId: 456,
                    nextPieceId: 10,
                    currentPieceCount: 10,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 1,
                },
            ];
            cleanupMocks = setupProviderRegistryMocks(mockEthProvider, {
                providers: [mockProvider],
                approvedIds: [3],
            });
            const mockWarmStorageService = createMockWarmStorageService([mockProvider], mockDataSets, {
                getProviderIdByAddress: async (addr) => {
                    assert.equal(addr, mockProvider.serviceProvider);
                    return 3;
                },
                getApprovedProvider: async (id) => {
                    assert.equal(id, 3);
                    return mockProvider;
                },
            });
            const service = await StorageContext.create(mockSynapse, mockWarmStorageService, {
                dataSetId: 456,
            });
            assert.equal(service.dataSetId, 456);
            assert.equal(service.serviceProvider, mockProvider.serviceProvider);
        });
        it('should select by providerAddress', async () => {
            const mockProvider = TEST_PROVIDERS.provider4;
            const mockDataSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProvider.serviceProvider,
                    providerId: 4,
                    pdpVerifierDataSetId: 789,
                    nextPieceId: 0,
                    currentPieceCount: 0,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 1,
                },
            ];
            cleanupMocks = setupProviderRegistryMocks(mockEthProvider, {
                providers: [mockProvider],
                approvedIds: [4],
            });
            const mockWarmStorageService = createMockWarmStorageService([mockProvider], mockDataSets, {
                getProviderIdByAddress: async (addr) => {
                    assert.equal(addr.toLowerCase(), mockProvider.serviceProvider.toLowerCase());
                    return 4;
                },
                getApprovedProvider: async (id) => {
                    assert.equal(id, 4);
                    return mockProvider;
                },
            });
            const service = await StorageContext.create(mockSynapse, mockWarmStorageService, {
                providerAddress: mockProvider.serviceProvider,
            });
            assert.equal(service.serviceProvider, mockProvider.serviceProvider);
            assert.equal(service.dataSetId, 789);
        });
        it('should throw when dataSetId not found', async () => {
            cleanupMocks = setupProviderRegistryMocks(mockEthProvider, {
                providers: [],
                approvedIds: [],
            });
            const mockWarmStorageService = createMockWarmStorageService([], []);
            try {
                await StorageContext.create(mockSynapse, mockWarmStorageService, {
                    dataSetId: 999,
                });
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'Data set 999 not found');
            }
        });
        it('should throw when dataSetId conflicts with providerId', async () => {
            const mockProvider1 = TEST_PROVIDERS.provider5;
            const mockDataSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProvider1.serviceProvider,
                    providerId: 5,
                    pdpVerifierDataSetId: 111,
                    nextPieceId: 0,
                    currentPieceCount: 0,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 1,
                },
            ];
            cleanupMocks = setupProviderRegistryMocks(mockEthProvider, {
                providers: [mockProvider1],
                approvedIds: [5],
            });
            const mockWarmStorageService = createMockWarmStorageService([mockProvider1], mockDataSets, {
                getProviderIdByAddress: async () => 5,
                getApprovedProvider: async (providerId) => {
                    if (providerId === 5) {
                        return mockProvider1;
                    }
                    throw new Error(`Provider ID ${providerId} is not currently approved`);
                },
            });
            try {
                await StorageContext.create(mockSynapse, mockWarmStorageService, {
                    dataSetId: 111,
                    providerId: 3,
                });
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'belongs to provider ID 5');
                assert.include(error.message, 'but provider ID 3 was requested');
            }
        });
        it('should throw when providerAddress not approved', async () => {
            cleanupMocks = setupProviderRegistryMocks(mockEthProvider, {
                providers: [],
                approvedIds: [],
            });
            const mockWarmStorageService = createMockWarmStorageService([], [], {
                getProviderIdByAddress: async () => 0,
                getApprovedProvider: async (_providerId) => {
                    return {
                        serviceProvider: '0x0000000000000000000000000000000000000000',
                        serviceURL: '',
                    };
                },
            });
            try {
                await StorageContext.create(mockSynapse, mockWarmStorageService, {
                    providerAddress: '0x6666666666666666666666666666666666666666',
                });
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'is not currently approved');
            }
        });
        it.skip('should filter by CDN setting in smart selection', async () => {
            const mockProviders = [
                createSimpleProvider({
                    serviceProvider: '0x7777777777777777777777777777777777777777',
                    serviceURL: 'https://pdp7.example.com',
                }),
            ];
            const mockDataSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProviders[0].serviceProvider,
                    pdpVerifierDataSetId: 200,
                    nextPieceId: 5,
                    currentPieceCount: 5,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 1,
                },
                {
                    railId: 2,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProviders[0].serviceProvider,
                    pdpVerifierDataSetId: 201,
                    nextPieceId: 3,
                    currentPieceCount: 3,
                    isLive: true,
                    isManaged: true,
                    withCDN: true,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 2,
                },
            ];
            const mockWarmStorageService = {
                getClientDataSetsWithDetails: async () => mockDataSets,
                getProviderIdByAddress: async () => 7,
                getApprovedProvider: async () => mockProviders[0],
                getAllApprovedProviders: async () => mockProviders,
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const originalFetch = global.fetch;
            global.fetch = async (input) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                if (url.includes('/ping')) {
                    return { status: 200, statusText: 'OK' };
                }
                throw new Error(`Unexpected URL: ${url}`);
            };
            try {
                const serviceNoCDN = await StorageContext.create(mockSynapse, mockWarmStorageService, {
                    withCDN: false,
                });
                assert.equal(serviceNoCDN.dataSetId, 200, 'Should select non-CDN data set');
                const serviceWithCDN = await StorageContext.create(mockSynapse, mockWarmStorageService, {
                    withCDN: true,
                });
                assert.equal(serviceWithCDN.dataSetId, 201, 'Should select CDN data set');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it.skip('should handle data sets not managed by current WarmStorage', async () => {
            const mockDataSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: '0x8888888888888888888888888888888888888888',
                    pdpVerifierDataSetId: 300,
                    nextPieceId: 0,
                    currentPieceCount: 0,
                    isLive: true,
                    isManaged: false,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 1,
                },
            ];
            const mockProvider = TEST_PROVIDERS.provider9;
            cleanupMocks = setupProviderRegistryMocks(mockEthProvider, {
                providers: [mockProvider],
                approvedIds: [9],
            });
            const mockWarmStorageService = createMockWarmStorageService([mockProvider], mockDataSets);
            const service = await StorageContext.create(mockSynapse, mockWarmStorageService, {});
            assert.exists(service.serviceProvider);
            assert.notEqual(service.serviceProvider, mockDataSets[0].payee);
        });
        it('should throw when data set belongs to non-approved provider', async () => {
            const mockDataSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',
                    providerId: 999,
                    pdpVerifierDataSetId: 400,
                    nextPieceId: 0,
                    currentPieceCount: 0,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 1,
                },
            ];
            const mockWarmStorageService = {
                getClientDataSetsWithDetails: async () => mockDataSets,
                getProviderIdByAddress: async () => 0,
                getApprovedProvider: async (_providerId) => {
                    return null;
                },
                isProviderIdApproved: async (_providerId) => {
                    return false;
                },
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            try {
                await StorageContext.create(mockSynapse, mockWarmStorageService, {
                    dataSetId: 400,
                });
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'is not currently approved');
            }
        });
        it.skip('should create new data set when none exist for provider', async () => {
            const mockProvider = createSimpleProvider({
                serviceProvider: '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb',
                serviceURL: 'https://pdp-b.example.com',
            });
            const mockWarmStorageService = {
                getApprovedProvider: async () => mockProvider,
                getClientDataSetsWithDetails: async () => [],
                getProviderIdByAddress: async () => 11,
                getNextClientDataSetId: async () => 1,
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = await StorageContext.create(mockSynapse, mockWarmStorageService, {
                providerId: 11,
            });
            assert.equal(service.serviceProvider, mockProvider.serviceProvider);
        });
        it.skip('should validate parallel fetching in resolveByProviderId', async () => {
            let getApprovedProviderCalled = false;
            let getClientDataSetsCalled = false;
            const callOrder = [];
            const mockProvider = createSimpleProvider({
                serviceProvider: '0xcccccccccccccccccccccccccccccccccccccccc',
                serviceURL: 'https://pdp-c.example.com',
            });
            const mockWarmStorageService = {
                getApprovedProvider: async () => {
                    callOrder.push('getApprovedProvider-start');
                    getApprovedProviderCalled = true;
                    await new Promise((resolve) => setTimeout(resolve, 10));
                    callOrder.push('getApprovedProvider-end');
                    return mockProvider;
                },
                getClientDataSetsWithDetails: async () => {
                    callOrder.push('getClientDataSetsWithDetails-start');
                    getClientDataSetsCalled = true;
                    await new Promise((resolve) => setTimeout(resolve, 10));
                    callOrder.push('getClientDataSetsWithDetails-end');
                    return [];
                },
                getNextClientDataSetId: async () => 1,
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            await StorageContext.create(mockSynapse, mockWarmStorageService, {
                providerId: 12,
            });
            assert.isTrue(getApprovedProviderCalled);
            assert.isTrue(getClientDataSetsCalled);
            const providerStartIndex = callOrder.indexOf('getApprovedProvider-start');
            const dataSetsStartIndex = callOrder.indexOf('getClientDataSetsWithDetails-start');
            const providerEndIndex = callOrder.indexOf('getApprovedProvider-end');
            assert.isBelow(providerStartIndex, providerEndIndex);
            assert.isBelow(dataSetsStartIndex, providerEndIndex);
        });
        it.skip('should use progressive loading in smart selection', async () => {
            let getClientDataSetsCalled = false;
            let getAllApprovedProvidersCalled = false;
            const mockProvider = createSimpleProvider({
                serviceProvider: '0xdddddddddddddddddddddddddddddddddddddddd',
                serviceURL: 'https://pdp-d.example.com',
            });
            const mockDataSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProvider.serviceProvider,
                    pdpVerifierDataSetId: 500,
                    nextPieceId: 2,
                    currentPieceCount: 2,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 1,
                },
            ];
            const mockWarmStorageService = {
                getClientDataSetsWithDetails: async () => {
                    getClientDataSetsCalled = true;
                    return mockDataSets;
                },
                getProviderIdByAddress: async () => 13,
                getApprovedProvider: async () => mockProvider,
                getAllApprovedProviders: async () => {
                    getAllApprovedProvidersCalled = true;
                    throw new Error('Should not fetch all providers when data sets exist');
                },
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const originalFetch = global.fetch;
            global.fetch = async (input) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                if (url.includes('/ping')) {
                    return { status: 200, statusText: 'OK' };
                }
                throw new Error(`Unexpected URL: ${url}`);
            };
            try {
                const service = await StorageContext.create(mockSynapse, mockWarmStorageService, {});
                assert.isTrue(getClientDataSetsCalled, 'Should fetch client data sets');
                assert.isFalse(getAllApprovedProvidersCalled, 'Should NOT fetch all providers');
                assert.equal(service.dataSetId, 500);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it.skip('should fetch all providers only when no data sets exist', async () => {
            let getAllApprovedProvidersCalled = false;
            const mockProviders = [
                createSimpleProvider({
                    serviceProvider: '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee',
                    serviceURL: 'https://pdp-e.example.com',
                }),
            ];
            const mockWarmStorageService = {
                getClientDataSetsWithDetails: async () => [],
                getAllApprovedProviders: async () => {
                    getAllApprovedProvidersCalled = true;
                    return mockProviders;
                },
                getNextClientDataSetId: async () => 1,
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            await StorageContext.create(mockSynapse, mockWarmStorageService, {});
            assert.isTrue(getAllApprovedProvidersCalled, 'Should fetch all providers when no data sets');
        });
        it.skip('should handle data set not live', async () => {
            const mockDataSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: '0xffffffffffffffffffffffffffffffffffffffffffff',
                    pdpVerifierDataSetId: 600,
                    nextPieceId: 0,
                    currentPieceCount: 0,
                    isLive: false,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 1,
                },
            ];
            const mockWarmStorageService = {
                getClientDataSetsWithDetails: async () => mockDataSets,
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            try {
                await StorageContext.create(mockSynapse, mockWarmStorageService, {
                    dataSetId: 600,
                });
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'Data set 600 not found');
            }
        });
        it.skip('should handle conflict between dataSetId and providerAddress', async () => {
            const mockDataSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: '0x1111222233334444555566667777888899990000',
                    pdpVerifierDataSetId: 700,
                    nextPieceId: 0,
                    currentPieceCount: 0,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: {},
                    pieceMetadata: [],
                    clientDataSetId: 1,
                },
            ];
            const mockWarmStorageService = {
                getClientDataSetsWithDetails: async () => mockDataSets,
                getProviderIdByAddress: async (address) => {
                    if (address === '0x1111222233334444555566667777888899990000') {
                        return 7;
                    }
                    if (address === '0x9999888877776666555544443333222211110000') {
                        return 8;
                    }
                    return 0;
                },
                getApprovedProvider: async (providerId) => {
                    if (providerId === 7) {
                        return createSimpleProvider({
                            serviceProvider: '0x1111222233334444555566667777888899990000',
                            serviceURL: 'https://example.com',
                        });
                    }
                    if (providerId === 8) {
                        return createSimpleProvider({
                            serviceProvider: '0x9999888877776666555544443333222211110000',
                            serviceURL: 'https://example2.com',
                        });
                    }
                    return {
                        serviceProvider: '0x0000000000000000000000000000000000000000',
                        serviceURL: '',
                    };
                },
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            try {
                await StorageContext.create(mockSynapse, mockWarmStorageService, {
                    dataSetId: 700,
                    providerAddress: '0x9999888877776666555544443333222211110000',
                });
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'belongs to provider');
                assert.include(error.message, 'but provider');
                assert.include(error.message, 'was requested');
            }
        });
        it.skip('should retry transaction fetch for up to 30 seconds', async () => {
        });
        it.skip('should fail after 30 seconds if transaction never appears', async () => {
        });
        it('should match providers by ID even when payee differs from serviceProvider', async () => {
            const provider2WithDifferentPayee = createMockProviderInfo({
                id: 2,
                serviceProvider: '0x682467D59F5679cB0BF13115d4C94550b8218CF2',
                name: 'Provider with different payee',
            });
            const mockDataSets = [
                {
                    pdpRailId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: '0x7A1CBda3352f7A2f24CD61Bec32580fb709a8913',
                    serviceProvider: '0x682467D59F5679cB0BF13115d4C94550b8218CF2',
                    providerId: 2,
                    pdpVerifierDataSetId: 100,
                    nextPieceId: 1,
                    currentPieceCount: 1,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    clientDataSetId: 1,
                    pdpEndEpoch: 0,
                    cdnRailId: 0,
                    cdnEndEpoch: 0,
                    cacheMissRailId: 0,
                    metadata: {},
                },
            ];
            const cleanupMocks = setupProviderRegistryMocks(mockEthProvider, {
                providers: [provider2WithDifferentPayee],
                approvedIds: [2],
            });
            const mockWarmStorageService = {
                getClientDataSetsWithDetails: async () => mockDataSets,
                getApprovedProvider: async (id) => {
                    if (id === 2)
                        return provider2WithDifferentPayee;
                    return null;
                },
                getAllApprovedProviders: async () => [provider2WithDifferentPayee],
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
                isProviderIdApproved: async (id) => id === 2,
                getApprovedProviderIds: async () => [2],
                getDataSetMetadata: async (dataSetId) => {
                    const dataSet = mockDataSets.find((d) => d.pdpVerifierDataSetId === dataSetId);
                    return dataSet?.metadata ?? {};
                },
            };
            const originalFetch = global.fetch;
            global.fetch = async (input) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                if (url.includes('/ping')) {
                    return { status: 200, statusText: 'OK' };
                }
                throw new Error(`Unexpected URL: ${url}`);
            };
            try {
                const service = await StorageContext.create(mockSynapse, mockWarmStorageService, {});
                assert.equal(service.dataSetId, 100);
                assert.equal(service.provider.id, 2);
                assert.equal(service.provider.serviceProvider, '0x682467D59F5679cB0BF13115d4C94550b8218CF2');
            }
            finally {
                global.fetch = originalFetch;
                cleanupMocks();
            }
        });
        it('should gracefully fall back to creating new data set when provider not matched', async () => {
            const provider3 = createMockProviderInfo({
                id: 3,
                serviceProvider: '0x3333333333333333333333333333333333333333',
                name: 'New Provider',
                products: {
                    PDP: {
                        type: 'PDP',
                        isActive: true,
                        capabilities: {},
                        data: {
                            serviceURL: 'https://provider3.example.com',
                            minPieceSizeInBytes: SIZE_CONSTANTS.KiB,
                            maxPieceSizeInBytes: SIZE_CONSTANTS.GiB,
                            ipniPiece: false,
                            ipniIpfs: false,
                            storagePricePerTibPerMonth: BigInt(1000000),
                            minProvingPeriodInEpochs: 2880,
                            location: 'US',
                            paymentTokenAddress: '0x0000000000000000000000000000000000000000',
                        },
                    },
                },
            });
            const mockDataSets = [
                {
                    pdpRailId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: '0x1111111111111111111111111111111111111111',
                    serviceProvider: '0x1111111111111111111111111111111111111111',
                    providerId: 1,
                    pdpVerifierDataSetId: 50,
                    nextPieceId: 1,
                    currentPieceCount: 1,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    clientDataSetId: 1,
                    pdpEndEpoch: 0,
                    cdnRailId: 0,
                    cdnEndEpoch: 0,
                    cacheMissRailId: 0,
                    metadata: {},
                },
            ];
            let consoleWarnCalled = false;
            const originalWarn = console.warn;
            console.warn = (message) => {
                if (message.includes('All providers from existing data sets failed health check')) {
                    consoleWarnCalled = true;
                }
            };
            const cleanupMocks = setupProviderRegistryMocks(mockEthProvider, {
                providers: [TEST_PROVIDERS.provider1, provider3],
                approvedIds: [1, 3],
            });
            const mockWarmStorageService = {
                getClientDataSetsWithDetails: async () => mockDataSets,
                getApprovedProvider: async (id) => {
                    if (id === 1)
                        return TEST_PROVIDERS.provider1;
                    if (id === 3)
                        return provider3;
                    return null;
                },
                getAllApprovedProviders: async () => [TEST_PROVIDERS.provider1, provider3],
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
                getNextClientDataSetId: async () => 2,
                isProviderIdApproved: async (id) => id === 1 || id === 3,
                getApprovedProviderIds: async () => [1, 3],
            };
            const originalFetch = global.fetch;
            global.fetch = async (input) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                if (url.includes('/ping')) {
                    if (url.includes('provider.example.com')) {
                        throw new Error('Connection refused');
                    }
                    if (url.includes('provider3.example.com')) {
                        return { status: 200, statusText: 'OK' };
                    }
                    throw new Error('Connection refused');
                }
                throw new Error(`Unexpected URL: ${url}`);
            };
            try {
                await StorageContext.create(mockSynapse, mockWarmStorageService, {});
                assert.isTrue(consoleWarnCalled, 'Should have logged warning about fallback');
            }
            catch (_error) {
                assert.isTrue(consoleWarnCalled, 'Should have logged warning about fallback');
            }
            finally {
                global.fetch = originalFetch;
                console.warn = originalWarn;
                cleanupMocks();
            }
        });
    });
    describe('preflightUpload', () => {
        it('should calculate costs without CDN', async () => {
            const mockWarmStorageService = {
                checkAllowanceForStorage: async () => ({
                    rateAllowanceNeeded: BigInt(100),
                    lockupAllowanceNeeded: BigInt(2880000),
                    currentRateAllowance: BigInt(1000000),
                    currentLockupAllowance: BigInt(10000000),
                    currentRateUsed: BigInt(0),
                    currentLockupUsed: BigInt(0),
                    sufficient: true,
                    message: undefined,
                    costs: {
                        perEpoch: BigInt(100),
                        perDay: BigInt(28800),
                        perMonth: BigInt(864000),
                    },
                }),
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const preflight = await service.preflightUpload(Number(SIZE_CONSTANTS.MiB));
            assert.equal(preflight.estimatedCost.perEpoch, BigInt(100));
            assert.equal(preflight.estimatedCost.perDay, BigInt(28800));
            assert.equal(preflight.estimatedCost.perMonth, BigInt(864000));
            assert.isTrue(preflight.allowanceCheck.sufficient);
        });
        it('should calculate costs with CDN', async () => {
            const mockWarmStorageService = {
                checkAllowanceForStorage: async () => ({
                    rateAllowanceNeeded: BigInt(200),
                    lockupAllowanceNeeded: BigInt(5760000),
                    currentRateAllowance: BigInt(1000000),
                    currentLockupAllowance: BigInt(10000000),
                    currentRateUsed: BigInt(0),
                    currentLockupUsed: BigInt(0),
                    sufficient: true,
                    message: undefined,
                    costs: {
                        perEpoch: BigInt(200),
                        perDay: BigInt(57600),
                        perMonth: BigInt(1728000),
                    },
                }),
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: true,
            }, {});
            const preflight = await service.preflightUpload(Number(SIZE_CONSTANTS.MiB));
            assert.equal(preflight.estimatedCost.perEpoch, BigInt(200));
            assert.equal(preflight.estimatedCost.perDay, BigInt(57600));
            assert.equal(preflight.estimatedCost.perMonth, BigInt(1728000));
            assert.isTrue(preflight.allowanceCheck.sufficient);
        });
        it('should handle insufficient allowances', async () => {
            const mockWarmStorageService = {
                checkAllowanceForStorage: async () => ({
                    rateAllowanceNeeded: BigInt(2000000),
                    lockupAllowanceNeeded: BigInt(20000000),
                    currentRateAllowance: BigInt(1000000),
                    currentLockupAllowance: BigInt(10000000),
                    currentRateUsed: BigInt(0),
                    currentLockupUsed: BigInt(0),
                    sufficient: false,
                    message: 'Rate allowance insufficient: current 1000000, need 2000000. Lockup allowance insufficient: current 10000000, need 20000000',
                    costs: {
                        perEpoch: BigInt(100),
                        perDay: BigInt(28800),
                        perMonth: BigInt(864000),
                    },
                }),
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const preflight = await service.preflightUpload(Number(100n * SIZE_CONSTANTS.MiB));
            assert.isFalse(preflight.allowanceCheck.sufficient);
            assert.include(preflight.allowanceCheck.message, 'Rate allowance insufficient');
            assert.include(preflight.allowanceCheck.message, 'Lockup allowance insufficient');
        });
        it('should enforce minimum size limit in preflightUpload', async () => {
            const mockWarmStorageService = {};
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            try {
                await service.preflightUpload(126);
                assert.fail('Should have thrown size limit error');
            }
            catch (error) {
                assert.include(error.message, 'below minimum allowed size');
                assert.include(error.message, '126 bytes');
                assert.include(error.message, '127 bytes');
            }
        });
        it('should enforce maximum size limit in preflightUpload', async () => {
            const mockWarmStorageService = {
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            try {
                await service.preflightUpload(Number(210n * SIZE_CONSTANTS.MiB));
                assert.fail('Should have thrown size limit error');
            }
            catch (error) {
                assert.include(error.message, 'exceeds maximum allowed size');
                assert.include(error.message, '220200960');
                assert.include(error.message, '209715200');
            }
        });
    });
    describe('download', () => {
        it('should download and verify a piece', async () => {
            const testData = new Uint8Array(127).fill(42);
            const testPieceCID = 'bafkzcibeqcad6efnpwn62p5vvs5x3nh3j7xkzfgb3xtitcdm2hulmty3xx4tl3wace';
            const mockSynapseWithDownload = {
                ...mockSynapse,
                download: async (pieceCid, options) => {
                    assert.equal(pieceCid, testPieceCID);
                    assert.equal(options?.providerAddress, mockProvider.serviceProvider);
                    assert.equal(options?.withCDN, false);
                    return testData;
                },
            };
            const mockWarmStorageService = {
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapseWithDownload, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const downloaded = await service.download(testPieceCID);
            assert.deepEqual(downloaded, testData);
        });
        it('should handle download errors', async () => {
            const testPieceCID = 'bafkzcibeqcad6efnpwn62p5vvs5x3nh3j7xkzfgb3xtitcdm2hulmty3xx4tl3wace';
            const mockSynapseWithError = {
                ...mockSynapse,
                download: async () => {
                    throw new Error('Network error');
                },
            };
            const mockWarmStorageService = {
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapseWithError, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            try {
                await service.download(testPieceCID);
                assert.fail('Should have thrown');
            }
            catch (error) {
                assert.equal(error.message, 'Network error');
            }
        });
        it('should accept empty download options', async () => {
            const testData = new Uint8Array(127).fill(42);
            const testPieceCID = 'bafkzcibeqcad6efnpwn62p5vvs5x3nh3j7xkzfgb3xtitcdm2hulmty3xx4tl3wace';
            const mockSynapseWithOptions = {
                ...mockSynapse,
                download: async (pieceCid, options) => {
                    assert.equal(pieceCid, testPieceCID);
                    assert.equal(options?.providerAddress, mockProvider.serviceProvider);
                    assert.equal(options?.withCDN, false);
                    return testData;
                },
            };
            const mockWarmStorageService = {
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapseWithOptions, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const downloaded1 = await service.download(testPieceCID);
            assert.deepEqual(downloaded1, testData);
            const downloaded2 = await service.download(testPieceCID, {});
            assert.deepEqual(downloaded2, testData);
        });
    });
    describe('upload', () => {
        it('should enforce 127 byte minimum size limit', async () => {
            const mockWarmStorageService = {
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const undersizedData = new Uint8Array(126);
            try {
                await service.upload(undersizedData);
                assert.fail('Should have thrown size limit error');
            }
            catch (error) {
                assert.include(error.message, 'below minimum allowed size');
                assert.include(error.message, '126 bytes');
                assert.include(error.message, '127 bytes');
            }
        });
        it('should support parallel uploads', async () => {
            let nextPieceId = 0;
            const addPiecesCalls = [];
            const mockWarmStorageService = {
                getAddPiecesInfo: async () => {
                    const currentPieceId = nextPieceId;
                    nextPieceId++;
                    return {
                        nextPieceId: currentPieceId,
                        clientDataSetId: 1,
                        currentPieceCount: currentPieceId,
                    };
                },
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async (data) => {
                const pieceCid = `bafkzcibcd4bdomn3tgwgrh3g532zopskstnbrd2n3sxfqbze7rxt7vqn7veigm${data[0]}`;
                return { pieceCid, size: data.length };
            };
            serviceAny._pdpServer.findPiece = async () => ({
                uuid: 'test-uuid',
            });
            const mockTxHash = mockAddPieces(serviceAny, {
                onCall: (_dataSetId, _clientDataSetId, nextPieceId, pieceCids) => {
                    pieceCids.forEach((pieceCid, index) => {
                        addPiecesCalls.push({
                            pieceCid: pieceCid.toString(),
                            pieceId: nextPieceId + index,
                        });
                    });
                },
            });
            mockGetPieceAdditionStatus(serviceAny);
            const mockTransaction = {
                hash: mockTxHash,
                wait: async () => ({ status: 1, blockNumber: 12345 }),
            };
            mockEthProvider.getTransaction = async () => mockTransaction;
            const uploadCompleteCallbacks = [];
            const pieceAddedCallbacks = [];
            const firstData = new Uint8Array(127).fill(1);
            const secondData = new Uint8Array(128).fill(2);
            const thirdData = new Uint8Array(129).fill(3);
            const uploads = [
                service.upload(firstData, {
                    onUploadComplete: (pieceCid) => uploadCompleteCallbacks.push(pieceCid.toString()),
                    onPieceAdded: () => pieceAddedCallbacks.push(1),
                }),
                service.upload(secondData, {
                    onUploadComplete: (pieceCid) => uploadCompleteCallbacks.push(pieceCid.toString()),
                    onPieceAdded: () => pieceAddedCallbacks.push(2),
                }),
                service.upload(thirdData, {
                    onUploadComplete: (pieceCid) => uploadCompleteCallbacks.push(pieceCid.toString()),
                    onPieceAdded: () => pieceAddedCallbacks.push(3),
                }),
            ];
            const results = await Promise.all(uploads);
            assert.lengthOf(results, 3, 'All three uploads should complete successfully');
            const resultSizes = results.map((r) => r.size);
            const resultPieceIds = results.map((r) => r.pieceId);
            assert.deepEqual(resultSizes, [127, 128, 129], 'Should have one result for each data size');
            assert.deepEqual(resultPieceIds, [0, 1, 2], 'The set of assigned piece IDs should be {0, 1, 2}');
            assert.lengthOf(addPiecesCalls, 3, 'addPieces should be called three times');
            for (const result of results) {
                assert.isTrue(addPiecesCalls.some((call) => call.pieceCid === result.pieceCid.toString() && call.pieceId === result.pieceId), `addPieces call for pieceCid ${String(result.pieceCid)} and pieceId ${result.pieceId != null ? String(result.pieceId) : 'not found'} should exist`);
            }
            assert.lengthOf(uploadCompleteCallbacks, 3, 'All upload complete callbacks should be called');
            assert.lengthOf(pieceAddedCallbacks, 3, 'All piece added callbacks should be called');
            assert.deepEqual(pieceAddedCallbacks.sort((a, b) => a - b), [1, 2, 3], 'All callbacks should be called');
        });
        it('should respect batch size configuration', async () => {
            let nextPieceId = 0;
            const addPiecesCalls = [];
            const mockWarmStorageService = {
                getAddPiecesInfo: async () => {
                    const currentPieceId = nextPieceId;
                    return {
                        nextPieceId: currentPieceId,
                        clientDataSetId: 1,
                        currentPieceCount: currentPieceId,
                    };
                },
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
                uploadBatchSize: 2,
            }, {});
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async (data) => {
                const pieceCid = `bafkzcibcd4bdomn3tgwgrh3g532zopskstnbrd2n3sxfqbze7rxt7vqn7veigm${data[0]}`;
                return { pieceCid, size: data.length };
            };
            serviceAny._pdpServer.findPiece = async () => ({
                uuid: 'test-uuid',
            });
            const mockTxHash = mockAddPieces(serviceAny, {
                txHash: `0x${'1'.repeat(64)}`,
                addDelay: 10,
                onCall: async (_dataSetId, _clientDataSetId, pieceIdStart, comms) => {
                    addPiecesCalls.push({
                        batchSize: comms.length,
                        nextPieceId: pieceIdStart,
                    });
                    nextPieceId += comms.length;
                },
            });
            mockGetPieceAdditionStatus(serviceAny);
            const mockTransaction = {
                hash: mockTxHash,
                wait: async () => ({ status: 1, blockNumber: 12345 }),
            };
            mockEthProvider.getTransaction = async () => mockTransaction;
            const uploads = [];
            const uploadData = [
                new Uint8Array(127).fill(0),
                new Uint8Array(127).fill(1),
                new Uint8Array(127).fill(2),
                new Uint8Array(127).fill(3),
                new Uint8Array(127).fill(4),
            ];
            for (const data of uploadData) {
                uploads.push(service.upload(data));
            }
            const results = await Promise.all(uploads);
            assert.lengthOf(results, 5, 'All uploads should complete successfully');
            assert.isBelow(addPiecesCalls.length, 5, 'Should have fewer batches than uploads');
            const totalProcessed = addPiecesCalls.reduce((sum, call) => sum + call.batchSize, 0);
            assert.equal(totalProcessed, 5, 'All 5 uploads should be processed');
            assert.equal(addPiecesCalls[0].nextPieceId, 0, 'First batch should start at piece ID 0');
            for (let i = 1; i < addPiecesCalls.length; i++) {
                const expectedId = addPiecesCalls[i - 1].nextPieceId + addPiecesCalls[i - 1].batchSize;
                assert.equal(addPiecesCalls[i].nextPieceId, expectedId, `Batch ${i} should have correct sequential piece ID`);
            }
        });
        it('should handle batch size of 1', async () => {
            let nextPieceId = 0;
            const addPiecesCalls = [];
            const mockWarmStorageService = {
                getAddPiecesInfo: async () => ({
                    nextPieceId: nextPieceId++,
                    clientDataSetId: 1,
                    currentPieceCount: nextPieceId,
                }),
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
                uploadBatchSize: 1,
            }, {});
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async (data) => ({
                pieceCid: `bafkzcibcd4bdomn3tgwgrh3g532zopskstnbrd2n3sxfqbze7rxt7vqn7veigm${data[0]}`,
                size: data.length,
            });
            serviceAny._pdpServer.findPiece = async () => ({
                uuid: 'test-uuid',
            });
            const mockTxHash2 = `0x${'2'.repeat(64)}`;
            serviceAny._pdpServer.addPieces = async (_dataSetId, _clientDataSetId, nextPieceId, comms) => {
                addPiecesCalls.push(comms.length);
                const pieceIds = Array.from({ length: comms.length }, (_, i) => nextPieceId + i);
                serviceAny._pdpServer._lastPieceIds = pieceIds;
                return {
                    message: 'success',
                    txHash: mockTxHash2,
                };
            };
            serviceAny._pdpServer.getPieceAdditionStatus = async () => {
                const pieceIds = serviceAny._pdpServer._lastPieceIds || [];
                return {
                    txStatus: 'confirmed',
                    addMessageOk: true,
                    confirmedPieceIds: pieceIds,
                };
            };
            const mockTransaction = {
                hash: mockTxHash2,
                wait: async () => ({ status: 1, blockNumber: 12345 }),
            };
            mockEthProvider.getTransaction = async () => mockTransaction;
            const uploads = [
                service.upload(new Uint8Array(127).fill(1)),
                service.upload(new Uint8Array(128).fill(2)),
                service.upload(new Uint8Array(129).fill(3)),
            ];
            await Promise.all(uploads);
            assert.lengthOf(addPiecesCalls, 3, 'Should have 3 individual calls');
            assert.deepEqual(addPiecesCalls, [1, 1, 1], 'Each call should have exactly 1 piece');
        });
        it('should debounce uploads for better batching', async () => {
            const addPiecesCalls = [];
            const mockWarmStorageService = {
                getAddPiecesInfo: async () => ({
                    nextPieceId: 0,
                    clientDataSetId: 1,
                    currentPieceCount: 0,
                }),
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async (data) => ({
                pieceCid: `bafkzcibcd4bdomn3tgwgrh3g532zopskstnbrd2n3sxfqbze7rxt7vqn7veigmy${data[0]}`,
                size: data.length,
            });
            serviceAny._pdpServer.findPiece = async () => ({
                uuid: 'test-uuid',
            });
            const mockTxHash3 = `0x${'3'.repeat(64)}`;
            serviceAny._pdpServer.addPieces = async (_dataSetId, _clientDataSetId, nextPieceId, comms) => {
                addPiecesCalls.push({ batchSize: comms.length });
                const pieceIds = Array.from({ length: comms.length }, (_, i) => nextPieceId + i);
                serviceAny._pdpServer._lastPieceIds = pieceIds;
                return {
                    message: 'success',
                    txHash: mockTxHash3,
                };
            };
            serviceAny._pdpServer.getPieceAdditionStatus = async () => {
                const pieceIds = serviceAny._pdpServer._lastPieceIds || [];
                return {
                    txStatus: 'confirmed',
                    addMessageOk: true,
                    confirmedPieceIds: pieceIds,
                };
            };
            const mockTransaction = {
                hash: mockTxHash3,
                wait: async () => ({ status: 1, blockNumber: 12345 }),
            };
            mockEthProvider.getTransaction = async () => mockTransaction;
            const uploads = [];
            for (let i = 0; i < 5; i++) {
                uploads.push(service.upload(new Uint8Array(127).fill(i)));
            }
            await Promise.all(uploads);
            assert.lengthOf(addPiecesCalls, 1, 'Should have exactly 1 batch due to debounce');
            assert.equal(addPiecesCalls[0].batchSize, 5, 'Batch should contain all 5 uploads');
        });
        it('should handle errors in batch processing gracefully', async () => {
            const mockWarmStorageService = {
                getAddPiecesInfo: async () => ({
                    nextPieceId: 0,
                    clientDataSetId: 1,
                    currentPieceCount: 0,
                }),
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
                uploadBatchSize: 2,
            }, {});
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async (data) => ({
                pieceCid: `bafkzcibcd4bdomn3tgwgrh3g532zopskstnbrd2n3sxfqbze7rxt7vqn7veigm${data[0]}`,
                size: data.length,
            });
            serviceAny._pdpServer.findPiece = async () => ({
                uuid: 'test-uuid',
            });
            mockAddPieces(serviceAny, {
                shouldFail: true,
                failureMessage: 'Network error during addPieces',
            });
            const uploads = [
                service.upload(new Uint8Array(127).fill(1)),
                service.upload(new Uint8Array(128).fill(2)),
                service.upload(new Uint8Array(129).fill(3)),
            ];
            const results = await Promise.allSettled(uploads);
            assert.equal(results[0].status, 'rejected');
            assert.equal(results[1].status, 'rejected');
            if (results[0].status === 'rejected' && results[1].status === 'rejected') {
                assert.include(results[0].reason.message, 'Network error during addPieces');
                assert.include(results[1].reason.message, 'Network error during addPieces');
                assert.equal(results[0].reason.message, results[1].reason.message);
            }
            if (results[2].status === 'rejected') {
                assert.include(results[2].reason.message, 'Network error during addPieces');
            }
        });
        it('should enforce 200 MiB size limit', async () => {
            const mockWarmStorageService = {};
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const oversizedData = new Uint8Array(Number(210n * SIZE_CONSTANTS.MiB));
            try {
                await service.upload(oversizedData);
                assert.fail('Should have thrown size limit error');
            }
            catch (error) {
                assert.include(error.message, 'exceeds maximum allowed size');
                assert.include(error.message, '220200960');
                assert.include(error.message, '209715200');
            }
        });
        it('should accept data at exactly 127 bytes', async () => {
            const mockWarmStorageService = {
                getAddPiecesInfo: async () => ({
                    nextPieceId: 0,
                    clientDataSetId: 1,
                    currentPieceCount: 0,
                }),
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const minSizeData = new Uint8Array(127);
            const testPieceCID = 'bafkzcibeqcad6efnpwn62p5vvs5x3nh3j7xkzfgb3xtitcdm2hulmty3xx4tl3wace';
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async (data) => {
                assert.equal(data.length, 127);
                return { pieceCid: testPieceCID, size: data.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                return { uuid: 'test-uuid' };
            };
            const mockTxHash4 = `0x${'4'.repeat(64)}`;
            serviceAny._pdpServer.addPieces = async (_dataSetId, _clientDataSetId, nextPieceId) => {
                const pieceIds = [nextPieceId];
                serviceAny._pdpServer._lastPieceIds = pieceIds;
                return {
                    message: 'success',
                    txHash: mockTxHash4,
                };
            };
            serviceAny._pdpServer.getPieceAdditionStatus = async () => {
                const pieceIds = serviceAny._pdpServer._lastPieceIds || [];
                return {
                    txStatus: 'confirmed',
                    addMessageOk: true,
                    confirmedPieceIds: pieceIds,
                };
            };
            const mockTransaction = {
                hash: mockTxHash4,
                wait: async () => ({ status: 1, blockNumber: 12345 }),
            };
            mockEthProvider.getTransaction = async () => mockTransaction;
            const result = await service.upload(minSizeData);
            assert.equal(result.pieceCid.toString(), testPieceCID);
            assert.equal(result.size, 127);
        });
        it('should accept data up to 200 MiB', async () => {
            const mockWarmStorageService = {
                getAddPiecesInfo: async () => ({
                    nextPieceId: 0,
                    clientDataSetId: 1,
                    currentPieceCount: 0,
                }),
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const maxSizeData = new Uint8Array(SIZE_CONSTANTS.MAX_UPLOAD_SIZE);
            const testPieceCID = 'bafkzcibeqcad6efnpwn62p5vvs5x3nh3j7xkzfgb3xtitcdm2hulmty3xx4tl3wace';
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async (data) => {
                assert.equal(data.length, SIZE_CONSTANTS.MAX_UPLOAD_SIZE);
                return { pieceCid: testPieceCID, size: data.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                return { uuid: 'test-uuid' };
            };
            const mockTxHash5 = `0x${'5'.repeat(64)}`;
            serviceAny._pdpServer.addPieces = async (_dataSetId, _clientDataSetId, nextPieceId) => {
                const pieceIds = [nextPieceId];
                serviceAny._pdpServer._lastPieceIds = pieceIds;
                return {
                    message: 'success',
                    txHash: mockTxHash5,
                };
            };
            serviceAny._pdpServer.getPieceAdditionStatus = async () => {
                const pieceIds = serviceAny._pdpServer._lastPieceIds || [];
                return {
                    txStatus: 'confirmed',
                    addMessageOk: true,
                    confirmedPieceIds: pieceIds,
                };
            };
            const mockTransaction = {
                hash: mockTxHash5,
                wait: async () => ({ status: 1, blockNumber: 12345 }),
            };
            mockEthProvider.getTransaction = async () => mockTransaction;
            const result = await service.upload(maxSizeData);
            assert.equal(result.pieceCid.toString(), testPieceCID);
            assert.equal(result.size, SIZE_CONSTANTS.MAX_UPLOAD_SIZE);
            assert.equal(result.pieceId, 0);
        });
        it('should handle upload callbacks correctly', async () => {
            const mockWarmStorageService = {
                getAddPiecesInfo: async () => ({
                    nextPieceId: 0,
                    clientDataSetId: 1,
                    currentPieceCount: 0,
                }),
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const testData = new Uint8Array(127).fill(42);
            const testPieceCID = 'bafkzcibeqcad6efnpwn62p5vvs5x3nh3j7xkzfgb3xtitcdm2hulmty3xx4tl3wace';
            let uploadCompleteCallbackFired = false;
            let pieceAddedCallbackFired = false;
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async () => {
                return { pieceCid: testPieceCID, size: testData.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                return { uuid: 'test-uuid' };
            };
            const mockTxHash6 = `0x${'6'.repeat(64)}`;
            serviceAny._pdpServer.addPieces = async (_dataSetId, _clientDataSetId, nextPieceId) => {
                const pieceIds = [nextPieceId];
                serviceAny._pdpServer._lastPieceIds = pieceIds;
                return {
                    message: 'success',
                    txHash: mockTxHash6,
                };
            };
            serviceAny._pdpServer.getPieceAdditionStatus = async () => {
                const pieceIds = serviceAny._pdpServer._lastPieceIds || [];
                return {
                    txStatus: 'confirmed',
                    addMessageOk: true,
                    confirmedPieceIds: pieceIds,
                };
            };
            const mockTransaction = {
                hash: mockTxHash6,
                wait: async () => ({ status: 1, blockNumber: 12345 }),
            };
            mockEthProvider.getTransaction = async () => mockTransaction;
            const result = await service.upload(testData, {
                onUploadComplete: (pieceCid) => {
                    assert.equal(pieceCid.toString(), testPieceCID);
                    uploadCompleteCallbackFired = true;
                },
                onPieceAdded: () => {
                    pieceAddedCallbackFired = true;
                },
            });
            assert.isTrue(uploadCompleteCallbackFired, 'onUploadComplete should have been called');
            assert.isTrue(pieceAddedCallbackFired, 'onPieceAdded should have been called');
            assert.equal(result.pieceCid.toString(), testPieceCID);
        });
        it('should handle new server with transaction tracking', async () => {
            const mockWarmStorageService = {
                getAddPiecesInfo: async () => ({
                    nextPieceId: 0,
                    clientDataSetId: 1,
                    currentPieceCount: 0,
                }),
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const testData = new Uint8Array(127).fill(42);
            const testPieceCID = 'bafkzcibeqcad6efnpwn62p5vvs5x3nh3j7xkzfgb3xtitcdm2hulmty3xx4tl3wace';
            const mockTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
            let uploadCompleteCallbackFired = false;
            let pieceAddedCallbackFired = false;
            let pieceConfirmedCallbackFired = false;
            let pieceAddedTransaction = null;
            let confirmedPieceIds = [];
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async () => {
                return { pieceCid: testPieceCID, size: testData.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                return { uuid: 'test-uuid' };
            };
            serviceAny._pdpServer.addPieces = async () => {
                return {
                    message: 'success',
                    txHash: mockTxHash,
                    statusUrl: `https://pdp.example.com/pdp/data-sets/123/pieces/added/${mockTxHash}`,
                };
            };
            const mockTransaction = {
                hash: mockTxHash,
                wait: async () => ({ status: 1 }),
            };
            const originalGetTransaction = mockEthProvider.getTransaction;
            mockEthProvider.getTransaction = async (hash) => {
                assert.equal(hash, mockTxHash);
                return mockTransaction;
            };
            serviceAny._pdpServer.getPieceAdditionStatus = async (dataSetId, txHash) => {
                assert.equal(dataSetId, 123);
                assert.equal(txHash, mockTxHash);
                return {
                    txHash: mockTxHash,
                    txStatus: 'confirmed',
                    dataSetId: 123,
                    pieceCount: 1,
                    addMessageOk: true,
                    confirmedPieceIds: [42],
                };
            };
            try {
                const result = await service.upload(testData, {
                    onUploadComplete: (pieceCid) => {
                        assert.equal(pieceCid.toString(), testPieceCID);
                        uploadCompleteCallbackFired = true;
                    },
                    onPieceAdded: (transaction) => {
                        pieceAddedCallbackFired = true;
                        pieceAddedTransaction = transaction;
                    },
                    onPieceConfirmed: (pieceIds) => {
                        pieceConfirmedCallbackFired = true;
                        confirmedPieceIds = pieceIds;
                    },
                });
                assert.isTrue(uploadCompleteCallbackFired, 'onUploadComplete should have been called');
                assert.isTrue(pieceAddedCallbackFired, 'onPieceAdded should have been called');
                assert.isTrue(pieceConfirmedCallbackFired, 'onPieceConfirmed should have been called');
                assert.exists(pieceAddedTransaction, 'Transaction should be passed to onPieceAdded');
                assert.equal(pieceAddedTransaction.hash, mockTxHash);
                assert.deepEqual(confirmedPieceIds, [42]);
                assert.equal(result.pieceId, 42);
            }
            finally {
                mockEthProvider.getTransaction = originalGetTransaction;
            }
        });
        it.skip('should fail if new server transaction is not found on-chain', async () => {
            const mockWarmStorageService = {
                getAddPiecesInfo: async () => ({
                    nextPieceId: 0,
                    clientDataSetId: 1,
                    currentPieceCount: 0,
                }),
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const testData = new Uint8Array(127).fill(42);
            const testPieceCID = 'bafkzcibeqcad6efnpwn62p5vvs5x3nh3j7xkzfgb3xtitcdm2hulmty3xx4tl3wace';
            const mockTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async () => {
                return { pieceCid: testPieceCID, size: testData.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                return { uuid: 'test-uuid' };
            };
            serviceAny._pdpServer.addPieces = async () => {
                return {
                    message: 'success',
                    txHash: mockTxHash,
                    statusUrl: `https://pdp.example.com/pdp/data-sets/123/pieces/added/${mockTxHash}`,
                };
            };
            const originalGetTransaction = mockEthProvider.getTransaction;
            mockEthProvider.getTransaction = async () => null;
            try {
                await service.upload(testData);
                assert.fail('Should have thrown error for transaction not found');
            }
            catch (error) {
                assert.include(error.message, 'StorageContext addPieces failed:');
                assert.include(error.message, 'Server returned transaction hash');
                assert.include(error.message, 'but transaction was not found on-chain');
            }
            finally {
                mockEthProvider.getTransaction = originalGetTransaction;
            }
        });
        it.skip('should fail if new server verification fails', async () => {
            const mockWarmStorageService = {
                getAddPiecesInfo: async () => ({
                    nextPieceId: 0,
                    clientDataSetId: 1,
                    currentPieceCount: 0,
                }),
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const testData = new Uint8Array(127).fill(42);
            const testPieceCID = 'bafkzcibeqcad6efnpwn62p5vvs5x3nh3j7xkzfgb3xtitcdm2hulmty3xx4tl3wace';
            const mockTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async () => {
                return { pieceCid: testPieceCID, size: testData.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                return { uuid: 'test-uuid' };
            };
            serviceAny._pdpServer.addPieces = async () => {
                return {
                    message: 'success',
                    txHash: mockTxHash,
                    statusUrl: `https://pdp.example.com/pdp/data-sets/123/pieces/added/${mockTxHash}`,
                };
            };
            const mockTransaction = {
                hash: mockTxHash,
                wait: async () => ({ status: 1 }),
            };
            const originalGetTransaction = mockEthProvider.getTransaction;
            mockEthProvider.getTransaction = async () => mockTransaction;
            serviceAny._pdpServer.getPieceAdditionStatus = async () => {
                throw new Error('Piece addition status not found');
            };
            try {
                await service.upload(testData);
                assert.fail('Should have thrown error for verification failure');
            }
            catch (error) {
                assert.include(error.message, 'StorageContext addPieces failed:');
                assert.include(error.message, 'Failed to verify piece addition');
                assert.include(error.message, 'The transaction was confirmed on-chain but the server failed to acknowledge it');
            }
            finally {
                mockEthProvider.getTransaction = originalGetTransaction;
            }
        });
        it('should handle transaction failure on-chain', async () => {
            const mockWarmStorageService = {
                getAddPiecesInfo: async () => ({
                    nextPieceId: 0,
                    clientDataSetId: 1,
                    currentPieceCount: 0,
                }),
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const testData = new Uint8Array(127).fill(42);
            const testPieceCID = 'bafkzcibeqcad6efnpwn62p5vvs5x3nh3j7xkzfgb3xtitcdm2hulmty3xx4tl3wace';
            const mockTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async () => {
                return { pieceCid: testPieceCID, size: testData.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                return { uuid: 'test-uuid' };
            };
            serviceAny._pdpServer.addPieces = async () => {
                return {
                    message: 'success',
                    txHash: mockTxHash,
                    statusUrl: `https://pdp.example.com/pdp/data-sets/123/pieces/added/${mockTxHash}`,
                };
            };
            const mockTransaction = {
                hash: mockTxHash,
                wait: async () => ({ status: 0 }),
            };
            const originalGetTransaction = mockEthProvider.getTransaction;
            mockEthProvider.getTransaction = async () => mockTransaction;
            try {
                await service.upload(testData);
                assert.fail('Should have thrown error for failed transaction');
            }
            catch (error) {
                assert.include(error.message, 'StorageContext addPieces failed:');
                assert.include(error.message, 'Failed to add piece to data set');
            }
            finally {
                mockEthProvider.getTransaction = originalGetTransaction;
            }
        });
        it.skip('should work with old servers that do not provide transaction tracking', async () => {
            const mockWarmStorageService = {
                getAddPiecesInfo: async () => ({
                    nextPieceId: 0,
                    clientDataSetId: 1,
                    currentPieceCount: 0,
                }),
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const testData = new Uint8Array(127).fill(42);
            const testPieceCID = 'bafkzcibeqcad6efnpwn62p5vvs5x3nh3j7xkzfgb3xtitcdm2hulmty3xx4tl3wace';
            let pieceAddedCallbackFired = false;
            let pieceAddedTransaction;
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async () => {
                return { pieceCid: testPieceCID, size: testData.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                return { uuid: 'test-uuid' };
            };
            const mockTxHash7 = `0x${'7'.repeat(64)}`;
            serviceAny._pdpServer.addPieces = async (_dataSetId, _clientDataSetId, nextPieceId) => {
                const pieceIds = [nextPieceId];
                serviceAny._pdpServer._lastPieceIds = pieceIds;
                return {
                    message: 'success',
                    txHash: mockTxHash7,
                };
            };
            serviceAny._pdpServer.getPieceAdditionStatus = async () => {
                const pieceIds = serviceAny._pdpServer._lastPieceIds || [];
                return {
                    txStatus: 'confirmed',
                    addMessageOk: true,
                    confirmedPieceIds: pieceIds,
                };
            };
            const mockTransaction = {
                hash: mockTxHash7,
                wait: async () => ({ status: 1, blockNumber: 12345 }),
            };
            mockEthProvider.getTransaction = async () => mockTransaction;
            const result = await service.upload(testData, {
                onPieceAdded: (transaction) => {
                    pieceAddedCallbackFired = true;
                    pieceAddedTransaction = transaction;
                },
            });
            assert.isTrue(pieceAddedCallbackFired, 'onPieceAdded should have been called');
            assert.isUndefined(pieceAddedTransaction, 'Transaction should be undefined for old servers');
            assert.equal(result.pieceId, 0);
        });
        it('should handle ArrayBuffer input', async () => {
            const mockWarmStorageService = {
                getAddPiecesInfo: async () => ({
                    nextPieceId: 0,
                    clientDataSetId: 1,
                    currentPieceCount: 0,
                }),
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const buffer = new ArrayBuffer(1024);
            const view = new Uint8Array(buffer);
            for (let i = 0; i < view.length; i++) {
                view[i] = i % 256;
            }
            const testPieceCID = 'bafkzcibeqcad6efnpwn62p5vvs5x3nh3j7xkzfgb3xtitcdm2hulmty3xx4tl3wace';
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async (data) => {
                assert.instanceOf(data, Uint8Array);
                assert.equal(data.length, 1024);
                return { pieceCid: testPieceCID, size: data.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                return { uuid: 'test-uuid' };
            };
            const mockTxHash8 = `0x${'8'.repeat(64)}`;
            serviceAny._pdpServer.addPieces = async (_dataSetId, _clientDataSetId, nextPieceId) => {
                const pieceIds = [nextPieceId];
                serviceAny._pdpServer._lastPieceIds = pieceIds;
                return {
                    message: 'success',
                    txHash: mockTxHash8,
                };
            };
            serviceAny._pdpServer.getPieceAdditionStatus = async () => {
                const pieceIds = serviceAny._pdpServer._lastPieceIds || [];
                return {
                    txStatus: 'confirmed',
                    addMessageOk: true,
                    confirmedPieceIds: pieceIds,
                };
            };
            const mockTransaction = {
                hash: mockTxHash8,
                wait: async () => ({ status: 1, blockNumber: 12345 }),
            };
            mockEthProvider.getTransaction = async () => mockTransaction;
            const result = await service.upload(buffer);
            assert.equal(result.pieceCid.toString(), testPieceCID);
            assert.equal(result.size, 1024);
        });
        it.skip('should handle piece parking timeout', async () => {
            const mockWarmStorageService = {};
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const testData = new Uint8Array(127).fill(42);
            const testPieceCID = 'bafkzcibeqcad6efnpwn62p5vvs5x3nh3j7xkzfgb3xtitcdm2hulmty3xx4tl3wace';
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async () => {
                return { pieceCid: testPieceCID, size: testData.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                throw new Error('Piece not found');
            };
            const originalTimeout = service.constructor.PIECE_PARKING_TIMEOUT_MS;
            Object.defineProperty(service.constructor, 'PIECE_PARKING_TIMEOUT_MS', {
                value: 100,
                configurable: true,
            });
            try {
                await service.upload(testData);
                assert.fail('Should have thrown timeout error');
            }
            catch (error) {
                assert.include(error.message, 'Timeout waiting for piece to be parked');
            }
            finally {
                Object.defineProperty(service.constructor, 'PIECE_PARKING_TIMEOUT_MS', {
                    value: originalTimeout,
                    configurable: true,
                });
            }
        });
        it('should handle upload piece failure', async () => {
            const mockWarmStorageService = {
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const testData = new Uint8Array(127).fill(42);
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async () => {
                throw new Error('Network error during upload');
            };
            try {
                await service.upload(testData);
                assert.fail('Should have thrown upload error');
            }
            catch (error) {
                assert.include(error.message, 'Failed to upload piece to service provider');
            }
        });
        it('should handle add pieces failure', async () => {
            const mockWarmStorageService = {
                getAddPiecesInfo: async () => ({
                    nextPieceId: 0,
                    clientDataSetId: 1,
                    currentPieceCount: 0,
                }),
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const testData = new Uint8Array(127).fill(42);
            const testPieceCID = 'bafkzcibeqcad6efnpwn62p5vvs5x3nh3j7xkzfgb3xtitcdm2hulmty3xx4tl3wace';
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async () => {
                return { pieceCid: testPieceCID, size: testData.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                return { uuid: 'test-uuid' };
            };
            mockAddPieces(serviceAny, {
                shouldFail: true,
                failureMessage: 'Signature validation failed',
            });
            try {
                await service.upload(testData);
                assert.fail('Should have thrown add pieces error');
            }
            catch (error) {
                assert.include(error.message, 'Failed to add piece to data set');
            }
        });
        it('should handle getAddPiecesInfo failure', async () => {
            const mockWarmStorageService = {
                getAddPiecesInfo: async () => {
                    throw new Error('Data set not managed by this WarmStorage');
                },
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const testData = new Uint8Array(127).fill(42);
            const testPieceCID = 'bafkzcibeqcad6efnpwn62p5vvs5x3nh3j7xkzfgb3xtitcdm2hulmty3xx4tl3wace';
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async () => {
                return { pieceCid: testPieceCID, size: testData.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                return { uuid: 'test-uuid' };
            };
            try {
                await service.upload(testData);
                assert.fail('Should have thrown getAddPiecesInfo error');
            }
            catch (error) {
                assert.include(error.message, 'Failed to add piece to data set');
            }
        });
    });
    describe('Provider Ping Validation', () => {
        describe('selectRandomProvider with ping validation', () => {
            it('should select first provider that responds to ping', async () => {
                const testProviders = [
                    createSimpleProvider({
                        serviceProvider: '0x1111111111111111111111111111111111111111',
                        serviceURL: 'https://pdp1.example.com',
                    }),
                    createSimpleProvider({
                        serviceProvider: '0x2222222222222222222222222222222222222222',
                        serviceURL: 'https://pdp2.example.com',
                    }),
                ];
                let pingCallCount = 0;
                const originalFetch = global.fetch;
                global.fetch = async (input) => {
                    const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                    if (url.includes('/ping')) {
                        pingCallCount++;
                        if (url.includes('pdp1.example.com')) {
                            return {
                                status: 500,
                                statusText: 'Internal Server Error',
                                text: async () => 'Down',
                            };
                        }
                        else if (url.includes('pdp2.example.com')) {
                            return { status: 200, statusText: 'OK' };
                        }
                    }
                    throw new Error(`Unexpected URL: ${url}`);
                };
                try {
                    const result = await StorageContext.selectRandomProvider(testProviders);
                    assert.equal(result.serviceProvider, testProviders[1].serviceProvider);
                    assert.isAtLeast(pingCallCount, 1, 'Should have called ping at least once');
                }
                finally {
                    global.fetch = originalFetch;
                }
            });
            it('should throw error when all providers fail ping', async () => {
                const testProviders = [
                    createSimpleProvider({
                        serviceProvider: '0x1111111111111111111111111111111111111111',
                        serviceURL: 'https://pdp1.example.com',
                    }),
                    createSimpleProvider({
                        serviceProvider: '0x2222222222222222222222222222222222222222',
                        serviceURL: 'https://pdp2.example.com',
                    }),
                ];
                const originalFetch = global.fetch;
                global.fetch = async () => {
                    return {
                        status: 500,
                        statusText: 'Internal Server Error',
                        text: async () => 'All servers down',
                    };
                };
                try {
                    await StorageContext.selectRandomProvider(testProviders);
                    assert.fail('Should have thrown error');
                }
                catch (error) {
                    assert.include(error.message, 'StorageContext selectProviderWithPing failed');
                    assert.include(error.message, 'All 2 providers failed health check');
                }
                finally {
                    global.fetch = originalFetch;
                }
            });
        });
        describe.skip('smartSelectProvider with ping validation', () => {
            it.skip('should fail when existing providers fail ping validation', async () => {
                const testProviders = [
                    createSimpleProvider({
                        serviceProvider: '0x1111111111111111111111111111111111111111',
                        serviceURL: 'https://pdp1.example.com',
                    }),
                    createSimpleProvider({
                        serviceProvider: '0x2222222222222222222222222222222222222222',
                        serviceURL: 'https://pdp2.example.com',
                    }),
                ];
                const dataSets = [
                    {
                        railId: 1,
                        payer: '0x1234567890123456789012345678901234567890',
                        payee: testProviders[0].serviceProvider,
                        pdpVerifierDataSetId: 100,
                        nextPieceId: 0,
                        currentPieceCount: 0,
                        isLive: true,
                        isManaged: true,
                        withCDN: false,
                        commissionBps: 0,
                        metadata: {},
                        pieceMetadata: [],
                        clientDataSetId: 1,
                    },
                ];
                const mockWarmStorageService = {
                    getClientDataSetsWithDetails: async () => dataSets,
                    getAllApprovedProviders: async () => testProviders,
                    getProviderIdByAddress: async (address) => {
                        const idx = testProviders.findIndex((p) => p.serviceProvider.toLowerCase() === address.toLowerCase());
                        return idx >= 0 ? idx + 1 : 0;
                    },
                    getApprovedProvider: async (id) => testProviders[id - 1] ?? null,
                    getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
                };
                let pingCallCount = 0;
                const originalFetch = global.fetch;
                global.fetch = async (input) => {
                    const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                    if (url.includes('/ping')) {
                        pingCallCount++;
                        return {
                            status: 500,
                            statusText: 'Internal Server Error',
                            text: async () => 'Down',
                        };
                    }
                    throw new Error(`Unexpected URL: ${url}`);
                };
                try {
                    await StorageContext.smartSelectProvider('0x1234567890123456789012345678901234567890', false, mockWarmStorageService);
                    assert.fail('Should have thrown error');
                }
                catch (error) {
                    assert.include(error.message, 'StorageContext selectProviderWithPing failed');
                    assert.include(error.message, 'All 1 providers failed health check');
                    assert.isAtLeast(pingCallCount, 1, 'Should have pinged the provider from existing data set');
                }
                finally {
                    global.fetch = originalFetch;
                }
            });
            it.skip('should select provider when no existing providers are available', async () => {
                const testProviders = [
                    createSimpleProvider({
                        serviceProvider: '0x1111111111111111111111111111111111111111',
                        serviceURL: 'https://pdp1.example.com',
                    }),
                    createSimpleProvider({
                        serviceProvider: '0x2222222222222222222222222222222222222222',
                        serviceURL: 'https://pdp2.example.com',
                    }),
                ];
                const mockWarmStorageService = {
                    getClientDataSetsWithDetails: async () => [],
                    getAllApprovedProviders: async () => testProviders,
                    getProviderIdByAddress: async () => 0,
                    getApprovedProvider: async () => null,
                    getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
                };
                let pingCallCount = 0;
                const originalFetch = global.fetch;
                global.fetch = async (input) => {
                    const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                    if (url.includes('/ping')) {
                        pingCallCount++;
                        if (url.includes('pdp1.example.com')) {
                            return { status: 200, statusText: 'OK' };
                        }
                        return { status: 500, statusText: 'Internal Server Error' };
                    }
                    throw new Error(`Unexpected URL: ${url}`);
                };
                try {
                    const mockSigner = {
                        getAddress: async () => '0x1234567890123456789012345678901234567890',
                    };
                    const result = await StorageContext.smartSelectProvider('0x1234567890123456789012345678901234567890', false, mockWarmStorageService, mockSigner);
                    assert.isTrue(testProviders.some((p) => p.serviceProvider === result.provider.serviceProvider), 'Should have selected one of the available providers');
                    assert.equal(result.dataSetId, -1);
                    assert.isFalse(result.isExisting);
                    assert.isAtLeast(pingCallCount, 1, 'Should have pinged at least one provider');
                }
                finally {
                    global.fetch = originalFetch;
                }
            });
            it('should use existing provider if ping succeeds', async () => {
                const testProvider = createSimpleProvider({
                    serviceProvider: '0x1111111111111111111111111111111111111111',
                    serviceURL: 'https://pdp1.example.com',
                });
                const dataSets = [
                    {
                        railId: 1,
                        payer: '0x1234567890123456789012345678901234567890',
                        payee: testProvider.serviceProvider,
                        pdpVerifierDataSetId: 100,
                        nextPieceId: 0,
                        currentPieceCount: 5,
                        isLive: true,
                        isManaged: true,
                        withCDN: false,
                        commissionBps: 0,
                        metadata: {},
                        pieceMetadata: [],
                        clientDataSetId: 1,
                    },
                ];
                const mockWarmStorageService = {
                    getClientDataSetsWithDetails: async () => dataSets,
                    getProviderIdByAddress: async () => 1,
                    getApprovedProvider: async () => testProvider,
                    getAllApprovedProviders: async () => [],
                    getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
                };
                const originalFetch = global.fetch;
                global.fetch = async (input) => {
                    const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                    if (url.includes('/ping')) {
                        return { status: 200, statusText: 'OK' };
                    }
                    throw new Error(`Unexpected URL: ${url}`);
                };
                try {
                    const mockSigner = {
                        getAddress: async () => '0x1234567890123456789012345678901234567890',
                    };
                    const result = await StorageContext.smartSelectProvider('0x1234567890123456789012345678901234567890', false, mockWarmStorageService, mockSigner);
                    assert.equal(result.provider.serviceProvider, testProvider.serviceProvider);
                    assert.equal(result.dataSetId, 100);
                    assert.isTrue(result.isExisting);
                }
                finally {
                    global.fetch = originalFetch;
                }
            });
        });
        describe.skip('selectProviderWithPing', () => {
            it('should deduplicate providers from multiple data sets', async () => {
                const testProvider = createSimpleProvider({
                    serviceProvider: '0x1111111111111111111111111111111111111111',
                    serviceURL: 'https://pdp1.example.com',
                });
                const dataSets = [
                    {
                        railId: 1,
                        payer: '0x1234567890123456789012345678901234567890',
                        payee: testProvider.serviceProvider,
                        pdpVerifierDataSetId: 100,
                        nextPieceId: 0,
                        currentPieceCount: 5,
                        isLive: true,
                        isManaged: true,
                        withCDN: false,
                        commissionBps: 0,
                        metadata: {},
                        pieceMetadata: [],
                        clientDataSetId: 1,
                    },
                    {
                        railId: 2,
                        payer: '0x1234567890123456789012345678901234567890',
                        payee: testProvider.serviceProvider,
                        pdpVerifierDataSetId: 101,
                        nextPieceId: 0,
                        currentPieceCount: 3,
                        isLive: true,
                        isManaged: true,
                        withCDN: false,
                        commissionBps: 0,
                        metadata: {},
                        pieceMetadata: [],
                        clientDataSetId: 2,
                    },
                    {
                        railId: 3,
                        payer: '0x1234567890123456789012345678901234567890',
                        payee: testProvider.serviceProvider,
                        pdpVerifierDataSetId: 102,
                        nextPieceId: 0,
                        currentPieceCount: 1,
                        isLive: true,
                        isManaged: true,
                        withCDN: false,
                        commissionBps: 0,
                        metadata: {},
                        pieceMetadata: [],
                        clientDataSetId: 3,
                    },
                ];
                const mockWarmStorageService = {
                    getClientDataSetsWithDetails: async () => dataSets,
                    getProviderIdByAddress: async () => 1,
                    getApprovedProvider: async () => testProvider,
                    getAllApprovedProviders: async () => [],
                    getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
                };
                let pingCount = 0;
                const originalFetch = global.fetch;
                global.fetch = async (input) => {
                    const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                    if (url.includes('/ping')) {
                        pingCount++;
                        return {
                            status: 500,
                            statusText: 'Internal Server Error',
                            text: async () => 'Server error',
                        };
                    }
                    throw new Error(`Unexpected URL: ${url}`);
                };
                try {
                    await StorageContext.smartSelectProvider('0x1234567890123456789012345678901234567890', false, mockWarmStorageService);
                    assert.fail('Should have thrown error');
                }
                catch (error) {
                    assert.equal(pingCount, 1, 'Should only ping each unique provider once');
                    assert.include(error.message, 'All 1 providers failed health check');
                }
                finally {
                    global.fetch = originalFetch;
                }
            });
        });
    });
    describe('getProviderInfo', () => {
        it('should return provider info through WarmStorageService', async () => {
            const expectedProviderInfo = createSimpleProvider({
                serviceProvider: mockProvider.serviceProvider,
                serviceURL: 'https://updated-pdp.example.com',
            });
            const mockSynapseWithProvider = {
                ...mockSynapse,
                getProviderInfo: async (address) => {
                    assert.equal(address, mockProvider.serviceProvider);
                    return expectedProviderInfo;
                },
            };
            const mockWarmStorageService = {};
            const service = new StorageContext(mockSynapseWithProvider, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const providerInfo = await service.getProviderInfo();
            assert.deepEqual(providerInfo, expectedProviderInfo);
        });
        it('should handle errors from Synapse getProviderInfo', async () => {
            const mockSynapseWithError = {
                ...mockSynapse,
                getProviderInfo: async () => {
                    throw new Error('Provider not found');
                },
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const mockWarmStorageService = {};
            const service = new StorageContext(mockSynapseWithError, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            try {
                await service.getProviderInfo();
                assert.fail('Should have thrown');
            }
            catch (error) {
                assert.include(error.message, 'Provider not found');
            }
        });
    });
    describe('getDataSetPieces', () => {
        it('should successfully fetch data set pieces', async () => {
            const mockWarmStorageService = {
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const mockDataSetData = {
                id: 292,
                pieces: [
                    {
                        pieceId: 101,
                        pieceCid: 'bafkzcibcd4bdomn3tgwgrh3g532zopskstnbrd2n3sxfqbze7rxt7vqn7veigmy',
                        subPieceCid: 'bafkzcibcd4bdomn3tgwgrh3g532zopskstnbrd2n3sxfqbze7rxt7vqn7veigmy',
                        subPieceOffset: 0,
                    },
                    {
                        pieceId: 102,
                        pieceCid: 'bafkzcibeqcad6efnpwn62p5vvs5x3nh3j7xkzfgb3xtitcdm2hulmty3xx4tl3wace',
                        subPieceCid: 'bafkzcibeqcad6efnpwn62p5vvs5x3nh3j7xkzfgb3xtitcdm2hulmty3xx4tl3wace',
                        subPieceOffset: 0,
                    },
                ],
                nextChallengeEpoch: 1500,
            };
            const serviceAny = service;
            serviceAny._pdpServer.getDataSet = async (dataSetId) => {
                assert.equal(dataSetId, 123);
                return mockDataSetData;
            };
            const result = await service.getDataSetPieces();
            assert.isArray(result);
            assert.equal(result.length, 2);
            assert.equal(result[0].toString(), mockDataSetData.pieces[0].pieceCid);
            assert.equal(result[1].toString(), mockDataSetData.pieces[1].pieceCid);
        });
        it('should handle empty data set pieces', async () => {
            const mockWarmStorageService = {
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const mockDataSetData = {
                id: 292,
                pieces: [],
                nextChallengeEpoch: 1500,
            };
            const serviceAny = service;
            serviceAny._pdpServer.getDataSet = async () => {
                return mockDataSetData;
            };
            const result = await service.getDataSetPieces();
            assert.isArray(result);
            assert.equal(result.length, 0);
        });
        it('should handle invalid CID in response', async () => {
            const mockWarmStorageService = {
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const mockDataSetData = {
                id: 292,
                pieces: [
                    {
                        pieceId: 101,
                        pieceCid: 'invalid-cid-format',
                        subPieceCid: 'bafkzcibeqcad6efnpwn62p5vvs5x3nh3j7xkzfgb3xtitcdm2hulmty3xx4tl3wace',
                        subPieceOffset: 0,
                    },
                ],
                nextChallengeEpoch: 1500,
            };
            const serviceAny = service;
            serviceAny._pdpServer.getDataSet = async () => {
                return mockDataSetData;
            };
            const result = await service.getDataSetPieces();
            assert.isArray(result);
            assert.equal(result.length, 1);
            assert.equal(result[0].toString(), 'invalid-cid-format');
        });
        it('should handle PDP server errors', async () => {
            const mockWarmStorageService = {
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const serviceAny = service;
            serviceAny._pdpServer.getDataSet = async () => {
                throw new Error('Data set not found: 999');
            };
            try {
                await service.getDataSetPieces();
                assert.fail('Should have thrown error for server error');
            }
            catch (error) {
                assert.include(error.message, 'Data set not found: 999');
            }
        });
    });
    describe('pieceStatus()', () => {
        const mockPieceCID = 'bafkzcibeqcad6efnpwn62p5vvs5x3nh3j7xkzfgb3xtitcdm2hulmty3xx4tl3wace';
        it('should return exists=false when piece not found on provider', async () => {
            const mockWarmStorageService = {
                getMaxProvingPeriod: async () => 2880,
                getChallengeWindow: async () => 60,
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const serviceAny = service;
            serviceAny._pdpServer.findPiece = async () => {
                throw new Error('Piece not found');
            };
            serviceAny._pdpServer.getDataSet = async () => ({
                id: 123,
                pieces: [],
                nextChallengeEpoch: 5000,
            });
            mockEthProvider.getBlockNumber = async () => 4000;
            const mockSynapseAny = mockSynapse;
            mockSynapseAny.getNetwork = () => 'calibration';
            const status = await service.pieceStatus(mockPieceCID);
            assert.isFalse(status.exists);
            assert.isNull(status.retrievalUrl);
            assert.isNull(status.dataSetLastProven);
            assert.isNull(status.dataSetNextProofDue);
        });
        it('should return piece status with proof timing when piece exists', async () => {
            const mockWarmStorageService = {
                getMaxProvingPeriod: async () => 2880,
                getChallengeWindow: async () => 60,
                getCurrentProvingParams: async () => ({
                    maxProvingPeriod: 2880,
                    challengeWindow: 60,
                }),
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const serviceAny = service;
            serviceAny._pdpServer.findPiece = async () => ({ uuid: 'test-uuid' });
            serviceAny._pdpServer.getDataSet = async () => ({
                id: 123,
                pieces: [
                    {
                        pieceId: 1,
                        pieceCid: { toString: () => mockPieceCID },
                    },
                ],
                nextChallengeEpoch: 5000,
            });
            const mockSynapseAny = mockSynapse;
            mockEthProvider.getBlockNumber = async () => 4000;
            mockSynapseAny.getNetwork = () => 'calibration';
            mockSynapseAny.getProviderInfo = async () => mockProvider;
            const status = await service.pieceStatus(mockPieceCID);
            assert.isTrue(status.exists);
            assert.equal(status.retrievalUrl, `https://pdp.example.com/piece/${mockPieceCID}`);
            assert.isNotNull(status.dataSetLastProven);
            assert.isNotNull(status.dataSetNextProofDue);
            assert.isFalse(status.inChallengeWindow);
            assert.isFalse(status.isProofOverdue);
        });
        it('should detect when in challenge window', async () => {
            const mockWarmStorageService = {
                getMaxProvingPeriod: async () => 2880,
                getChallengeWindow: async () => 60,
                getCurrentProvingParams: async () => ({
                    maxProvingPeriod: 2880,
                    challengeWindow: 60,
                }),
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const serviceAny = service;
            serviceAny._pdpServer.findPiece = async () => ({ uuid: 'test-uuid' });
            serviceAny._pdpServer.getDataSet = async () => ({
                id: 123,
                pieces: [
                    {
                        pieceId: 1,
                        pieceCid: { toString: () => mockPieceCID },
                    },
                ],
                nextChallengeEpoch: 5000,
            });
            mockEthProvider.getBlockNumber = async () => 5030;
            const mockSynapseAny = mockSynapse;
            mockSynapseAny.getNetwork = () => 'calibration';
            mockSynapseAny.getProviderInfo = async () => mockProvider;
            const status = await service.pieceStatus(mockPieceCID);
            assert.isTrue(status.exists);
            assert.isTrue(status.inChallengeWindow);
            assert.isFalse(status.isProofOverdue);
        });
        it('should detect when proof is overdue', async () => {
            const mockWarmStorageService = {
                getMaxProvingPeriod: async () => 2880,
                getChallengeWindow: async () => 60,
                getCurrentProvingParams: async () => ({
                    maxProvingPeriod: 2880,
                    challengeWindow: 60,
                }),
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const serviceAny = service;
            serviceAny._pdpServer.findPiece = async () => ({ uuid: 'test-uuid' });
            serviceAny._pdpServer.getDataSet = async () => ({
                id: 123,
                pieces: [
                    {
                        pieceId: 1,
                        pieceCid: { toString: () => mockPieceCID },
                    },
                ],
                nextChallengeEpoch: 5000,
            });
            mockEthProvider.getBlockNumber = async () => 5100;
            const mockSynapseAny = mockSynapse;
            mockSynapseAny.getNetwork = () => 'calibration';
            mockSynapseAny.getProviderInfo = async () => mockProvider;
            const status = await service.pieceStatus(mockPieceCID);
            assert.isTrue(status.exists);
            assert.isTrue(status.isProofOverdue);
        });
        it('should handle data set with nextChallengeEpoch=0', async () => {
            const mockWarmStorageService = {
                getMaxProvingPeriod: async () => 2880,
                getChallengeWindow: async () => 60,
                getCurrentProvingParams: async () => ({
                    maxProvingPeriod: 2880,
                    challengeWindow: 60,
                }),
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const serviceAny = service;
            serviceAny._pdpServer.findPiece = async () => ({ uuid: 'test-uuid' });
            serviceAny._pdpServer.getDataSet = async () => ({
                id: 123,
                pieces: [
                    {
                        pieceId: 1,
                        pieceCid: { toString: () => mockPieceCID },
                    },
                ],
                nextChallengeEpoch: 0,
            });
            mockEthProvider.getBlockNumber = async () => 5000;
            const mockSynapseAny = mockSynapse;
            mockSynapseAny.getNetwork = () => 'calibration';
            mockSynapseAny.getProviderInfo = async () => mockProvider;
            const status = await service.pieceStatus(mockPieceCID);
            assert.isTrue(status.exists);
            assert.isNull(status.dataSetLastProven);
            assert.isNull(status.dataSetNextProofDue);
            assert.isFalse(status.inChallengeWindow);
        });
        it('should handle trailing slash in retrieval URL', async () => {
            const mockProviderWithSlash = {
                ...mockProvider,
            };
            const mockWarmStorageService = {
                getMaxProvingPeriod: async () => 2880,
                getChallengeWindow: async () => 60,
                getCurrentProvingParams: async () => ({
                    maxProvingPeriod: 2880,
                    challengeWindow: 60,
                }),
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProviderWithSlash, 123, {
                withCDN: false,
            }, {});
            const serviceAny = service;
            serviceAny._pdpServer.findPiece = async () => ({ uuid: 'test-uuid' });
            serviceAny._pdpServer.getDataSet = async () => ({
                id: 123,
                pieces: [],
                nextChallengeEpoch: 5000,
            });
            const mockSynapseAny = mockSynapse;
            mockEthProvider.getBlockNumber = async () => 4000;
            mockSynapseAny.getNetwork = () => 'calibration';
            mockSynapseAny.getProviderInfo = async (address) => {
                if (address === mockProviderWithSlash.serviceProvider) {
                    return mockProviderWithSlash;
                }
                throw new Error('Provider not found');
            };
            const status = await service.pieceStatus(mockPieceCID);
            assert.isTrue(status.exists);
            assert.equal(status.retrievalUrl, `https://pdp.example.com/piece/${mockPieceCID}`);
            const urlWithoutProtocol = (status.retrievalUrl ?? '').substring(8);
            assert.notInclude(urlWithoutProtocol, '//');
        });
        it('should handle invalid PieceCID', async () => {
            const mockWarmStorageService = {};
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            try {
                await service.pieceStatus('invalid-pieceCid');
                assert.fail('Should have thrown error for invalid PieceCID');
            }
            catch (error) {
                assert.include(error.message, 'Invalid PieceCID provided');
            }
        });
        it('should calculate hours until challenge window', async () => {
            const mockWarmStorageService = {
                getMaxProvingPeriod: async () => 2880,
                getChallengeWindow: async () => 60,
                getCurrentProvingParams: async () => ({
                    maxProvingPeriod: 2880,
                    challengeWindow: 60,
                }),
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const serviceAny = service;
            serviceAny._pdpServer.findPiece = async () => ({ uuid: 'test-uuid' });
            serviceAny._pdpServer.getDataSet = async () => ({
                id: 123,
                pieces: [
                    {
                        pieceId: 1,
                        pieceCid: { toString: () => mockPieceCID },
                    },
                ],
                nextChallengeEpoch: 5000,
            });
            mockEthProvider.getBlockNumber = async () => 4880;
            const mockSynapseAny = mockSynapse;
            mockSynapseAny.getNetwork = () => 'calibration';
            mockSynapseAny.getProviderInfo = async () => mockProvider;
            const status = await service.pieceStatus(mockPieceCID);
            assert.isTrue(status.exists);
            assert.isFalse(status.inChallengeWindow);
            assert.isTrue((status.hoursUntilChallengeWindow ?? 0) > 0);
        });
        it('should handle data set data fetch failure gracefully', async () => {
            const mockWarmStorageService = {
                getMaxProvingPeriod: async () => 2880,
                getChallengeWindow: async () => 60,
                getCurrentProvingParams: async () => ({
                    maxProvingPeriod: 2880,
                    challengeWindow: 60,
                }),
                getServiceProviderRegistryAddress: () => '0x0000000000000000000000000000000000000001',
            };
            const service = new StorageContext(mockSynapse, mockWarmStorageService, mockProvider, 123, {
                withCDN: false,
            }, {});
            const serviceAny = service;
            serviceAny._pdpServer.findPiece = async () => ({ uuid: 'test-uuid' });
            serviceAny._pdpServer.getDataSet = async () => {
                throw new Error('Network error');
            };
            const mockSynapseAny = mockSynapse;
            mockEthProvider.getBlockNumber = async () => 4000;
            mockSynapseAny.getNetwork = () => 'calibration';
            mockSynapseAny.getProviderInfo = async () => mockProvider;
            const status = await service.pieceStatus(mockPieceCID);
            assert.isTrue(status.exists);
            assert.isNotNull(status.retrievalUrl);
            assert.isNull(status.dataSetLastProven);
            assert.isNull(status.dataSetNextProofDue);
            assert.isUndefined(status.pieceId);
        });
    });
});
//# sourceMappingURL=storage.test.js.map