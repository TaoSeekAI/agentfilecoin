import { assert } from 'chai';
import { ethers } from 'ethers';
import { SPRegistryService } from "../sp-registry/service.js";
import { PRODUCTS } from "../sp-registry/types.js";
import { SIZE_CONSTANTS } from "../utils/constants.js";
describe('SPRegistryService', () => {
    let mockProvider;
    let mockSigner;
    let service;
    const mockRegistryAddress = '0x1234567890123456789012345678901234567890';
    const mockProviderAddress = '0xabcdef1234567890123456789012345678901234';
    const createMockContract = () => {
        return {
            getProviderIdByAddress: async (address) => {
                if (address.toLowerCase() === mockProviderAddress.toLowerCase()) {
                    return BigInt(1);
                }
                return BigInt(0);
            },
            getProviderByAddress: async (address) => {
                if (address.toLowerCase() === mockProviderAddress.toLowerCase()) {
                    return {
                        serviceProvider: mockProviderAddress,
                        payee: mockProviderAddress,
                        name: 'Test Provider',
                        description: 'A test storage provider',
                        isActive: true,
                    };
                }
                return {
                    serviceProvider: ethers.ZeroAddress,
                    payee: ethers.ZeroAddress,
                    name: '',
                    description: '',
                    isActive: false,
                };
            },
            getProvider: async (id) => {
                if (id === 1) {
                    return {
                        id: BigInt(1),
                        serviceProvider: mockProviderAddress,
                        payee: mockProviderAddress,
                        name: 'Test Provider',
                        description: 'A test storage provider',
                        isActive: true,
                    };
                }
                throw new Error('Provider not found');
            },
            getProviderProducts: async (id) => {
                if (id === 1) {
                    return [
                        {
                            productType: 0,
                            isActive: true,
                            capabilityKeys: [],
                            productData: '0x',
                        },
                    ];
                }
                return [];
            },
            providerHasProduct: async (id, productType) => {
                return id === 1 && productType === 0;
            },
            getPDPService: async (id) => {
                if (id === 1) {
                    return {
                        offering: {
                            serviceURL: 'https://provider.example.com',
                            minPieceSizeInBytes: SIZE_CONSTANTS.KiB,
                            maxPieceSizeInBytes: SIZE_CONSTANTS.GiB,
                            ipniPiece: true,
                            ipniIpfs: false,
                            storagePricePerTibPerMonth: BigInt(1000000),
                            minProvingPeriodInEpochs: 2880,
                            location: 'US-EAST',
                            paymentTokenAddress: '0x0000000000000000000000000000000000000000',
                        },
                        capabilities: [],
                        isActive: true,
                    };
                }
                return null;
            },
            encodePDPOffering: async (_offering) => {
                return `0x${'a'.repeat(64)}`;
            },
            decodePDPOffering: async (_data) => {
                return {
                    serviceURL: 'https://provider.example.com',
                    minPieceSizeInBytes: SIZE_CONSTANTS.KiB,
                    maxPieceSizeInBytes: SIZE_CONSTANTS.GiB,
                    ipniPiece: true,
                    ipniIpfs: false,
                    storagePricePerTibPerMonth: BigInt(1000000),
                    minProvingPeriodInEpochs: 2880,
                    location: 'US-EAST',
                    paymentTokenAddress: '0x0000000000000000000000000000000000000000',
                };
            },
            getAllActiveProviders: async (offset, _limit) => {
                if (offset === 0) {
                    return [[BigInt(1)], false];
                }
                return [[], false];
            },
            getProviderCount: async () => BigInt(1),
            isProviderActive: async (id) => id === 1,
            isRegisteredProvider: async (address) => {
                return address.toLowerCase() === mockProviderAddress.toLowerCase();
            },
            REGISTRATION_FEE: async () => BigInt(0),
            registerProvider: async (_payee, _name, _description, _productType, _productData, _capabilityKeys, _capabilityValues, _options) => {
                return {
                    hash: `0x${'1'.repeat(64)}`,
                    wait: async () => ({
                        status: 1,
                        blockNumber: 12345,
                    }),
                };
            },
            updateProviderInfo: async (_name, _description) => {
                return {
                    hash: `0x${'2'.repeat(64)}`,
                    wait: async () => ({
                        status: 1,
                        blockNumber: 12346,
                    }),
                };
            },
            removeProvider: async () => {
                return {
                    hash: `0x${'3'.repeat(64)}`,
                    wait: async () => ({
                        status: 1,
                        blockNumber: 12347,
                    }),
                };
            },
            addProduct: async (_productType, _data) => {
                return {
                    hash: `0x${'5'.repeat(64)}`,
                    wait: async () => ({
                        status: 1,
                        blockNumber: 12349,
                    }),
                };
            },
            updateProduct: async (_index, _data) => {
                return {
                    hash: `0x${'6'.repeat(64)}`,
                    wait: async () => ({
                        status: 1,
                        blockNumber: 12350,
                    }),
                };
            },
            removeProduct: async (_productType) => {
                return {
                    hash: `0x${'7'.repeat(64)}`,
                    wait: async () => ({
                        status: 1,
                        blockNumber: 12351,
                    }),
                };
            },
            connect: function (_signer) {
                return this;
            },
        };
    };
    beforeEach(() => {
        mockProvider = {
            getNetwork: async () => ({ chainId: BigInt(314159), name: 'calibration' }),
            call: async (_tx) => '0x',
        };
        mockSigner = {
            getAddress: async () => '0x9999999999999999999999999999999999999999',
            provider: mockProvider,
        };
        service = new SPRegistryService(mockProvider, mockRegistryAddress);
        service._getRegistryContract = () => createMockContract();
    });
    describe('Constructor', () => {
        it('should create instance with provider and address', () => {
            const instance = new SPRegistryService(mockProvider, mockRegistryAddress);
            assert.exists(instance);
        });
    });
    describe('Provider Read Operations', () => {
        it('should get provider by ID', async () => {
            const provider = await service.getProvider(1);
            assert.exists(provider);
            assert.equal(provider?.id, 1);
            assert.equal(provider?.serviceProvider, mockProviderAddress);
            assert.equal(provider?.name, 'Test Provider');
            assert.equal(provider?.description, 'A test storage provider');
            assert.isTrue(provider?.active);
        });
        it('should return null for non-existent provider', async () => {
            const provider = await service.getProvider(999);
            assert.isNull(provider);
        });
        it('should get provider by address', async () => {
            const provider = await service.getProviderByAddress(mockProviderAddress);
            assert.exists(provider);
            assert.equal(provider?.id, 1);
            assert.equal(provider?.serviceProvider, mockProviderAddress);
        });
        it('should return null for unregistered address', async () => {
            const provider = await service.getProviderByAddress('0x0000000000000000000000000000000000000000');
            assert.isNull(provider);
        });
        it('should get provider ID by address', async () => {
            const id = await service.getProviderIdByAddress(mockProviderAddress);
            assert.equal(id, 1);
        });
        it('should return 0 for unregistered address', async () => {
            const id = await service.getProviderIdByAddress('0x0000000000000000000000000000000000000000');
            assert.equal(id, 0);
        });
        it('should check if provider is active', async () => {
            const isActive = await service.isProviderActive(1);
            assert.isTrue(isActive);
            const isInactive = await service.isProviderActive(999);
            assert.isFalse(isInactive);
        });
        it('should check if address is registered provider', async () => {
            const isRegistered = await service.isRegisteredProvider(mockProviderAddress);
            assert.isTrue(isRegistered);
            const isNotRegistered = await service.isRegisteredProvider('0x0000000000000000000000000000000000000000');
            assert.isFalse(isNotRegistered);
        });
        it('should get provider count', async () => {
            const count = await service.getProviderCount();
            assert.equal(count, 1);
        });
    });
    describe('Provider Write Operations', () => {
        it('should register new provider', async () => {
            const tx = await service.registerProvider(mockSigner, {
                payee: '0x9999999999999999999999999999999999999999',
                name: 'New Provider',
                description: 'Description',
            });
            assert.exists(tx, 'Transaction should exist');
            assert.exists(tx.hash, 'Transaction should have a hash');
        });
        it('should update provider info', async () => {
            const tx = await service.updateProviderInfo(mockSigner, 'Updated Name', 'Updated Description');
            assert.exists(tx);
            assert.exists(tx.hash);
        });
        it('should remove provider', async () => {
            const tx = await service.removeProvider(mockSigner);
            assert.exists(tx);
            assert.exists(tx.hash);
        });
    });
    describe('Product Operations', () => {
        it.skip('should get provider products', async () => {
            const provider = await service.getProvider(1);
            assert.exists(provider);
            assert.exists(provider?.products);
            assert.exists(provider?.products.PDP);
            const product = provider?.products.PDP;
            assert.exists(product);
            assert.equal(product?.type, 'PDP');
            assert.isTrue(product?.isActive);
        });
        it.skip('should decode PDP product data', async () => {
            const provider = await service.getProvider(1);
            const product = provider?.products.PDP;
            assert.exists(product);
            assert.equal(product?.type, 'PDP');
            if (product?.type === 'PDP') {
                assert.equal(product.data.serviceURL, 'https://provider.example.com');
                assert.equal(product.data.minPieceSizeInBytes, SIZE_CONSTANTS.KiB);
                assert.equal(product.data.maxPieceSizeInBytes, SIZE_CONSTANTS.GiB);
                assert.isTrue(product.data.ipniPiece);
                assert.isFalse(product.data.ipniIpfs);
                assert.equal(product.data.location, 'US-EAST');
            }
        });
        it('should add new product', async () => {
            const pdpData = {
                serviceURL: 'https://new.example.com',
                minPieceSizeInBytes: SIZE_CONSTANTS.KiB,
                maxPieceSizeInBytes: SIZE_CONSTANTS.GiB,
                ipniPiece: true,
                ipniIpfs: false,
                storagePricePerTibPerMonth: BigInt(1000000),
                minProvingPeriodInEpochs: 2880,
                location: 'US-WEST',
                paymentTokenAddress: '0x0000000000000000000000000000000000000000',
            };
            const tx = await service.addPDPProduct(mockSigner, pdpData);
            assert.exists(tx);
            assert.exists(tx.hash);
        });
        it.skip('should update existing product', async () => {
            const pdpData = {
                serviceURL: 'https://updated.example.com',
                minPieceSizeInBytes: SIZE_CONSTANTS.KiB * 2n,
                maxPieceSizeInBytes: SIZE_CONSTANTS.GiB * 2n,
                ipniPiece: true,
                ipniIpfs: true,
                storagePricePerTibPerMonth: BigInt(2000000),
                minProvingPeriodInEpochs: 2880,
                location: 'EU-WEST',
                paymentTokenAddress: '0x0000000000000000000000000000000000000000',
            };
            const tx = await service.updatePDPProduct(mockSigner, pdpData);
            assert.exists(tx);
            assert.exists(tx.hash);
        });
        it('should remove product', async () => {
            const tx = await service.removeProduct(mockSigner, PRODUCTS.PDP);
            assert.exists(tx);
            assert.exists(tx.hash);
        });
    });
    describe('Batch Operations', () => {
        it('should get multiple providers in batch', async () => {
            const providers = await service.getProviders([1, 2, 3]);
            assert.isArray(providers);
            assert.equal(providers.length, 1);
            assert.exists(providers[0]);
            assert.equal(providers[0].id, 1);
        });
        it('should handle empty provider ID list', async () => {
            const providers = await service.getProviders([]);
            assert.isArray(providers);
            assert.equal(providers.length, 0);
        });
    });
    describe('Provider Info Conversion', () => {
        it.skip('should extract serviceURL from first PDP product', async () => {
            const provider = await service.getProvider(1);
            assert.exists(provider);
            assert.equal(provider?.products.PDP?.data.serviceURL, 'https://provider.example.com');
        });
        it('should handle provider without PDP products', async () => {
            ;
            service._getRegistryContract = () => ({
                ...createMockContract(),
                getProviderProducts: async () => [],
            });
            const provider = await service.getProvider(1);
            assert.exists(provider);
            assert.isUndefined(provider?.products.PDP);
        });
    });
    describe('Error Handling', () => {
        it.skip('should handle contract call failures gracefully', async () => {
            ;
            service._getRegistryContract = () => ({
                getProvider: async () => {
                    throw new Error('Contract call failed');
                },
            });
            const provider = await service.getProvider(1);
            assert.isNull(provider);
        });
        it.skip('should handle invalid product data', async () => {
            ;
            service._getRegistryContract = () => ({
                ...createMockContract(),
                decodePDPOffering: async () => {
                    throw new Error('Invalid data');
                },
            });
            const provider = await service.getProvider(1);
            assert.exists(provider);
            assert.exists(provider?.products);
            assert.isUndefined(provider?.products.PDP);
        });
    });
});
//# sourceMappingURL=sp-registry-service.test.js.map