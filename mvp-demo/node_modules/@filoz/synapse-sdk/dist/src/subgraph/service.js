import { fromHex, toHex } from 'multiformats/bytes';
import { CID } from 'multiformats/cid';
import { asPieceCID } from "../piece/index.js";
import { PRODUCTS } from "../sp-registry/types.js";
import { createError } from "../utils/errors.js";
import { QUERIES } from "./queries.js";
export class SubgraphService {
    endpoint;
    headers;
    constructor(subgraphConfig) {
        this.endpoint = this.resolveEndpoint(subgraphConfig);
        this.headers = this.buildHeaders(subgraphConfig.apiKey);
    }
    resolveEndpoint(config) {
        if (config.endpoint != null && config.endpoint.trim() !== '') {
            return config.endpoint.trim();
        }
        if (config.goldsky != null) {
            return this.buildGoldskyEndpoint(config.goldsky);
        }
        throw createError('SubgraphService', 'constructor', 'Invalid configuration: provide either endpoint or complete goldsky config');
    }
    buildGoldskyEndpoint(goldsky) {
        const { projectId, subgraphName, version } = goldsky;
        if (projectId?.trim() == null ||
            projectId?.trim() === '' ||
            subgraphName?.trim() == null ||
            subgraphName?.trim() === '' ||
            version?.trim() == null ||
            version?.trim() === '') {
            throw createError('SubgraphService', 'constructor', 'Incomplete Goldsky config: projectId, subgraphName, and version required');
        }
        return `https://api.goldsky.com/api/public/${projectId}/subgraphs/${subgraphName}/${version}/gn`;
    }
    buildHeaders(apiKey) {
        const headers = { 'Content-Type': 'application/json' };
        if (apiKey != null && apiKey !== '') {
            return { ...headers, Authorization: `Bearer ${apiKey}` };
        }
        return headers;
    }
    normalizeQueryOptions(options = {}) {
        return {
            where: {},
            first: 10,
            skip: 0,
            orderBy: 'createdAt',
            orderDirection: 'desc',
            ...options,
        };
    }
    async executeQuery(query, variables, operation) {
        try {
            const response = await fetch(this.endpoint, {
                method: 'POST',
                headers: this.headers,
                body: JSON.stringify({ query, variables }),
            });
            if (!response.ok) {
                const errorText = await response.text();
                throw createError('SubgraphService', operation, `HTTP ${response.status}: ${errorText}`);
            }
            const result = (await response.json());
            if (result.errors != null && result.errors.length > 0) {
                const errorMsg = result.errors.map((e) => e.message).join('; ');
                throw createError('SubgraphService', operation, `GraphQL errors: ${errorMsg}`);
            }
            return result.data;
        }
        catch (error) {
            if (error instanceof Error && error.name === 'SynapseError') {
                throw error;
            }
            throw createError('SubgraphService', operation, `Query execution failed: ${error.message}`, {
                cause: error,
            });
        }
    }
    getProductType(productType) {
        const entry = Object.entries(PRODUCTS).find(([, value]) => value === productType);
        return entry != null ? entry[0] : 'PDP';
    }
    transformProviderData(data) {
        const safeData = {
            providerId: data?.providerId ?? 0,
            serviceProvider: data?.serviceProvider ?? '',
            payee: data?.payee ?? '',
            name: data?.name ?? '',
            description: data?.description ?? '',
            status: data?.status ?? 'UNKNOWN',
            products: Array.isArray(data?.products) ? data.products : [],
        };
        return {
            id: safeData.providerId,
            serviceProvider: safeData.serviceProvider,
            payee: safeData.payee,
            name: safeData.name,
            description: safeData.description,
            active: safeData.status === 'APPROVED',
            products: this.transformProducts(safeData.products),
        };
    }
    transformProducts(products) {
        return products.reduce((productAcc, product) => {
            const productType = this.getProductType(product?.productType);
            const serviceProduct = this.createServiceProduct(product, productType);
            if (serviceProduct != null) {
                productAcc[productType] = serviceProduct;
            }
            return productAcc;
        }, {});
    }
    createServiceProduct(product, productType) {
        try {
            return {
                type: productType,
                isActive: product?.isActive ?? false,
                capabilities: this.transformCapabilities(product?.capabilityValues),
                data: this.parseProductData(product?.decodedProductData),
            };
        }
        catch (error) {
            console.warn(`SubgraphService: Failed to create service product for type ${productType}:`, error instanceof Error ? error.message : 'Unknown error');
            return null;
        }
    }
    transformCapabilities(capabilityValues) {
        if (!Array.isArray(capabilityValues)) {
            return {};
        }
        return capabilityValues.reduce((capabilityAcc, capability) => {
            if (capability?.key != null && capability?.value != null) {
                capabilityAcc[capability.key] = String(capability.value);
            }
            return capabilityAcc;
        }, {});
    }
    parseProductData(decodedProductData) {
        try {
            if (decodedProductData == null || decodedProductData.trim() === '') {
                throw new Error('Empty or null product data');
            }
            const parsed = JSON.parse(decodedProductData);
            if (parsed?.serviceURL == null) {
                throw new Error('Missing required serviceURL field');
            }
            return parsed;
        }
        catch (error) {
            console.warn(`SubgraphService: Failed to parse product data, using defaults:`, error instanceof Error ? error.message : 'Unknown error');
            return {
                serviceURL: '',
                minPieceSizeInBytes: 0n,
                maxPieceSizeInBytes: 0n,
                ipniPiece: false,
                ipniIpfs: false,
                storagePricePerTibPerMonth: 0n,
                minProvingPeriodInEpochs: 0,
                location: '',
                paymentTokenAddress: '',
            };
        }
    }
    parseTimestamp(value) {
        if (value == null)
            return 0;
        const parsed = Number(value);
        return Number.isNaN(parsed) ? 0 : parsed;
    }
    safeConvertHexToCid(hexCid) {
        try {
            const cleanHex = hexCid.startsWith('0x') ? hexCid.slice(2) : hexCid;
            const cidBytes = fromHex(cleanHex);
            const cid = CID.decode(cidBytes);
            const pieceCid = asPieceCID(cid);
            if (pieceCid == null) {
                throw new Error(`Failed to convert CID to PieceCID format: ${hexCid}`);
            }
            return pieceCid;
        }
        catch (error) {
            console.warn(`SubgraphService: queryProviders: Failed to convert CID to PieceCID format: ${error instanceof Error ? error.message : 'Unknown error'}`);
            return null;
        }
    }
    isValidProviderData(data) {
        return data?.id != null && data.id.trim() !== '' && data?.products != null && data.products.length > 0;
    }
    async getApprovedProvidersForPieceCID(pieceCid) {
        const pieceCidParsed = asPieceCID(pieceCid);
        if (pieceCidParsed == null) {
            throw createError('SubgraphService', 'getApprovedProvidersForPieceCID', 'Invalid PieceCID');
        }
        const hexPieceCid = toHex(pieceCidParsed.bytes);
        const data = await this.executeQuery(QUERIES.GET_APPROVED_PROVIDERS_FOR_PIECE_LINK, { cid: hexPieceCid }, 'getApprovedProvidersForPieceCID');
        if (data?.pieces == null || data.pieces.length === 0) {
            console.log(`SubgraphService: No providers found for PieceCID: ${pieceCidParsed.toString()}`);
            return [];
        }
        const uniqueProviderMap = data.pieces.reduce((acc, piece) => {
            const provider = piece.dataSet.serviceProvider;
            const address = provider?.serviceProvider?.toLowerCase();
            if (address == null || address === '' || acc.has(address)) {
                return acc;
            }
            if (!this.isValidProviderData(provider)) {
                console.warn('SubgraphService: Skipping incomplete provider data for approved provider:', provider);
                return acc;
            }
            acc.set(address, provider);
            return acc;
        }, new Map());
        return Array.from(uniqueProviderMap.values()).map((provider) => this.transformProviderData(provider));
    }
    async getProviderByAddress(address) {
        const data = await this.executeQuery(QUERIES.GET_PROVIDER_BY_ADDRESS, { serviceProvider: address }, 'getProviderByAddress');
        if (data?.provider == null) {
            console.log(`SubgraphService: No provider found for address: ${address}`);
            return null;
        }
        return this.transformProviderData(data.provider);
    }
    async queryProviders(options = {}) {
        const data = await this.executeQuery(QUERIES.GET_PROVIDERS_FLEXIBLE, this.normalizeQueryOptions(options), 'queryProviders');
        if (data?.providers == null || data?.providers?.length === 0) {
            console.log('SubgraphService: No providers found for the given criteria');
            return [];
        }
        return data.providers
            .filter((provider) => this.isValidProviderData(provider))
            .map((provider) => this.transformProviderData(provider));
    }
    async queryDataSets(options = {}) {
        const data = await this.executeQuery(QUERIES.GET_DATA_SETS_FLEXIBLE, this.normalizeQueryOptions(options), 'queryDataSets');
        if (data?.dataSets == null || data?.dataSets?.length === 0) {
            console.log('SubgraphService: No data sets found for the given criteria');
            return [];
        }
        return data.dataSets.map((dataSet) => ({
            id: dataSet.id,
            setId: this.parseTimestamp(dataSet.setId),
            listener: dataSet.listener ?? '',
            payer: dataSet.payer ?? '',
            withCDN: dataSet.withCDN ?? false,
            isActive: dataSet.isActive,
            leafCount: this.parseTimestamp(dataSet.leafCount),
            challengeRange: this.parseTimestamp(dataSet.challengeRange),
            lastProvenEpoch: this.parseTimestamp(dataSet.lastProvenEpoch),
            nextChallengeEpoch: this.parseTimestamp(dataSet.nextChallengeEpoch),
            totalPieces: this.parseTimestamp(dataSet.totalPieces),
            totalDataSize: this.parseTimestamp(dataSet.totalDataSize),
            totalProofs: this.parseTimestamp(dataSet.totalProofs),
            totalProvedPieces: this.parseTimestamp(dataSet.totalProvedPieces),
            totalFaultedPeriods: this.parseTimestamp(dataSet.totalFaultedPeriods),
            totalFaultedPieces: this.parseTimestamp(dataSet.totalFaultedPieces),
            metadataKeys: dataSet.metadataKeys ?? [],
            metadataValues: dataSet.metadataValues ?? [],
            createdAt: this.parseTimestamp(dataSet.createdAt),
            updatedAt: this.parseTimestamp(dataSet.updatedAt),
            serviceProvider: dataSet.serviceProvider != null
                ? this.transformProviderData(dataSet.serviceProvider)
                : this.transformProviderData({}),
            rails: dataSet.rails != null
                ? dataSet.rails.map((rail) => ({
                    id: rail.id,
                    type: rail.type,
                    railId: this.parseTimestamp(rail.railId),
                    token: rail.token,
                    paymentRate: this.parseTimestamp(rail.paymentRate),
                    settledUpto: this.parseTimestamp(rail.settledUpto),
                    endEpoch: this.parseTimestamp(rail.endEpoch),
                }))
                : undefined,
        }));
    }
    async queryPieces(options = {}) {
        const data = await this.executeQuery(QUERIES.GET_PIECES_FLEXIBLE, this.normalizeQueryOptions(options), 'queryPieces');
        if (data?.pieces == null || data?.pieces?.length === 0) {
            console.log('SubgraphService: No pieces found for the given criteria');
            return [];
        }
        return data.pieces.map((piece) => ({
            id: piece.id,
            setId: this.parseTimestamp(piece.setId),
            pieceId: this.parseTimestamp(piece.pieceId),
            rawSize: this.parseTimestamp(piece.rawSize),
            leafCount: this.parseTimestamp(piece.leafCount),
            cid: this.safeConvertHexToCid(piece.cid),
            removed: piece.removed,
            totalProofsSubmitted: this.parseTimestamp(piece.totalProofsSubmitted),
            totalPeriodsFaulted: this.parseTimestamp(piece.totalPeriodsFaulted),
            lastProvenEpoch: this.parseTimestamp(piece.lastProvenEpoch),
            lastProvenAt: this.parseTimestamp(piece.lastProvenAt),
            lastFaultedEpoch: this.parseTimestamp(piece.lastFaultedEpoch),
            lastFaultedAt: this.parseTimestamp(piece.lastFaultedAt),
            createdAt: this.parseTimestamp(piece.createdAt),
            metadataKeys: piece.metadataKeys ?? [],
            metadataValues: piece.metadataValues ?? [],
            dataSet: {
                id: piece.dataSet.id,
                setId: this.parseTimestamp(piece.dataSet.setId),
                isActive: piece.dataSet.isActive,
                serviceProvider: this.transformProviderData(piece.dataSet.serviceProvider),
            },
        }));
    }
    async queryFaultRecords(options = {}) {
        const data = await this.executeQuery(QUERIES.GET_FAULT_RECORDS_FLEXIBLE, this.normalizeQueryOptions(options), 'queryFaultRecords');
        if (data?.faultRecords == null || data?.faultRecords?.length === 0) {
            console.log('SubgraphService: No fault records found for the given criteria');
            return [];
        }
        return data.faultRecords.map((fault) => ({
            id: fault.id,
            dataSetId: this.parseTimestamp(fault.dataSetId),
            pieceIds: fault.pieceIds.map((id) => this.parseTimestamp(id)),
            currentChallengeEpoch: this.parseTimestamp(fault.currentChallengeEpoch),
            nextChallengeEpoch: this.parseTimestamp(fault.nextChallengeEpoch),
            periodsFaulted: this.parseTimestamp(fault.periodsFaulted),
            deadline: this.parseTimestamp(fault.deadline),
            createdAt: this.parseTimestamp(fault.createdAt),
            dataSet: {
                id: fault.dataSet.id,
                setId: this.parseTimestamp(fault.dataSet.setId),
                serviceProvider: this.transformProviderData(fault.dataSet.serviceProvider),
            },
        }));
    }
}
//# sourceMappingURL=service.js.map