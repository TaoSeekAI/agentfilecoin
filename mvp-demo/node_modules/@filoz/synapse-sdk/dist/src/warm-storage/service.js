import { ethers } from 'ethers';
import { PDPVerifier } from "../pdp/verifier.js";
import { CONTRACT_ADDRESSES, SIZE_CONSTANTS, TIME_CONSTANTS, TIMING_CONSTANTS } from "../utils/constants.js";
import { CONTRACT_ABIS, createError, getFilecoinNetworkType, TOKENS } from "../utils/index.js";
export class WarmStorageService {
    _provider;
    _warmStorageAddress;
    _warmStorageContract = null;
    _warmStorageViewContract = null;
    _pdpVerifier = null;
    _addresses;
    constructor(provider, warmStorageAddress, addresses) {
        this._provider = provider;
        this._warmStorageAddress = warmStorageAddress;
        this._addresses = addresses;
    }
    static async create(provider, warmStorageAddress) {
        const networkName = await getFilecoinNetworkType(provider);
        const multicall = new ethers.Contract(CONTRACT_ADDRESSES.MULTICALL3[networkName], CONTRACT_ABIS.MULTICALL3, provider);
        const iface = new ethers.Interface(CONTRACT_ABIS.WARM_STORAGE);
        const calls = [
            {
                target: warmStorageAddress,
                allowFailure: false,
                callData: iface.encodeFunctionData('pdpVerifierAddress'),
            },
            {
                target: warmStorageAddress,
                allowFailure: false,
                callData: iface.encodeFunctionData('paymentsContractAddress'),
            },
            {
                target: warmStorageAddress,
                allowFailure: false,
                callData: iface.encodeFunctionData('usdfcTokenAddress'),
            },
            {
                target: warmStorageAddress,
                allowFailure: false,
                callData: iface.encodeFunctionData('filCDNBeneficiaryAddress'),
            },
            {
                target: warmStorageAddress,
                allowFailure: false,
                callData: iface.encodeFunctionData('viewContractAddress'),
            },
            {
                target: warmStorageAddress,
                allowFailure: false,
                callData: iface.encodeFunctionData('serviceProviderRegistry'),
            },
            {
                target: warmStorageAddress,
                allowFailure: false,
                callData: iface.encodeFunctionData('sessionKeyRegistry'),
            },
        ];
        const results = await multicall.aggregate3.staticCall(calls);
        const addresses = {
            pdpVerifier: iface.decodeFunctionResult('pdpVerifierAddress', results[0].returnData)[0],
            payments: iface.decodeFunctionResult('paymentsContractAddress', results[1].returnData)[0],
            usdfcToken: iface.decodeFunctionResult('usdfcTokenAddress', results[2].returnData)[0],
            filCDNBeneficiary: iface.decodeFunctionResult('filCDNBeneficiaryAddress', results[3].returnData)[0],
            viewContract: iface.decodeFunctionResult('viewContractAddress', results[4].returnData)[0],
            serviceProviderRegistry: iface.decodeFunctionResult('serviceProviderRegistry', results[5].returnData)[0],
            sessionKeyRegistry: iface.decodeFunctionResult('sessionKeyRegistry', results[6].returnData)[0],
        };
        return new WarmStorageService(provider, warmStorageAddress, addresses);
    }
    getPDPVerifierAddress() {
        return this._addresses.pdpVerifier;
    }
    getPaymentsAddress() {
        return this._addresses.payments;
    }
    getUSDFCTokenAddress() {
        return this._addresses.usdfcToken;
    }
    getViewContractAddress() {
        return this._addresses.viewContract;
    }
    getServiceProviderRegistryAddress() {
        return this._addresses.serviceProviderRegistry;
    }
    getSessionKeyRegistryAddress() {
        return this._addresses.sessionKeyRegistry;
    }
    getProvider() {
        return this._provider;
    }
    _getWarmStorageContract() {
        if (this._warmStorageContract == null) {
            this._warmStorageContract = new ethers.Contract(this._warmStorageAddress, CONTRACT_ABIS.WARM_STORAGE, this._provider);
        }
        return this._warmStorageContract;
    }
    _getWarmStorageViewContract() {
        if (this._warmStorageViewContract == null) {
            const viewAddress = this.getViewContractAddress();
            this._warmStorageViewContract = new ethers.Contract(viewAddress, CONTRACT_ABIS.WARM_STORAGE_VIEW, this._provider);
        }
        return this._warmStorageViewContract;
    }
    _getPDPVerifier() {
        if (this._pdpVerifier == null) {
            const address = this.getPDPVerifierAddress();
            this._pdpVerifier = new PDPVerifier(this._provider, address);
        }
        return this._pdpVerifier;
    }
    async getDataSet(dataSetId) {
        const viewContract = this._getWarmStorageViewContract();
        const ds = await viewContract.getDataSet(dataSetId);
        if (Number(ds.pdpRailId) === 0) {
            throw createError('WarmStorageService', 'getDataSet', `Data set ${dataSetId} does not exist`);
        }
        return {
            pdpRailId: Number(ds.pdpRailId),
            cacheMissRailId: Number(ds.cacheMissRailId),
            cdnRailId: Number(ds.cdnRailId),
            payer: ds.payer,
            payee: ds.payee,
            serviceProvider: ds.serviceProvider,
            commissionBps: Number(ds.commissionBps),
            clientDataSetId: Number(ds.clientDataSetId),
            pdpEndEpoch: Number(ds.pdpEndEpoch),
            providerId: Number(ds.providerId),
            cdnEndEpoch: Number(ds.cdnEndEpoch),
        };
    }
    async getClientDataSets(clientAddress) {
        try {
            const viewContract = this._getWarmStorageViewContract();
            const dataSetData = await viewContract.getClientDataSets(clientAddress);
            return dataSetData.map((ds) => ({
                pdpRailId: Number(ds.pdpRailId),
                cacheMissRailId: Number(ds.cacheMissRailId),
                cdnRailId: Number(ds.cdnRailId),
                payer: ds.payer,
                payee: ds.payee,
                serviceProvider: ds.serviceProvider,
                commissionBps: Number(ds.commissionBps),
                clientDataSetId: Number(ds.clientDataSetId),
                pdpEndEpoch: Number(ds.pdpEndEpoch),
                providerId: Number(ds.providerId),
                cdnEndEpoch: Number(ds.cdnEndEpoch),
            }));
        }
        catch (error) {
            throw new Error(`Failed to get client data sets: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async getClientDataSetsWithDetails(client, onlyManaged = false) {
        const pdpVerifier = this._getPDPVerifier();
        const viewContract = this._getWarmStorageViewContract();
        const ids = await viewContract.clientDataSets(client);
        if (ids.length === 0)
            return [];
        const enhancedDataSetsPromises = ids.map(async (idBigInt) => {
            const pdpVerifierDataSetId = Number(idBigInt);
            try {
                const base = await this.getDataSet(pdpVerifierDataSetId);
                const [isLive, listenerResult, metadata] = await Promise.all([
                    pdpVerifier.dataSetLive(pdpVerifierDataSetId),
                    pdpVerifier.getDataSetListener(pdpVerifierDataSetId).catch(() => null),
                    this.getDataSetMetadata(pdpVerifierDataSetId).catch(() => Object.create(null)),
                ]);
                const isManaged = listenerResult != null && listenerResult.toLowerCase() === this._warmStorageAddress.toLowerCase();
                if (onlyManaged && !isManaged) {
                    return null;
                }
                const nextPieceId = isLive ? await pdpVerifier.getNextPieceId(pdpVerifierDataSetId) : 0n;
                return {
                    ...base,
                    pdpVerifierDataSetId,
                    nextPieceId: Number(nextPieceId),
                    currentPieceCount: Number(nextPieceId),
                    isLive,
                    isManaged,
                    withCDN: base.cdnRailId > 0,
                    metadata,
                };
            }
            catch (error) {
                throw new Error(`Failed to get details for data set ${pdpVerifierDataSetId}: ${error instanceof Error ? error.message : String(error)}`);
            }
        });
        const results = await Promise.all(enhancedDataSetsPromises);
        return results.filter((result) => result !== null);
    }
    async getAddPiecesInfo(dataSetId) {
        try {
            const viewContract = this._getWarmStorageViewContract();
            const pdpVerifier = this._getPDPVerifier();
            const [isLive, nextPieceId, listener, dataSetInfo] = await Promise.all([
                pdpVerifier.dataSetLive(Number(dataSetId)),
                pdpVerifier.getNextPieceId(Number(dataSetId)),
                pdpVerifier.getDataSetListener(Number(dataSetId)),
                viewContract.getDataSet(Number(dataSetId)),
            ]);
            if (!isLive) {
                throw new Error(`Data set ${dataSetId} does not exist or is not live`);
            }
            if (listener.toLowerCase() !== this._warmStorageAddress.toLowerCase()) {
                throw new Error(`Data set ${dataSetId} is not managed by this WarmStorage contract (${this._warmStorageAddress}), managed by ${String(listener)}`);
            }
            const clientDataSetId = Number(dataSetInfo.clientDataSetId);
            return {
                nextPieceId: Number(nextPieceId),
                clientDataSetId,
                currentPieceCount: Number(nextPieceId),
            };
        }
        catch (error) {
            throw new Error(`Failed to get add pieces info: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async getNextClientDataSetId(clientAddress) {
        try {
            const viewContract = this._getWarmStorageViewContract();
            const currentCounter = await viewContract.clientDataSetIDs(clientAddress);
            return Number(currentCounter);
        }
        catch (error) {
            throw new Error(`Failed to get next client dataset ID: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async verifyDataSetCreation(txHashOrTransaction) {
        try {
            const txHash = typeof txHashOrTransaction === 'string' ? txHashOrTransaction : txHashOrTransaction.hash;
            let receipt;
            if (typeof txHashOrTransaction === 'string') {
                receipt = await this._provider.getTransactionReceipt(txHash);
            }
            else {
                receipt = await txHashOrTransaction.wait(TIMING_CONSTANTS.TRANSACTION_CONFIRMATIONS);
            }
            if (receipt == null) {
                return {
                    transactionMined: false,
                    transactionSuccess: false,
                    dataSetLive: false,
                };
            }
            const transactionSuccess = receipt.status === 1;
            if (!transactionSuccess) {
                return {
                    transactionMined: true,
                    transactionSuccess: false,
                    dataSetLive: false,
                    blockNumber: receipt.blockNumber,
                    gasUsed: receipt.gasUsed,
                    error: 'Transaction failed',
                };
            }
            const pdpVerifier = this._getPDPVerifier();
            const dataSetId = await pdpVerifier.extractDataSetIdFromReceipt(receipt);
            if (dataSetId == null) {
                return {
                    transactionMined: true,
                    transactionSuccess: true,
                    dataSetLive: false,
                    blockNumber: receipt.blockNumber,
                    gasUsed: receipt.gasUsed,
                    error: 'Could not find DataSetCreated event in transaction',
                };
            }
            const isLive = await pdpVerifier.dataSetLive(dataSetId);
            return {
                transactionMined: true,
                transactionSuccess: true,
                dataSetId,
                dataSetLive: isLive,
                blockNumber: receipt.blockNumber,
                gasUsed: receipt.gasUsed,
            };
        }
        catch (error) {
            return {
                transactionMined: false,
                transactionSuccess: false,
                dataSetLive: false,
                error: error instanceof Error ? error.message : 'Unknown error',
            };
        }
    }
    async getComprehensiveDataSetStatus(txHashOrTransaction, pdpServer) {
        const txHash = typeof txHashOrTransaction === 'string' ? txHashOrTransaction : txHashOrTransaction.hash;
        let serverStatus = null;
        if (pdpServer != null) {
            try {
                performance.mark('synapse:pdpServer.getDataSetCreationStatus-start');
                serverStatus = await pdpServer.getDataSetCreationStatus(txHash);
                performance.mark('synapse:pdpServer.getDataSetCreationStatus-end');
                performance.measure('synapse:pdpServer.getDataSetCreationStatus', 'synapse:pdpServer.getDataSetCreationStatus-start', 'synapse:pdpServer.getDataSetCreationStatus-end');
            }
            catch {
                performance.mark('synapse:pdpServer.getDataSetCreationStatus-end');
                performance.measure('synapse:pdpServer.getDataSetCreationStatus', 'synapse:pdpServer.getDataSetCreationStatus-start', 'synapse:pdpServer.getDataSetCreationStatus-end');
            }
        }
        performance.mark('synapse:verifyDataSetCreation-start');
        const chainStatus = await this.verifyDataSetCreation(txHashOrTransaction);
        performance.mark('synapse:verifyDataSetCreation-end');
        performance.measure('synapse:verifyDataSetCreation', 'synapse:verifyDataSetCreation-start', 'synapse:verifyDataSetCreation-end');
        const isComplete = chainStatus.transactionMined &&
            chainStatus.transactionSuccess &&
            chainStatus.dataSetId != null &&
            chainStatus.dataSetLive &&
            serverStatus != null &&
            serverStatus.ok === true &&
            serverStatus.dataSetCreated;
        const dataSetId = serverStatus?.dataSetId ?? chainStatus.dataSetId ?? null;
        let error = chainStatus.error ?? null;
        if (serverStatus != null && serverStatus.ok === false) {
            error = `Server reported transaction failed (status: ${serverStatus.txStatus})`;
        }
        return {
            txHash,
            serverStatus,
            chainStatus,
            summary: {
                isComplete,
                isLive: chainStatus.dataSetLive,
                dataSetId,
                error,
            },
        };
    }
    async waitForDataSetCreationWithStatus(txHashOrTransaction, pdpServer, maxWaitTime = TIMING_CONSTANTS.DATA_SET_CREATION_TIMEOUT_MS, pollInterval = TIMING_CONSTANTS.DATA_SET_CREATION_POLL_INTERVAL_MS, onProgress) {
        const startTime = Date.now();
        while (Date.now() - startTime < maxWaitTime) {
            const status = await this.getComprehensiveDataSetStatus(txHashOrTransaction, pdpServer);
            const elapsedMs = Date.now() - startTime;
            if (onProgress != null) {
                try {
                    await onProgress(status, elapsedMs);
                }
                catch (error) {
                    console.error('Error in progress callback:', error);
                }
            }
            if (status.summary.isComplete) {
                return status;
            }
            if (status.summary.error != null && status.chainStatus.transactionMined) {
                throw new Error(status.summary.error);
            }
            await new Promise((resolve) => setTimeout(resolve, pollInterval));
        }
        throw new Error(`Data set creation timed out after ${maxWaitTime / 1000} seconds`);
    }
    async getDataSetMetadata(dataSetId) {
        const viewContract = this._getWarmStorageViewContract();
        const [keys, values] = await viewContract.getAllDataSetMetadata(dataSetId);
        const metadata = Object.create(null);
        for (let i = 0; i < keys.length; i++) {
            metadata[keys[i]] = values[i];
        }
        return metadata;
    }
    async getDataSetMetadataByKey(dataSetId, key) {
        const viewContract = this._getWarmStorageViewContract();
        const [exists, value] = await viewContract.getDataSetMetadata(dataSetId, key);
        return exists ? value : null;
    }
    async getPieceMetadata(dataSetId, pieceId) {
        const viewContract = this._getWarmStorageViewContract();
        const [keys, values] = await viewContract.getAllPieceMetadata(dataSetId, pieceId);
        const metadata = Object.create(null);
        for (let i = 0; i < keys.length; i++) {
            metadata[keys[i]] = values[i];
        }
        return metadata;
    }
    async getPieceMetadataByKey(dataSetId, pieceId, key) {
        const viewContract = this._getWarmStorageViewContract();
        const [exists, value] = await viewContract.getPieceMetadata(dataSetId, pieceId, key);
        return exists ? value : null;
    }
    async getServicePrice() {
        const contract = this._getWarmStorageContract();
        const pricing = await contract.getServicePrice();
        return {
            pricePerTiBPerMonthNoCDN: pricing.pricePerTiBPerMonthNoCDN,
            pricePerTiBPerMonthWithCDN: pricing.pricePerTiBPerMonthWithCDN,
            tokenAddress: pricing.tokenAddress,
            epochsPerMonth: pricing.epochsPerMonth,
        };
    }
    async calculateStorageCost(sizeInBytes) {
        const servicePriceInfo = await this.getServicePrice();
        const sizeInBytesBigint = BigInt(sizeInBytes);
        const pricePerEpochNoCDN = (servicePriceInfo.pricePerTiBPerMonthNoCDN * sizeInBytesBigint) /
            (SIZE_CONSTANTS.TiB * servicePriceInfo.epochsPerMonth);
        const pricePerEpochWithCDN = (servicePriceInfo.pricePerTiBPerMonthWithCDN * sizeInBytesBigint) /
            (SIZE_CONSTANTS.TiB * servicePriceInfo.epochsPerMonth);
        return {
            perEpoch: pricePerEpochNoCDN,
            perDay: pricePerEpochNoCDN * BigInt(TIME_CONSTANTS.EPOCHS_PER_DAY),
            perMonth: pricePerEpochNoCDN * servicePriceInfo.epochsPerMonth,
            withCDN: {
                perEpoch: pricePerEpochWithCDN,
                perDay: pricePerEpochWithCDN * BigInt(TIME_CONSTANTS.EPOCHS_PER_DAY),
                perMonth: pricePerEpochWithCDN * servicePriceInfo.epochsPerMonth,
            },
        };
    }
    async checkAllowanceForStorage(sizeInBytes, withCDN, paymentsService, lockupDays) {
        const [approval, costs] = await Promise.all([
            paymentsService.serviceApproval(this._warmStorageAddress, TOKENS.USDFC),
            this.calculateStorageCost(sizeInBytes),
        ]);
        const selectedCosts = withCDN ? costs.withCDN : costs;
        const rateNeeded = selectedCosts.perEpoch;
        const lockupPeriod = BigInt(lockupDays ?? Number(TIME_CONSTANTS.DEFAULT_LOCKUP_DAYS)) * BigInt(TIME_CONSTANTS.EPOCHS_PER_DAY);
        const lockupNeeded = rateNeeded * lockupPeriod;
        const totalRateNeeded = BigInt(approval.rateUsed) + rateNeeded;
        const totalLockupNeeded = BigInt(approval.lockupUsed) + lockupNeeded;
        const sufficient = approval.rateAllowance >= totalRateNeeded && approval.lockupAllowance >= totalLockupNeeded;
        const rateAllowanceNeeded = totalRateNeeded > approval.rateAllowance ? totalRateNeeded - approval.rateAllowance : 0n;
        const lockupAllowanceNeeded = totalLockupNeeded > approval.lockupAllowance ? totalLockupNeeded - approval.lockupAllowance : 0n;
        let message;
        if (!sufficient) {
            const needsRate = rateAllowanceNeeded > 0n;
            const needsLockup = lockupAllowanceNeeded > 0n;
            if (needsRate && needsLockup) {
                message = 'Insufficient rate and lockup allowances';
            }
            else if (needsRate) {
                message = 'Insufficient rate allowance';
            }
            else if (needsLockup) {
                message = 'Insufficient lockup allowance';
            }
        }
        return {
            rateAllowanceNeeded,
            lockupAllowanceNeeded,
            currentRateAllowance: approval.rateAllowance,
            currentLockupAllowance: approval.lockupAllowance,
            currentRateUsed: approval.rateUsed,
            currentLockupUsed: approval.lockupUsed,
            sufficient,
            message,
            costs: selectedCosts,
            depositAmountNeeded: lockupNeeded,
        };
    }
    async prepareStorageUpload(options, paymentsService) {
        const [costs, allowanceCheck] = await Promise.all([
            this.calculateStorageCost(options.dataSize),
            this.checkAllowanceForStorage(options.dataSize, options.withCDN ?? false, paymentsService),
        ]);
        const selectedCosts = (options.withCDN ?? false) ? costs.withCDN : costs;
        const actions = [];
        const accountInfo = await paymentsService.accountInfo(TOKENS.USDFC);
        const requiredBalance = selectedCosts.perMonth;
        if (accountInfo.availableFunds < requiredBalance) {
            const depositAmount = requiredBalance - accountInfo.availableFunds;
            actions.push({
                type: 'deposit',
                description: `Deposit ${depositAmount} USDFC to payments contract`,
                execute: async () => await paymentsService.deposit(depositAmount, TOKENS.USDFC),
            });
        }
        if (!allowanceCheck.sufficient) {
            actions.push({
                type: 'approveService',
                description: `Approve service with rate allowance ${allowanceCheck.rateAllowanceNeeded} and lockup allowance ${allowanceCheck.lockupAllowanceNeeded}`,
                execute: async () => await paymentsService.approveService(this._warmStorageAddress, allowanceCheck.rateAllowanceNeeded, allowanceCheck.lockupAllowanceNeeded, TIME_CONSTANTS.EPOCHS_PER_MONTH, TOKENS.USDFC),
            });
        }
        return {
            estimatedCost: {
                perEpoch: selectedCosts.perEpoch,
                perDay: selectedCosts.perDay,
                perMonth: selectedCosts.perMonth,
            },
            allowanceCheck: {
                sufficient: allowanceCheck.sufficient,
                message: allowanceCheck.sufficient
                    ? undefined
                    : `Insufficient allowances: rate needed ${allowanceCheck.rateAllowanceNeeded}, lockup needed ${allowanceCheck.lockupAllowanceNeeded}`,
            },
            actions,
        };
    }
    async terminateDataSet(signer, dataSetId) {
        const contract = this._getWarmStorageContract();
        const contractWithSigner = contract.connect(signer);
        return await contractWithSigner.terminateService(dataSetId);
    }
    async addApprovedProvider(signer, providerId) {
        const contract = this._getWarmStorageContract();
        const contractWithSigner = contract.connect(signer);
        return await contractWithSigner.addApprovedProvider(providerId);
    }
    async removeApprovedProvider(signer, providerId) {
        const contract = this._getWarmStorageContract();
        const contractWithSigner = contract.connect(signer);
        const viewContract = this._getWarmStorageViewContract();
        const approvedIds = await viewContract.getApprovedProviders();
        const index = approvedIds.findIndex((id) => Number(id) === providerId);
        if (index === -1) {
            throw new Error(`Provider ${providerId} is not in the approved list`);
        }
        return await contractWithSigner.removeApprovedProvider(providerId, index);
    }
    async getApprovedProviderIds() {
        const viewContract = this._getWarmStorageViewContract();
        const providerIds = await viewContract.getApprovedProviders();
        return providerIds.map((id) => Number(id));
    }
    async isProviderIdApproved(providerId) {
        const viewContract = this._getWarmStorageViewContract();
        return await viewContract.isProviderApproved(providerId);
    }
    async getOwner() {
        const contract = this._getWarmStorageContract();
        return await contract.owner();
    }
    async isOwner(signer) {
        const signerAddress = await signer.getAddress();
        const ownerAddress = await this.getOwner();
        return signerAddress.toLowerCase() === ownerAddress.toLowerCase();
    }
    async getMaxProvingPeriod() {
        const viewContract = this._getWarmStorageViewContract();
        const maxPeriod = await viewContract.getMaxProvingPeriod();
        return Number(maxPeriod);
    }
    async getChallengeWindow() {
        const viewContract = this._getWarmStorageViewContract();
        const window = await viewContract.challengeWindow();
        return Number(window);
    }
}
//# sourceMappingURL=service.js.map