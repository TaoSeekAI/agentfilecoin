import { ethers } from 'ethers';
import { CONTRACT_ABIS, CONTRACT_ADDRESSES } from "../utils/constants.js";
import { getFilecoinNetworkType } from "../utils/index.js";
export class SPRegistryService {
    _provider;
    _registryAddress;
    _registryContract = null;
    constructor(provider, registryAddress) {
        this._provider = provider;
        this._registryAddress = registryAddress;
    }
    static async create(provider, registryAddress) {
        return new SPRegistryService(provider, registryAddress);
    }
    _getRegistryContract() {
        if (this._registryContract == null) {
            this._registryContract = new ethers.Contract(this._registryAddress, CONTRACT_ABIS.SERVICE_PROVIDER_REGISTRY, this._provider);
        }
        return this._registryContract;
    }
    async registerProvider(signer, info) {
        const contract = this._getRegistryContract().connect(signer);
        const registrationFee = await contract.REGISTRATION_FEE();
        let productType = 0;
        let productData = '0x';
        let capabilityKeys = [];
        let capabilityValues = [];
        if (info.pdpOffering != null) {
            productType = 0;
            productData = await this.encodePDPOffering(info.pdpOffering);
            if (info.capabilities != null) {
                capabilityKeys = [];
                capabilityValues = [];
                for (const [key, value] of Object.entries(info.capabilities)) {
                    capabilityKeys.push(key);
                    capabilityValues.push(value ?? '');
                }
            }
        }
        const tx = await contract.registerProvider(info.payee, info.name, info.description, productType, productData, capabilityKeys, capabilityValues, { value: registrationFee });
        return tx;
    }
    async updateProviderInfo(signer, name, description) {
        const contract = this._getRegistryContract().connect(signer);
        return await contract.updateProviderInfo(name, description);
    }
    async removeProvider(signer) {
        const contract = this._getRegistryContract().connect(signer);
        return await contract.removeProvider();
    }
    async getProvider(providerId) {
        try {
            const contract = this._getRegistryContract();
            const rawProvider = await contract.getProvider(providerId);
            if (rawProvider.serviceProvider === ethers.ZeroAddress) {
                return null;
            }
            const products = await this._getProviderProducts(providerId);
            return this._convertToProviderInfo(providerId, rawProvider, products);
        }
        catch (error) {
            if (error instanceof Error && error.message.includes('Provider not found')) {
                return null;
            }
            throw error;
        }
    }
    async getProviderByAddress(address) {
        try {
            const contract = this._getRegistryContract();
            const [rawProvider, providerId] = await Promise.all([
                contract.getProviderByAddress(address),
                contract.getProviderIdByAddress(address),
            ]);
            if (rawProvider.serviceProvider === ethers.ZeroAddress) {
                return null;
            }
            const products = await this._getProviderProducts(Number(providerId));
            return this._convertToProviderInfo(Number(providerId), rawProvider, products);
        }
        catch {
            return null;
        }
    }
    async getProviderIdByAddress(address) {
        const contract = this._getRegistryContract();
        const id = await contract.getProviderIdByAddress(address);
        return Number(id);
    }
    async getAllActiveProviders() {
        const contract = this._getRegistryContract();
        const providerPromises = [];
        const pageSize = 50;
        let offset = 0;
        let hasMore = true;
        while (hasMore) {
            const result = await contract.getAllActiveProviders(offset, pageSize);
            const providerIds = result[0];
            hasMore = result[1];
            if (providerIds.length > 0) {
                const ids = providerIds.map((id) => Number(id));
                providerPromises.push(this.getProviders(ids));
            }
            offset += pageSize;
        }
        const providerBatches = await Promise.all(providerPromises);
        return providerBatches.flat();
    }
    async getActiveProvidersByProductType(productType) {
        const contract = this._getRegistryContract();
        const providerPromises = [];
        let offset = 0;
        const limit = 50;
        let hasMore = true;
        while (hasMore) {
            const result = await contract.getProvidersByProductType(productType, offset, limit);
            if (result.providerIds.length > 0) {
                const ids = result.providerIds.map((id) => Number(id));
                providerPromises.push(this.getProviders(ids));
            }
            hasMore = result.hasMore;
            offset += limit;
        }
        const providerBatches = await Promise.all(providerPromises);
        const allProviders = providerBatches.flat();
        return allProviders.filter((provider) => provider.active);
    }
    async isProviderActive(providerId) {
        const contract = this._getRegistryContract();
        return await contract.isProviderActive(providerId);
    }
    async isRegisteredProvider(address) {
        const contract = this._getRegistryContract();
        return await contract.isRegisteredProvider(address);
    }
    async getProviderCount() {
        const contract = this._getRegistryContract();
        const count = await contract.getProviderCount();
        return Number(count);
    }
    async activeProviderCount() {
        const contract = this._getRegistryContract();
        const count = await contract.activeProviderCount();
        return Number(count);
    }
    async addPDPProduct(signer, pdpOffering, capabilities = {}) {
        const contract = this._getRegistryContract().connect(signer);
        const encodedOffering = await this.encodePDPOffering(pdpOffering);
        const entries = Object.entries(capabilities);
        const capabilityKeys = entries.map(([key]) => key);
        const capabilityValues = entries.map(([, value]) => value || '');
        return await contract.addProduct(0, encodedOffering, capabilityKeys, capabilityValues);
    }
    async updatePDPProduct(signer, pdpOffering, capabilities = {}) {
        const contract = this._getRegistryContract().connect(signer);
        const encodedOffering = await this.encodePDPOffering(pdpOffering);
        const entries = Object.entries(capabilities);
        const capabilityKeys = entries.map(([key]) => key);
        const capabilityValues = entries.map(([, value]) => value || '');
        return await contract.updateProduct(0, encodedOffering, capabilityKeys, capabilityValues);
    }
    async removeProduct(signer, productType) {
        const contract = this._getRegistryContract().connect(signer);
        return await contract.removeProduct(productType);
    }
    async getPDPService(providerId) {
        try {
            const contract = this._getRegistryContract();
            const result = await contract.getPDPService(providerId);
            if (!result.pdpOffering.serviceURL) {
                return null;
            }
            let capabilities = {};
            if (result.capabilityKeys && result.capabilityKeys.length > 0) {
                const keys = Array.from(result.capabilityKeys);
                const capResult = await contract.getProductCapabilities(providerId, 0, keys);
                const values = Array.from(capResult[1] || []);
                capabilities = this._convertCapabilitiesToObject(keys, values);
            }
            return {
                offering: {
                    serviceURL: result.pdpOffering.serviceURL,
                    minPieceSizeInBytes: result.pdpOffering.minPieceSizeInBytes,
                    maxPieceSizeInBytes: result.pdpOffering.maxPieceSizeInBytes,
                    ipniPiece: result.pdpOffering.ipniPiece,
                    ipniIpfs: result.pdpOffering.ipniIpfs,
                    storagePricePerTibPerMonth: result.pdpOffering.storagePricePerTibPerMonth,
                    minProvingPeriodInEpochs: Number(result.pdpOffering.minProvingPeriodInEpochs),
                    location: result.pdpOffering.location,
                    paymentTokenAddress: result.pdpOffering.paymentTokenAddress,
                },
                capabilities,
                isActive: result.isActive,
            };
        }
        catch {
            return null;
        }
    }
    async providerHasProduct(providerId, productType) {
        const contract = this._getRegistryContract();
        return await contract.providerHasProduct(providerId, productType);
    }
    async getProviders(providerIds) {
        if (providerIds.length === 0) {
            return [];
        }
        try {
            return await this._getProvidersWithMulticall(providerIds);
        }
        catch {
            return await this._getProvidersIndividually(providerIds);
        }
    }
    async _getProvidersWithMulticall(providerIds) {
        const network = await getFilecoinNetworkType(this._provider);
        const multicall3Address = CONTRACT_ADDRESSES.MULTICALL3[network];
        const multicall = new ethers.Contract(multicall3Address, CONTRACT_ABIS.MULTICALL3, this._provider);
        const iface = new ethers.Interface(CONTRACT_ABIS.SERVICE_PROVIDER_REGISTRY);
        const calls = this._prepareMulticallCalls(providerIds, iface);
        const results = await multicall.aggregate3.staticCall(calls);
        return this._processMulticallResults(providerIds, results, iface);
    }
    _prepareMulticallCalls(providerIds, iface) {
        const calls = [];
        for (const id of providerIds) {
            calls.push({
                target: this._registryAddress,
                allowFailure: true,
                callData: iface.encodeFunctionData('getProvider', [id]),
            });
            calls.push({
                target: this._registryAddress,
                allowFailure: true,
                callData: iface.encodeFunctionData('getPDPService', [id]),
            });
        }
        return calls;
    }
    _processMulticallResults(providerIds, results, iface) {
        const providers = [];
        for (let i = 0; i < providerIds.length; i++) {
            const providerResultIndex = i * 2;
            const pdpServiceResultIndex = i * 2 + 1;
            if (!results[providerResultIndex].success) {
                continue;
            }
            try {
                const decoded = iface.decodeFunctionResult('getProvider', results[providerResultIndex].returnData);
                const rawProvider = decoded[0];
                const products = this._extractProductsFromMulticallResult(results[pdpServiceResultIndex], iface);
                const providerInfo = this._convertToProviderInfo(providerIds[i], rawProvider, products);
                providers.push(providerInfo);
            }
            catch {
            }
        }
        return providers;
    }
    _extractProductsFromMulticallResult(pdpServiceResult, iface) {
        const products = [];
        if (!pdpServiceResult.success) {
            return products;
        }
        try {
            const pdpDecoded = iface.decodeFunctionResult('getPDPService', pdpServiceResult.returnData);
            const [pdpOffering, capabilityKeys, isActive] = pdpDecoded;
            if (!pdpOffering[0]) {
                return products;
            }
            const capabilities = this._buildCapabilitiesFromKeys(capabilityKeys);
            products.push({
                type: 'PDP',
                isActive,
                capabilities,
                data: {
                    serviceURL: pdpOffering[0],
                    minPieceSizeInBytes: pdpOffering[1],
                    maxPieceSizeInBytes: pdpOffering[2],
                    ipniPiece: pdpOffering[3],
                    ipniIpfs: pdpOffering[4],
                    storagePricePerTibPerMonth: pdpOffering[5],
                    minProvingPeriodInEpochs: Number(pdpOffering[6]),
                    location: pdpOffering[7],
                    paymentTokenAddress: pdpOffering[8],
                },
            });
        }
        catch {
        }
        return products;
    }
    _buildCapabilitiesFromKeys(capabilityKeys) {
        const capabilities = {};
        if (capabilityKeys && Array.isArray(capabilityKeys)) {
            for (const key of capabilityKeys) {
                capabilities[key] = '';
            }
        }
        return capabilities;
    }
    async _getProvidersIndividually(providerIds) {
        const providers = [];
        const promises = providerIds.map((id) => this.getProvider(id));
        const results = await Promise.all(promises);
        for (const provider of results) {
            if (provider != null) {
                providers.push(provider);
            }
        }
        return providers;
    }
    async _getProviderProducts(providerId) {
        const products = [];
        const pdpService = await this.getPDPService(providerId);
        if (pdpService != null) {
            products.push({
                type: 'PDP',
                isActive: pdpService.isActive,
                capabilities: pdpService.capabilities,
                data: pdpService.offering,
            });
        }
        return products;
    }
    _convertToProviderInfo(providerId, rawProvider, productsArray) {
        const products = {};
        for (const product of productsArray) {
            if (product.type === 'PDP') {
                products.PDP = product;
            }
        }
        return {
            id: providerId,
            serviceProvider: rawProvider.serviceProvider,
            payee: rawProvider.payee,
            name: rawProvider.name,
            description: rawProvider.description,
            active: rawProvider.isActive,
            products,
        };
    }
    _convertCapabilitiesToObject(keys, values) {
        const capabilities = {};
        for (let i = 0; i < keys.length; i++) {
            capabilities[keys[i]] = values[i] || '';
        }
        return capabilities;
    }
    async encodePDPOffering(offering) {
        const contract = this._getRegistryContract();
        return await contract.encodePDPOffering(offering);
    }
}
//# sourceMappingURL=service.js.map