import { ethers } from 'ethers';
import { asPieceCID } from "../piece/index.js";
import { METADATA_KEYS } from "../utils/constants.js";
import { EIP712_TYPES } from "../utils/eip712.js";
export class PDPAuthHelper {
    signer;
    domain;
    WITH_CDN_METADATA = { key: METADATA_KEYS.WITH_CDN, value: '' };
    constructor(serviceContractAddress, signer, chainId) {
        this.signer = signer;
        this.domain = {
            name: 'FilecoinWarmStorageService',
            version: '1',
            chainId: Number(chainId),
            verifyingContract: serviceContractAddress,
        };
    }
    getUnderlyingSigner() {
        if ('signer' in this.signer && this.signer.constructor.name === 'NonceManager') {
            return this.signer.signer;
        }
        return this.signer;
    }
    async isMetaMaskSigner() {
        try {
            const actualSigner = this.getUnderlyingSigner();
            if (actualSigner.constructor.name === 'Wallet') {
                return false;
            }
            const provider = actualSigner.provider;
            if (provider == null) {
                return false;
            }
            if ('_eip1193Provider' in provider) {
                return true;
            }
            if (provider instanceof ethers.JsonRpcProvider || provider instanceof ethers.WebSocketProvider) {
                return false;
            }
            if ('request' in provider && typeof provider.request === 'function') {
                return true;
            }
        }
        catch {
        }
        return false;
    }
    async signWithMetaMask(types, value) {
        const provider = this.signer.provider;
        if (provider == null) {
            throw new Error('No provider available');
        }
        const signerAddress = await this.signer.getAddress();
        let primaryType = '';
        for (const typeName of Object.keys(types)) {
            if (typeName !== 'Cid' && typeName !== 'PieceData') {
                primaryType = typeName;
                break;
            }
        }
        const typedData = {
            types: {
                EIP712Domain: [
                    { name: 'name', type: 'string' },
                    { name: 'version', type: 'string' },
                    { name: 'chainId', type: 'uint256' },
                    { name: 'verifyingContract', type: 'address' },
                ],
                ...types,
            },
            primaryType,
            domain: this.domain,
            message: value,
        };
        let eip1193Provider;
        if ('_eip1193Provider' in provider) {
            eip1193Provider = provider._eip1193Provider;
        }
        else if ('request' in provider) {
            eip1193Provider = provider;
        }
        else {
            eip1193Provider = provider;
        }
        let signature;
        if (eip1193Provider != null && 'request' in eip1193Provider) {
            signature = await eip1193Provider.request({
                method: 'eth_signTypedData_v4',
                params: [signerAddress, JSON.stringify(typedData)],
            });
        }
        else {
            signature = await provider.send('eth_signTypedData_v4', [signerAddress, JSON.stringify(typedData)]);
        }
        return signature;
    }
    async signCreateDataSet(clientDataSetId, payee, metadata = []) {
        let signature;
        const types = { CreateDataSet: EIP712_TYPES.CreateDataSet, MetadataEntry: EIP712_TYPES.MetadataEntry };
        const useMetaMask = await this.isMetaMaskSigner();
        if (useMetaMask) {
            const value = {
                clientDataSetId: clientDataSetId.toString(),
                metadata,
                payee,
            };
            signature = await this.signWithMetaMask(types, value);
        }
        else {
            const value = {
                clientDataSetId: BigInt(clientDataSetId),
                metadata,
                payee,
            };
            const actualSigner = this.getUnderlyingSigner();
            signature = await actualSigner.signTypedData(this.domain, types, value);
        }
        const sig = ethers.Signature.from(signature);
        const signedData = ethers.TypedDataEncoder.hash(this.domain, types, {
            clientDataSetId: BigInt(clientDataSetId),
            metadata,
            payee,
        });
        return {
            signature,
            v: sig.v,
            r: sig.r,
            s: sig.s,
            signedData,
        };
    }
    async signAddPieces(clientDataSetId, firstPieceId, pieceDataArray, metadata = []) {
        if (metadata.length === 0) {
            metadata = Array(pieceDataArray.length).fill([]);
        }
        else if (metadata.length !== pieceDataArray.length) {
            throw new Error('metadata length must match pieceDataArray length');
        }
        const pieceMetadata = [];
        const formattedPieceData = [];
        for (let i = 0; i < pieceDataArray.length; i++) {
            const piece = pieceDataArray[i];
            const pieceCid = typeof piece === 'string' ? asPieceCID(piece) : piece;
            if (pieceCid == null) {
                throw new Error(`Invalid PieceCID: ${String(pieceCid)}`);
            }
            formattedPieceData.push({
                data: pieceCid.bytes,
            });
            pieceMetadata.push({
                pieceIndex: i,
                metadata: metadata[i],
            });
        }
        const types = {
            AddPieces: EIP712_TYPES.AddPieces,
            Cid: EIP712_TYPES.Cid,
            PieceMetadata: EIP712_TYPES.PieceMetadata,
            MetadataEntry: EIP712_TYPES.MetadataEntry,
        };
        let signature;
        const useMetaMask = await this.isMetaMaskSigner();
        if (useMetaMask) {
            const value = {
                clientDataSetId: clientDataSetId.toString(),
                firstAdded: firstPieceId.toString(),
                pieceData: formattedPieceData.map((item) => ({
                    data: ethers.hexlify(item.data),
                })),
                pieceMetadata: pieceMetadata,
            };
            signature = await this.signWithMetaMask(types, value);
        }
        else {
            const value = {
                clientDataSetId: BigInt(clientDataSetId),
                firstAdded: BigInt(firstPieceId),
                pieceData: formattedPieceData,
                pieceMetadata: pieceMetadata,
            };
            const actualSigner = this.getUnderlyingSigner();
            signature = await actualSigner.signTypedData(this.domain, types, value);
        }
        const sig = ethers.Signature.from(signature);
        const signedData = ethers.TypedDataEncoder.hash(this.domain, types, {
            clientDataSetId: BigInt(clientDataSetId),
            firstAdded: BigInt(firstPieceId),
            pieceData: formattedPieceData,
            pieceMetadata: pieceMetadata,
        });
        return {
            signature,
            v: sig.v,
            r: sig.r,
            s: sig.s,
            signedData,
        };
    }
    async signSchedulePieceRemovals(clientDataSetId, pieceIds) {
        const pieceIdsBigInt = pieceIds.map((id) => BigInt(id));
        let signature;
        const useMetaMask = await this.isMetaMaskSigner();
        if (useMetaMask) {
            const value = {
                clientDataSetId: clientDataSetId.toString(),
                pieceIds: pieceIdsBigInt.map((id) => id.toString()),
            };
            signature = await this.signWithMetaMask({ SchedulePieceRemovals: EIP712_TYPES.SchedulePieceRemovals }, value);
        }
        else {
            const value = {
                clientDataSetId: BigInt(clientDataSetId),
                pieceIds: pieceIdsBigInt,
            };
            const actualSigner = this.getUnderlyingSigner();
            signature = await actualSigner.signTypedData(this.domain, { SchedulePieceRemovals: EIP712_TYPES.SchedulePieceRemovals }, value);
        }
        const sig = ethers.Signature.from(signature);
        const signedData = ethers.TypedDataEncoder.hash(this.domain, { SchedulePieceRemovals: EIP712_TYPES.SchedulePieceRemovals }, {
            clientDataSetId: BigInt(clientDataSetId),
            pieceIds: pieceIdsBigInt,
        });
        return {
            signature,
            v: sig.v,
            r: sig.r,
            s: sig.s,
            signedData,
        };
    }
    async signDeleteDataSet(clientDataSetId) {
        let signature;
        const useMetaMask = await this.isMetaMaskSigner();
        if (useMetaMask) {
            const value = {
                clientDataSetId: clientDataSetId.toString(),
            };
            signature = await this.signWithMetaMask({ DeleteDataSet: EIP712_TYPES.DeleteDataSet }, value);
        }
        else {
            const value = {
                clientDataSetId: BigInt(clientDataSetId),
            };
            const actualSigner = this.getUnderlyingSigner();
            signature = await actualSigner.signTypedData(this.domain, { DeleteDataSet: EIP712_TYPES.DeleteDataSet }, value);
        }
        const sig = ethers.Signature.from(signature);
        const signedData = ethers.TypedDataEncoder.hash(this.domain, { DeleteDataSet: EIP712_TYPES.DeleteDataSet }, {
            clientDataSetId: BigInt(clientDataSetId),
        });
        return {
            signature,
            v: sig.v,
            r: sig.r,
            s: sig.s,
            signedData,
        };
    }
    async getSignerAddress() {
        return await this.signer.getAddress();
    }
}
//# sourceMappingURL=auth.js.map