import { ethers } from 'ethers';
import { asPieceCID, calculate as calculatePieceCID, downloadAndValidate } from "../piece/index.js";
import { validateDataSetMetadata, validatePieceMetadata } from "../utils/metadata.js";
import { constructFindPieceUrl, constructPieceUrl } from "../utils/piece.js";
import { asDataSetData, validateDataSetCreationStatusResponse, validateFindPieceResponse, validatePieceAdditionStatusResponse, validatePieceDeleteResponse, validatePieceStatusResponse, } from "./validation.js";
export class PDPServer {
    _serviceURL;
    _authHelper;
    constructor(authHelper, serviceURL) {
        if (serviceURL.trim() === '') {
            throw new Error('PDP service URL is required');
        }
        this._serviceURL = serviceURL.replace(/\/$/, '');
        this._authHelper = authHelper;
    }
    async createDataSet(clientDataSetId, payee, payer, metadata, recordKeeper) {
        validateDataSetMetadata(metadata);
        const authData = await this.getAuthHelper().signCreateDataSet(clientDataSetId, payee, metadata);
        const extraData = this._encodeDataSetCreateData({
            payer,
            metadata,
            signature: authData.signature,
        });
        const requestBody = {
            recordKeeper,
            extraData: `0x${extraData}`,
        };
        const response = await fetch(`${this._serviceURL}/pdp/data-sets`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestBody),
        });
        if (response.status !== 201) {
            const errorText = await response.text();
            throw new Error(`Failed to create data set: ${response.status} ${response.statusText} - ${errorText}`);
        }
        const location = response.headers.get('Location');
        if (location == null) {
            throw new Error('Server did not provide Location header in response');
        }
        const locationMatch = location.match(/\/pdp\/data-sets\/created\/(.+)$/);
        if (locationMatch == null) {
            throw new Error(`Invalid Location header format: ${location}`);
        }
        const txHash = locationMatch[1];
        return {
            txHash,
            statusUrl: `${this._serviceURL}${location}`,
        };
    }
    async addPieces(dataSetId, clientDataSetId, nextPieceId, pieceDataArray, metadata) {
        if (pieceDataArray.length === 0) {
            throw new Error('At least one piece must be provided');
        }
        if (metadata != null) {
            for (let i = 0; i < metadata.length; i++) {
                if (metadata[i] != null && metadata[i].length > 0) {
                    try {
                        validatePieceMetadata(metadata[i]);
                    }
                    catch (error) {
                        throw new Error(`Piece ${i} metadata validation failed: ${error.message}`);
                    }
                }
            }
        }
        for (const pieceData of pieceDataArray) {
            const pieceCid = asPieceCID(pieceData);
            if (pieceCid == null) {
                throw new Error(`Invalid PieceCID: ${String(pieceData)}`);
            }
        }
        const finalMetadata = metadata ?? pieceDataArray.map(() => []);
        if (finalMetadata.length !== pieceDataArray.length) {
            throw new Error(`Metadata length (${finalMetadata.length}) must match pieces length (${pieceDataArray.length})`);
        }
        const authData = await this.getAuthHelper().signAddPieces(clientDataSetId, nextPieceId, pieceDataArray, finalMetadata);
        const extraData = this._encodeAddPiecesExtraData({
            signature: authData.signature,
            metadata: finalMetadata,
        });
        const requestBody = {
            pieces: pieceDataArray.map((pieceData) => {
                const cidString = typeof pieceData === 'string' ? pieceData : pieceData.toString();
                return {
                    pieceCid: cidString,
                    subPieces: [
                        {
                            subPieceCid: cidString,
                        },
                    ],
                };
            }),
            extraData: `0x${extraData}`,
        };
        const response = await fetch(`${this._serviceURL}/pdp/data-sets/${dataSetId}/pieces`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestBody),
        });
        if (response.status !== 201) {
            const errorText = await response.text();
            throw new Error(`Failed to add pieces to data set: ${response.status} ${response.statusText} - ${errorText}`);
        }
        const location = response.headers.get('Location');
        let txHash;
        let statusUrl;
        if (location != null) {
            const locationMatch = location.match(/\/pieces\/added\/([0-9a-fA-Fx]+)$/);
            if (locationMatch != null) {
                txHash = locationMatch[1];
                if (!txHash.startsWith('0x')) {
                    txHash = `0x${txHash}`;
                }
                statusUrl = `${this._serviceURL}${location}`;
            }
        }
        const responseText = await response.text();
        return {
            message: responseText !== '' ? responseText : `Pieces added to data set ID ${dataSetId} successfully`,
            txHash,
            statusUrl,
        };
    }
    async getDataSetCreationStatus(txHash) {
        const response = await fetch(`${this._serviceURL}/pdp/data-sets/created/${txHash}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
            },
        });
        if (response.status === 404) {
            throw new Error(`Data set creation not found for transaction hash: ${txHash}`);
        }
        if (response.status !== 200) {
            const errorText = await response.text();
            throw new Error(`Failed to get data set creation status: ${response.status} ${response.statusText} - ${errorText}`);
        }
        const data = await response.json();
        return validateDataSetCreationStatusResponse(data);
    }
    async getPieceAdditionStatus(dataSetId, txHash) {
        const response = await fetch(`${this._serviceURL}/pdp/data-sets/${dataSetId}/pieces/added/${txHash}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
            },
        });
        if (response.status === 404) {
            throw new Error(`Piece addition not found for transaction: ${txHash}`);
        }
        if (response.status !== 200) {
            const errorText = await response.text();
            throw new Error(`Failed to get piece addition status: ${response.status} ${response.statusText} - ${errorText}`);
        }
        const data = await response.json();
        return validatePieceAdditionStatusResponse(data);
    }
    async findPiece(pieceCid) {
        const parsedPieceCid = asPieceCID(pieceCid);
        if (parsedPieceCid == null) {
            throw new Error(`Invalid PieceCID: ${String(pieceCid)}`);
        }
        const url = constructFindPieceUrl(this._serviceURL, parsedPieceCid);
        const response = await fetch(url, {
            method: 'GET',
            headers: {},
        });
        if (response.status === 404) {
            throw new Error(`Piece not found: ${parsedPieceCid.toString()}`);
        }
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Failed to find piece: ${response.status} ${response.statusText} - ${errorText}`);
        }
        const data = await response.json();
        return validateFindPieceResponse(data);
    }
    async getPieceStatus(pieceCid) {
        const parsedPieceCid = asPieceCID(pieceCid);
        if (parsedPieceCid == null) {
            throw new Error(`Invalid PieceCID: ${String(pieceCid)}`);
        }
        const response = await fetch(`${this._serviceURL}/pdp/piece/${parsedPieceCid.toString()}/status`, {
            method: 'GET',
            headers: {
                Accept: 'application/json',
            },
        });
        if (response.status === 404) {
            const errorText = await response.text();
            throw new Error(`Piece not found or does not belong to service: ${errorText}`);
        }
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Failed to get piece status: ${response.status} ${response.statusText} - ${errorText}`);
        }
        const data = await response.json();
        return validatePieceStatusResponse(data);
    }
    async uploadPiece(data) {
        const uint8Data = data instanceof ArrayBuffer ? new Uint8Array(data) : data;
        performance.mark('synapse:calculatePieceCID-start');
        const pieceCid = calculatePieceCID(uint8Data);
        performance.mark('synapse:calculatePieceCID-end');
        performance.measure('synapse:calculatePieceCID', 'synapse:calculatePieceCID-start', 'synapse:calculatePieceCID-end');
        const size = uint8Data.length;
        const requestBody = {
            pieceCid: pieceCid.toString(),
        };
        performance.mark('synapse:POST.pdp.piece-start');
        const createResponse = await fetch(`${this._serviceURL}/pdp/piece`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestBody),
        });
        performance.mark('synapse:POST.pdp.piece-end');
        performance.measure('synapse:POST.pdp.piece', 'synapse:POST.pdp.piece-start', 'synapse:POST.pdp.piece-end');
        if (createResponse.status === 200) {
            return {
                pieceCid,
                size,
            };
        }
        if (createResponse.status !== 201) {
            const errorText = await createResponse.text();
            throw new Error(`Failed to create upload session: ${createResponse.status} ${createResponse.statusText} - ${errorText}`);
        }
        const location = createResponse.headers.get('Location');
        if (location == null) {
            throw new Error('Server did not provide Location header in response (may be restricted by CORS policy)');
        }
        const locationMatch = location.match(/\/(?:pdp\/)?piece\/upload\/([a-fA-F0-9-]+)/);
        if (locationMatch == null) {
            throw new Error(`Invalid Location header format: ${location}`);
        }
        const uploadUuid = locationMatch[1];
        performance.mark('synapse:PUT.pdp.piece.upload-start');
        const uploadResponse = await fetch(`${this._serviceURL}/pdp/piece/upload/${uploadUuid}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/octet-stream',
                'Content-Length': uint8Data.length.toString(),
            },
            body: uint8Data,
        });
        performance.mark('synapse:PUT.pdp.piece.upload-end');
        performance.measure('synapse:PUT.pdp.piece.upload', 'synapse:PUT.pdp.piece.upload-start', 'synapse:PUT.pdp.piece.upload-end');
        if (uploadResponse.status !== 204) {
            const errorText = await uploadResponse.text();
            throw new Error(`Failed to upload piece: ${uploadResponse.status} ${uploadResponse.statusText} - ${errorText}`);
        }
        return {
            pieceCid,
            size,
        };
    }
    async downloadPiece(pieceCid) {
        const parsedPieceCid = asPieceCID(pieceCid);
        if (parsedPieceCid == null) {
            throw new Error(`Invalid PieceCID: ${String(pieceCid)}`);
        }
        const downloadUrl = constructPieceUrl(this._serviceURL, parsedPieceCid);
        const response = await fetch(downloadUrl);
        return await downloadAndValidate(response, parsedPieceCid);
    }
    async getDataSet(dataSetId) {
        const response = await fetch(`${this._serviceURL}/pdp/data-sets/${dataSetId}`, {
            method: 'GET',
            headers: {
                Accept: 'application/json',
            },
        });
        if (response.status === 404) {
            throw new Error(`Data set not found: ${dataSetId}`);
        }
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Failed to fetch data set: ${response.status} ${response.statusText} - ${errorText}`);
        }
        const data = await response.json();
        const converted = asDataSetData(data);
        if (converted == null) {
            console.error('Invalid data set data response:', data);
            throw new Error('Invalid data set data response format');
        }
        return converted;
    }
    async deletePiece(dataSetId, clientDataSetId, pieceID) {
        const authData = await this.getAuthHelper().signSchedulePieceRemovals(clientDataSetId, [pieceID]);
        const payload = {
            extraData: `0x${authData.signature}`,
        };
        const response = await fetch(`${this._serviceURL}/pdp/data-sets/${dataSetId}/pieces/${pieceID}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(payload),
        });
        if (response.status !== 200) {
            const errorText = await response.text();
            throw new Error(`Failed to delete piece: ${response.status} ${response.statusText} - ${errorText}`);
        }
        const data = await response.json();
        return validatePieceDeleteResponse(data).txHash;
    }
    _encodeDataSetCreateData(data) {
        const signature = data.signature.startsWith('0x') ? data.signature : `0x${data.signature}`;
        const keys = data.metadata.map((item) => item.key);
        const values = data.metadata.map((item) => item.value);
        const abiCoder = ethers.AbiCoder.defaultAbiCoder();
        const encoded = abiCoder.encode(['address', 'string[]', 'string[]', 'bytes'], [data.payer, keys, values, signature]);
        return encoded.slice(2);
    }
    _encodeAddPiecesExtraData(data) {
        const signature = data.signature.startsWith('0x') ? data.signature : `0x${data.signature}`;
        const keys = data.metadata.map((item) => item.map((item) => item.key));
        const values = data.metadata.map((item) => item.map((item) => item.value));
        const abiCoder = ethers.AbiCoder.defaultAbiCoder();
        const encoded = abiCoder.encode(['bytes', 'string[][]', 'string[][]'], [signature, keys, values]);
        return encoded.slice(2);
    }
    async ping() {
        const response = await fetch(`${this._serviceURL}/pdp/ping`, {
            method: 'GET',
            headers: {},
        });
        if (response.status !== 200) {
            const errorText = await response.text().catch(() => 'Unknown error');
            throw new Error(`Provider ping failed: ${response.status} ${response.statusText} - ${errorText}`);
        }
    }
    getServiceURL() {
        return this._serviceURL;
    }
    getAuthHelper() {
        if (this._authHelper == null) {
            throw new Error('AuthHelper is not available for an operation that requires signing');
        }
        return this._authHelper;
    }
}
//# sourceMappingURL=server.js.map