import { ethers } from 'ethers';
import { asPieceCID, downloadAndValidate } from "../piece/index.js";
import { SPRegistryService } from "../sp-registry/index.js";
import { combineMetadata, createError, METADATA_KEYS, metadataMatches, SIZE_CONSTANTS, TIME_CONSTANTS, TOKENS, } from "../utils/index.js";
import { ProviderResolver } from "../utils/provider-resolver.js";
import { StorageContext } from "./context.js";
export class StorageManager {
    _synapse;
    _warmStorageService;
    _pieceRetriever;
    _withCDN;
    _dev;
    _withIpni;
    _defaultContext;
    constructor(synapse, warmStorageService, pieceRetriever, withCDN, dev, withIpni) {
        this._synapse = synapse;
        this._warmStorageService = warmStorageService;
        this._pieceRetriever = pieceRetriever;
        this._withCDN = withCDN;
        this._dev = dev;
        this._withIpni = withIpni;
    }
    async upload(data, options) {
        if (options?.context != null) {
            const invalidOptions = [];
            if (options.providerId !== undefined)
                invalidOptions.push('providerId');
            if (options.providerAddress !== undefined)
                invalidOptions.push('providerAddress');
            if (options.dataSetId !== undefined)
                invalidOptions.push('dataSetId');
            if (options.withCDN !== undefined)
                invalidOptions.push('withCDN');
            if (options.forceCreateDataSet !== undefined)
                invalidOptions.push('forceCreateDataSet');
            if (options.uploadBatchSize !== undefined)
                invalidOptions.push('uploadBatchSize');
            if (invalidOptions.length > 0) {
                throw createError('StorageManager', 'upload', `Cannot specify both 'context' and other options: ${invalidOptions.join(', ')}`);
            }
        }
        const context = options?.context ?? (await this.createContext(options));
        return await context.upload(data, {
            ...options?.callbacks,
            metadata: options?.metadata,
        });
    }
    async download(pieceCid, options) {
        if (options?.context != null) {
            const invalidOptions = [];
            if (options.providerAddress !== undefined)
                invalidOptions.push('providerAddress');
            if (options.withCDN !== undefined)
                invalidOptions.push('withCDN');
            if (invalidOptions.length > 0) {
                throw createError('StorageManager', 'download', `Cannot specify both 'context' and other options: ${invalidOptions.join(', ')}`);
            }
            return await options.context.download(pieceCid, options);
        }
        const parsedPieceCID = asPieceCID(pieceCid);
        if (parsedPieceCID == null) {
            throw createError('StorageManager', 'download', `Invalid PieceCID: ${String(pieceCid)}`);
        }
        const withCDN = options?.withCDN ?? this._withCDN;
        if (this._defaultContext != null && !withCDN && options?.providerAddress == null) {
            const defaultHasCDN = this._defaultContext._withCDN ?? this._withCDN;
            if (defaultHasCDN === false) {
                const hasPiece = await this._defaultContext.hasPiece(parsedPieceCID);
                if (hasPiece) {
                    return await this._defaultContext.download(pieceCid, options);
                }
            }
        }
        const clientAddress = await this._synapse.getClient().getAddress();
        const response = await this._pieceRetriever.fetchPiece(parsedPieceCID, clientAddress, {
            providerAddress: options?.providerAddress,
            withCDN,
        });
        return await downloadAndValidate(response, parsedPieceCID);
    }
    async preflightUpload(size, options) {
        let withCDN = options?.withCDN ?? this._withCDN;
        if (options?.metadata != null && METADATA_KEYS.WITH_CDN in options.metadata) {
            const value = options.metadata[METADATA_KEYS.WITH_CDN];
            if (value !== '') {
                console.warn(`Warning: withCDN metadata entry has unexpected value "${value}". Expected empty string.`);
            }
            withCDN = true;
        }
        return await StorageContext.performPreflightCheck(this._warmStorageService, this._synapse.payments, size, withCDN);
    }
    async createContext(options) {
        const effectiveWithCDN = options?.withCDN ?? this._withCDN;
        const canUseDefault = options == null ||
            (options.providerId == null &&
                options.providerAddress == null &&
                options.dataSetId == null &&
                options.forceCreateDataSet !== true &&
                options.uploadBatchSize == null);
        if (canUseDefault) {
            if (this._defaultContext != null) {
                const requestedMetadata = combineMetadata(options?.metadata, effectiveWithCDN);
                if (metadataMatches(this._defaultContext.dataSetMetadata, requestedMetadata)) {
                    if (options?.callbacks != null) {
                        try {
                            options.callbacks.onProviderSelected?.(this._defaultContext.provider);
                        }
                        catch (error) {
                            console.error('Error in onProviderSelected callback:', error);
                        }
                        try {
                            options.callbacks.onDataSetResolved?.({
                                isExisting: true,
                                dataSetId: this._defaultContext.dataSetId,
                                provider: this._defaultContext.provider,
                            });
                        }
                        catch (error) {
                            console.error('Error in onDataSetResolved callback:', error);
                        }
                    }
                    return this._defaultContext;
                }
            }
            const context = await StorageContext.create(this._synapse, this._warmStorageService, {
                ...options,
                withCDN: effectiveWithCDN,
                withIpni: options?.withIpni ?? this._withIpni,
                dev: options?.dev ?? this._dev,
            });
            this._defaultContext = context;
            return context;
        }
        return await StorageContext.create(this._synapse, this._warmStorageService, {
            ...options,
            withCDN: effectiveWithCDN,
            withIpni: options?.withIpni ?? this._withIpni,
            dev: options?.dev ?? this._dev,
        });
    }
    async getDefaultContext() {
        return await this.createContext();
    }
    async findDataSets(clientAddress) {
        const address = clientAddress ?? (await this._synapse.getClient().getAddress());
        return await this._warmStorageService.getClientDataSetsWithDetails(address);
    }
    async terminateDataSet(dataSetId) {
        return this._warmStorageService.terminateDataSet(this._synapse.getSigner(), dataSetId);
    }
    async getStorageInfo() {
        try {
            const getOptionalAllowances = async () => {
                try {
                    const warmStorageAddress = this._synapse.getWarmStorageAddress();
                    const approval = await this._synapse.payments.serviceApproval(warmStorageAddress, TOKENS.USDFC);
                    return {
                        service: warmStorageAddress,
                        rateAllowance: approval.rateAllowance,
                        lockupAllowance: approval.lockupAllowance,
                        rateUsed: approval.rateUsed,
                        lockupUsed: approval.lockupUsed,
                    };
                }
                catch {
                    return null;
                }
            };
            const registryAddress = this._warmStorageService.getServiceProviderRegistryAddress();
            const spRegistry = new SPRegistryService(this._synapse.getProvider(), registryAddress);
            const resolver = new ProviderResolver(this._warmStorageService, spRegistry);
            const [pricingData, providers, allowances] = await Promise.all([
                this._warmStorageService.getServicePrice(),
                resolver.getApprovedProviders(),
                getOptionalAllowances(),
            ]);
            const epochsPerMonth = BigInt(pricingData.epochsPerMonth);
            const noCDNPerEpoch = BigInt(pricingData.pricePerTiBPerMonthNoCDN) / epochsPerMonth;
            const withCDNPerEpoch = BigInt(pricingData.pricePerTiBPerMonthWithCDN) / epochsPerMonth;
            const noCDNPerDay = BigInt(pricingData.pricePerTiBPerMonthNoCDN) / TIME_CONSTANTS.DAYS_PER_MONTH;
            const withCDNPerDay = BigInt(pricingData.pricePerTiBPerMonthWithCDN) / TIME_CONSTANTS.DAYS_PER_MONTH;
            const validProviders = providers.filter((p) => p.serviceProvider !== ethers.ZeroAddress);
            const network = this._synapse.getNetwork();
            return {
                pricing: {
                    noCDN: {
                        perTiBPerMonth: BigInt(pricingData.pricePerTiBPerMonthNoCDN),
                        perTiBPerDay: noCDNPerDay,
                        perTiBPerEpoch: noCDNPerEpoch,
                    },
                    withCDN: {
                        perTiBPerMonth: BigInt(pricingData.pricePerTiBPerMonthWithCDN),
                        perTiBPerDay: withCDNPerDay,
                        perTiBPerEpoch: withCDNPerEpoch,
                    },
                    tokenAddress: pricingData.tokenAddress,
                    tokenSymbol: 'USDFC',
                },
                providers: validProviders,
                serviceParameters: {
                    network,
                    epochsPerMonth,
                    epochsPerDay: TIME_CONSTANTS.EPOCHS_PER_DAY,
                    epochDuration: TIME_CONSTANTS.EPOCH_DURATION,
                    minUploadSize: SIZE_CONSTANTS.MIN_UPLOAD_SIZE,
                    maxUploadSize: SIZE_CONSTANTS.MAX_UPLOAD_SIZE,
                    warmStorageAddress: this._synapse.getWarmStorageAddress(),
                    paymentsAddress: this._warmStorageService.getPaymentsAddress(),
                    pdpVerifierAddress: this._warmStorageService.getPDPVerifierAddress(),
                },
                allowances,
            };
        }
        catch (error) {
            throw new Error(`Failed to get storage service information: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
}
//# sourceMappingURL=manager.js.map