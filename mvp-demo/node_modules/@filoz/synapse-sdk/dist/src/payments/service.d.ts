import { ethers } from 'ethers';
import type { RailInfo, SettlementResult, TokenAmount, TokenIdentifier } from '../types.ts';
export interface DepositCallbacks {
    onAllowanceCheck?: (current: bigint, required: bigint) => void;
    onApprovalTransaction?: (tx: ethers.TransactionResponse) => void;
    onApprovalConfirmed?: (receipt: ethers.TransactionReceipt) => void;
    onDepositStarting?: () => void;
}
export declare class PaymentsService {
    private readonly _provider;
    private readonly _signer;
    private readonly _paymentsAddress;
    private readonly _usdfcAddress;
    private readonly _disableNonceManager;
    private _usdfcContract;
    private _paymentsContract;
    constructor(provider: ethers.Provider, signer: ethers.Signer, paymentsAddress: string, usdfcAddress: string, disableNonceManager: boolean);
    private _getUsdfcContract;
    private _getPaymentsContract;
    private _getPermitSignature;
    balance(token?: TokenIdentifier): Promise<bigint>;
    accountInfo(token?: TokenIdentifier): Promise<{
        funds: bigint;
        lockupCurrent: bigint;
        lockupRate: bigint;
        lockupLastSettledAt: bigint;
        availableFunds: bigint;
    }>;
    walletBalance(token?: TokenIdentifier): Promise<bigint>;
    decimals(_token?: TokenIdentifier): number;
    allowance(spender: string, token?: TokenIdentifier): Promise<bigint>;
    approve(spender: string, amount: TokenAmount, token?: TokenIdentifier): Promise<ethers.TransactionResponse>;
    approveService(service: string, rateAllowance: TokenAmount, lockupAllowance: TokenAmount, maxLockupPeriod: TokenAmount, token?: TokenIdentifier): Promise<ethers.TransactionResponse>;
    revokeService(service: string, token?: TokenIdentifier): Promise<ethers.TransactionResponse>;
    serviceApproval(service: string, token?: TokenIdentifier): Promise<{
        isApproved: boolean;
        rateAllowance: bigint;
        rateUsed: bigint;
        lockupAllowance: bigint;
        lockupUsed: bigint;
        maxLockupPeriod: bigint;
    }>;
    deposit(amount: TokenAmount, token?: TokenIdentifier, callbacks?: DepositCallbacks): Promise<ethers.TransactionResponse>;
    depositWithPermit(amount: TokenAmount, token?: TokenIdentifier, deadline?: number | bigint): Promise<ethers.TransactionResponse>;
    depositWithPermitAndApproveOperator(amount: TokenAmount, operator: string, rateAllowance: TokenAmount, lockupAllowance: TokenAmount, maxLockupPeriod: TokenAmount, token?: TokenIdentifier, deadline?: number | bigint): Promise<ethers.TransactionResponse>;
    withdraw(amount: TokenAmount, token?: TokenIdentifier): Promise<ethers.TransactionResponse>;
    settle(railId: number | bigint, untilEpoch?: number | bigint): Promise<ethers.TransactionResponse>;
    getSettlementAmounts(railId: number | bigint, untilEpoch?: number | bigint): Promise<SettlementResult>;
    settleTerminatedRail(railId: number | bigint): Promise<ethers.TransactionResponse>;
    getRail(railId: number | bigint): Promise<{
        token: string;
        from: string;
        to: string;
        operator: string;
        validator: string;
        paymentRate: bigint;
        lockupPeriod: bigint;
        lockupFixed: bigint;
        settledUpTo: bigint;
        endEpoch: bigint;
        commissionRateBps: bigint;
        serviceFeeRecipient: string;
    }>;
    settleAuto(railId: number | bigint, untilEpoch?: number | bigint): Promise<ethers.TransactionResponse>;
    getRailsAsPayer(token?: TokenIdentifier): Promise<RailInfo[]>;
    getRailsAsPayee(token?: TokenIdentifier): Promise<RailInfo[]>;
}
//# sourceMappingURL=service.d.ts.map