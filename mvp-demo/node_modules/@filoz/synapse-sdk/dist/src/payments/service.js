import { ethers } from 'ethers';
import { CHAIN_IDS, CONTRACT_ABIS, CONTRACT_ADDRESSES, createError, EIP2612_PERMIT_TYPES, getCurrentEpoch, getFilecoinNetworkType, SETTLEMENT_FEE, TIMING_CONSTANTS, TOKENS, } from "../utils/index.js";
export class PaymentsService {
    _provider;
    _signer;
    _paymentsAddress;
    _usdfcAddress;
    _disableNonceManager;
    _usdfcContract = null;
    _paymentsContract = null;
    constructor(provider, signer, paymentsAddress, usdfcAddress, disableNonceManager) {
        this._provider = provider;
        this._signer = signer;
        this._paymentsAddress = paymentsAddress;
        this._usdfcAddress = usdfcAddress;
        this._disableNonceManager = disableNonceManager;
    }
    _getUsdfcContract() {
        if (this._usdfcContract == null) {
            this._usdfcContract = new ethers.Contract(this._usdfcAddress, CONTRACT_ABIS.ERC20, this._signer);
        }
        return this._usdfcContract;
    }
    _getPaymentsContract() {
        if (this._paymentsContract == null) {
            this._paymentsContract = new ethers.Contract(this._paymentsAddress, CONTRACT_ABIS.PAYMENTS, this._signer);
        }
        return this._paymentsContract;
    }
    async _getPermitSignature(amount, deadline, contextName) {
        const signerAddress = await this._signer.getAddress();
        const networkType = await getFilecoinNetworkType(this._provider);
        const chainId = CHAIN_IDS[networkType];
        const multicall3Address = CONTRACT_ADDRESSES.MULTICALL3[networkType];
        const multicall = new ethers.Contract(multicall3Address, CONTRACT_ABIS.MULTICALL3, this._provider);
        const erc20Interface = new ethers.Interface(CONTRACT_ABIS.ERC20);
        const permitInterface = new ethers.Interface(CONTRACT_ABIS.ERC20_PERMIT);
        const calls = [
            {
                target: this._usdfcAddress,
                allowFailure: false,
                callData: erc20Interface.encodeFunctionData('balanceOf', [signerAddress]),
            },
            {
                target: this._usdfcAddress,
                allowFailure: false,
                callData: erc20Interface.encodeFunctionData('name'),
            },
            {
                target: this._usdfcAddress,
                allowFailure: true,
                callData: permitInterface.encodeFunctionData('version'),
            },
            {
                target: this._usdfcAddress,
                allowFailure: false,
                callData: permitInterface.encodeFunctionData('nonces', [signerAddress]),
            },
        ];
        let results;
        try {
            results = await multicall.aggregate3.staticCall(calls);
        }
        catch (error) {
            throw createError('PaymentsService', contextName, 'Failed to fetch token information for permit. Ensure token contract is reachable.', error);
        }
        let usdfcBalance;
        try {
            const decoded = erc20Interface.decodeFunctionResult('balanceOf', results[0].returnData);
            usdfcBalance = decoded[0];
        }
        catch (error) {
            throw createError('PaymentsService', contextName, 'Failed to decode token balance.', error);
        }
        if (usdfcBalance < amount) {
            throw createError('PaymentsService', contextName, `Insufficient USDFC: have ${usdfcBalance.toString()}, need ${amount.toString()}`);
        }
        let tokenName;
        try {
            const decoded = erc20Interface.decodeFunctionResult('name', results[1].returnData);
            tokenName = decoded[0];
        }
        catch (error) {
            throw createError('PaymentsService', contextName, 'Failed to read token name for permit domain. Ensure token contract is reachable.', error);
        }
        let domainVersion = '1';
        if (results[2].success) {
            try {
                const decoded = permitInterface.decodeFunctionResult('version', results[2].returnData);
                const maybeVersion = decoded[0];
                if (typeof maybeVersion === 'string' && maybeVersion.length > 0) {
                    domainVersion = maybeVersion;
                }
            }
            catch {
            }
        }
        let nonce;
        try {
            const decoded = permitInterface.decodeFunctionResult('nonces', results[3].returnData);
            nonce = decoded[0];
        }
        catch (error) {
            throw createError('PaymentsService', contextName, 'Token does not appear to support EIP-2612 permit (nonces() unavailable).', error);
        }
        const domain = {
            name: tokenName,
            version: domainVersion,
            chainId,
            verifyingContract: this._usdfcAddress,
        };
        const value = {
            owner: signerAddress,
            spender: this._paymentsAddress,
            value: amount,
            nonce,
            deadline,
        };
        let signatureHex;
        try {
            signatureHex = await this._signer.signTypedData(domain, EIP2612_PERMIT_TYPES, value);
        }
        catch (error) {
            throw createError('PaymentsService', contextName, 'Failed to sign EIP-2612 permit. Ensure your wallet supports typed data signing.', error);
        }
        return ethers.Signature.from(signatureHex);
    }
    async balance(token = TOKENS.USDFC) {
        if (token !== TOKENS.USDFC) {
            throw createError('PaymentsService', 'payments contract balance check', `Token "${token}" is not supported. Currently only USDFC token is supported for payments contract balance queries.`);
        }
        const accountInfo = await this.accountInfo(token);
        return accountInfo.availableFunds;
    }
    async accountInfo(token = TOKENS.USDFC) {
        if (token !== TOKENS.USDFC) {
            throw createError('PaymentsService', 'account info', `Token "${token}" is not supported. Currently only USDFC token is supported.`);
        }
        const signerAddress = await this._signer.getAddress();
        const paymentsContract = this._getPaymentsContract();
        let accountData;
        try {
            accountData = await paymentsContract.accounts(this._usdfcAddress, signerAddress);
        }
        catch (contractCallError) {
            throw createError('PaymentsService', 'account info', 'Failed to read account information from payments contract. This could indicate the contract is not properly deployed, the ABI is incorrect, or there are network connectivity issues.', contractCallError);
        }
        const [funds, lockupCurrent, lockupRate, lockupLastSettledAt] = accountData;
        const currentEpoch = await getCurrentEpoch(this._provider);
        const epochsSinceSettlement = currentEpoch - BigInt(lockupLastSettledAt);
        const actualLockup = BigInt(lockupCurrent) + BigInt(lockupRate) * epochsSinceSettlement;
        const availableFunds = BigInt(funds) - actualLockup;
        return {
            funds: BigInt(funds),
            lockupCurrent: BigInt(lockupCurrent),
            lockupRate: BigInt(lockupRate),
            lockupLastSettledAt: BigInt(lockupLastSettledAt),
            availableFunds: availableFunds > 0n ? availableFunds : 0n,
        };
    }
    async walletBalance(token) {
        if (token == null || token === TOKENS.FIL) {
            try {
                const address = await this._signer.getAddress();
                const balance = await this._provider.getBalance(address);
                return balance;
            }
            catch (error) {
                throw createError('PaymentsService', 'wallet FIL balance check', 'Unable to retrieve FIL balance from wallet. This could be due to network connectivity issues, RPC endpoint problems, or wallet connection issues.', error);
            }
        }
        if (token === TOKENS.USDFC) {
            try {
                const address = await this._signer.getAddress();
                const usdfcContract = this._getUsdfcContract();
                const balance = await usdfcContract.balanceOf(address);
                return balance;
            }
            catch (error) {
                throw createError('PaymentsService', 'wallet USDFC balance check', 'Unexpected error while checking USDFC token balance in wallet.', error);
            }
        }
        throw createError('PaymentsService', 'wallet balance', `Token "${token}" is not supported. Currently only FIL and USDFC tokens are supported.`);
    }
    decimals(_token = TOKENS.USDFC) {
        return 18;
    }
    async allowance(spender, token = TOKENS.USDFC) {
        if (token !== TOKENS.USDFC) {
            throw createError('PaymentsService', 'allowance', `Token "${token}" is not supported. Currently only USDFC token is supported.`);
        }
        const signerAddress = await this._signer.getAddress();
        const usdfcContract = this._getUsdfcContract();
        try {
            const currentAllowance = await usdfcContract.allowance(signerAddress, spender);
            return currentAllowance;
        }
        catch (error) {
            throw createError('PaymentsService', 'allowance check', 'Failed to check token allowance. This could indicate network connectivity issues or an invalid spender address.', error);
        }
    }
    async approve(spender, amount, token = TOKENS.USDFC) {
        if (token !== TOKENS.USDFC) {
            throw createError('PaymentsService', 'approve', `Token "${token}" is not supported. Currently only USDFC token is supported.`);
        }
        const approveAmount = typeof amount === 'bigint' ? amount : BigInt(amount);
        if (approveAmount < 0n) {
            throw createError('PaymentsService', 'approve', 'Approval amount cannot be negative');
        }
        const signerAddress = await this._signer.getAddress();
        const usdfcContract = this._getUsdfcContract();
        const txOptions = {};
        if (this._disableNonceManager) {
            const approvalNonce = await this._provider.getTransactionCount(signerAddress, 'pending');
            txOptions.nonce = approvalNonce;
        }
        try {
            const approveTx = await usdfcContract.approve(spender, approveAmount, txOptions);
            return approveTx;
        }
        catch (error) {
            throw createError('PaymentsService', 'approve', `Failed to approve ${spender} to spend ${approveAmount.toString()} ${token}`, error);
        }
    }
    async approveService(service, rateAllowance, lockupAllowance, maxLockupPeriod, token = TOKENS.USDFC) {
        if (token !== TOKENS.USDFC) {
            throw createError('PaymentsService', 'approveService', `Token "${token}" is not supported. Currently only USDFC token is supported.`);
        }
        const rateAllowanceBigint = typeof rateAllowance === 'bigint' ? rateAllowance : BigInt(rateAllowance);
        const lockupAllowanceBigint = typeof lockupAllowance === 'bigint' ? lockupAllowance : BigInt(lockupAllowance);
        const maxLockupPeriodBigint = typeof maxLockupPeriod === 'bigint' ? maxLockupPeriod : BigInt(maxLockupPeriod);
        if (rateAllowanceBigint < 0n || lockupAllowanceBigint < 0n || maxLockupPeriodBigint < 0n) {
            throw createError('PaymentsService', 'approveService', 'Allowance values cannot be negative');
        }
        const signerAddress = await this._signer.getAddress();
        const paymentsContract = this._getPaymentsContract();
        const txOptions = {};
        if (this._disableNonceManager) {
            const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending');
            txOptions.nonce = currentNonce;
        }
        try {
            const approveTx = await paymentsContract.setOperatorApproval(this._usdfcAddress, service, true, rateAllowanceBigint, lockupAllowanceBigint, maxLockupPeriodBigint, txOptions);
            return approveTx;
        }
        catch (error) {
            throw createError('PaymentsService', 'approveService', `Failed to approve service ${service} as operator for ${token}`, error);
        }
    }
    async revokeService(service, token = TOKENS.USDFC) {
        if (token !== TOKENS.USDFC) {
            throw createError('PaymentsService', 'revokeService', `Token "${token}" is not supported. Currently only USDFC token is supported.`);
        }
        const signerAddress = await this._signer.getAddress();
        const paymentsContract = this._getPaymentsContract();
        const txOptions = {};
        if (this._disableNonceManager) {
            const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending');
            txOptions.nonce = currentNonce;
        }
        try {
            const revokeTx = await paymentsContract.setOperatorApproval(this._usdfcAddress, service, false, 0n, 0n, 0n, txOptions);
            return revokeTx;
        }
        catch (error) {
            throw createError('PaymentsService', 'revokeService', `Failed to revoke service ${service} as operator for ${token}`, error);
        }
    }
    async serviceApproval(service, token = TOKENS.USDFC) {
        if (token !== TOKENS.USDFC) {
            throw createError('PaymentsService', 'serviceApproval', `Token "${token}" is not supported. Currently only USDFC token is supported.`);
        }
        const signerAddress = await this._signer.getAddress();
        const paymentsContract = this._getPaymentsContract();
        try {
            const approval = await paymentsContract.operatorApprovals(this._usdfcAddress, signerAddress, service);
            return {
                isApproved: approval[0],
                rateAllowance: approval[1],
                lockupAllowance: approval[2],
                rateUsed: approval[3],
                lockupUsed: approval[4],
                maxLockupPeriod: approval[5],
            };
        }
        catch (error) {
            throw createError('PaymentsService', 'serviceApproval', `Failed to check service approval status for ${service}`, error);
        }
    }
    async deposit(amount, token = TOKENS.USDFC, callbacks) {
        if (token !== TOKENS.USDFC) {
            throw createError('PaymentsService', 'deposit', `Unsupported token: ${token}`);
        }
        const depositAmountBigint = typeof amount === 'bigint' ? amount : BigInt(amount);
        if (depositAmountBigint <= 0n) {
            throw createError('PaymentsService', 'deposit', 'Invalid amount');
        }
        const signerAddress = await this._signer.getAddress();
        const usdfcContract = this._getUsdfcContract();
        const paymentsContract = this._getPaymentsContract();
        const usdfcBalance = await usdfcContract.balanceOf(signerAddress);
        if (usdfcBalance < depositAmountBigint) {
            throw createError('PaymentsService', 'deposit', `Insufficient USDFC: have ${BigInt(usdfcBalance).toString()}, need ${depositAmountBigint.toString()}`);
        }
        const currentAllowance = await this.allowance(this._paymentsAddress, token);
        callbacks?.onAllowanceCheck?.(currentAllowance, depositAmountBigint);
        if (currentAllowance < depositAmountBigint) {
            const approveTx = await this.approve(this._paymentsAddress, depositAmountBigint, token);
            callbacks?.onApprovalTransaction?.(approveTx);
            const approvalReceipt = await approveTx.wait(TIMING_CONSTANTS.TRANSACTION_CONFIRMATIONS);
            if (approvalReceipt != null) {
                callbacks?.onApprovalConfirmed?.(approvalReceipt);
            }
        }
        callbacks?.onDepositStarting?.();
        const txOptions = {};
        if (this._disableNonceManager) {
            const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending');
            txOptions.nonce = currentNonce;
        }
        const depositTx = await paymentsContract.deposit(this._usdfcAddress, signerAddress, depositAmountBigint, txOptions);
        return depositTx;
    }
    async depositWithPermit(amount, token = TOKENS.USDFC, deadline) {
        if (token !== TOKENS.USDFC) {
            throw createError('PaymentsService', 'depositWithPermit', `Unsupported token: ${token}`);
        }
        const depositAmountBigint = typeof amount === 'bigint' ? amount : BigInt(amount);
        if (depositAmountBigint <= 0n) {
            throw createError('PaymentsService', 'depositWithPermit', 'Invalid amount');
        }
        const signerAddress = await this._signer.getAddress();
        const paymentsContract = this._getPaymentsContract();
        const permitDeadline = deadline == null
            ? BigInt(Math.floor(Date.now() / 1000) + TIMING_CONSTANTS.PERMIT_DEADLINE_DURATION)
            : BigInt(deadline);
        const signature = await this._getPermitSignature(depositAmountBigint, permitDeadline, 'depositWithPermit');
        const txOptions = {};
        if (this._disableNonceManager) {
            const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending');
            txOptions.nonce = currentNonce;
        }
        try {
            const tx = await paymentsContract.depositWithPermit(this._usdfcAddress, signerAddress, depositAmountBigint, permitDeadline, signature.v, signature.r, signature.s, txOptions);
            return tx;
        }
        catch (error) {
            throw createError('PaymentsService', 'depositWithPermit', 'Failed to execute depositWithPermit on Payments contract.', error);
        }
    }
    async depositWithPermitAndApproveOperator(amount, operator, rateAllowance, lockupAllowance, maxLockupPeriod, token = TOKENS.USDFC, deadline) {
        if (token !== TOKENS.USDFC) {
            throw createError('PaymentsService', 'depositWithPermitAndApproveOperator', `Unsupported token: ${token}`);
        }
        const depositAmountBigint = typeof amount === 'bigint' ? amount : BigInt(amount);
        if (depositAmountBigint <= 0n) {
            throw createError('PaymentsService', 'depositWithPermitAndApproveOperator', 'Invalid amount');
        }
        const rateAllowanceBigint = typeof rateAllowance === 'bigint' ? rateAllowance : BigInt(rateAllowance);
        const lockupAllowanceBigint = typeof lockupAllowance === 'bigint' ? lockupAllowance : BigInt(lockupAllowance);
        const maxLockupPeriodBigint = typeof maxLockupPeriod === 'bigint' ? maxLockupPeriod : BigInt(maxLockupPeriod);
        if (rateAllowanceBigint < 0n || lockupAllowanceBigint < 0n || maxLockupPeriodBigint < 0n) {
            throw createError('PaymentsService', 'depositWithPermitAndApproveOperator', 'Allowance values cannot be negative');
        }
        const signerAddress = await this._signer.getAddress();
        const paymentsContract = this._getPaymentsContract();
        const permitDeadline = deadline == null
            ? BigInt(Math.floor(Date.now() / 1000) + TIMING_CONSTANTS.PERMIT_DEADLINE_DURATION)
            : BigInt(deadline);
        const signature = await this._getPermitSignature(depositAmountBigint, permitDeadline, 'depositWithPermitAndApproveOperator');
        const txOptions = {};
        if (this._disableNonceManager) {
            const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending');
            txOptions.nonce = currentNonce;
        }
        try {
            const tx = await paymentsContract.depositWithPermitAndApproveOperator(this._usdfcAddress, signerAddress, depositAmountBigint, permitDeadline, signature.v, signature.r, signature.s, operator, rateAllowanceBigint, lockupAllowanceBigint, maxLockupPeriodBigint, txOptions);
            return tx;
        }
        catch (error) {
            throw createError('PaymentsService', 'depositWithPermitAndApproveOperator', 'Failed to execute depositWithPermitAndApproveOperator on Payments contract.', error);
        }
    }
    async withdraw(amount, token = TOKENS.USDFC) {
        if (token !== TOKENS.USDFC) {
            throw createError('PaymentsService', 'withdraw', `Unsupported token: ${token}`);
        }
        const withdrawAmountBigint = typeof amount === 'bigint' ? amount : BigInt(amount);
        if (withdrawAmountBigint <= 0n) {
            throw createError('PaymentsService', 'withdraw', 'Invalid amount');
        }
        const signerAddress = await this._signer.getAddress();
        const paymentsContract = this._getPaymentsContract();
        const accountInfo = await this.accountInfo(token);
        if (accountInfo.availableFunds < withdrawAmountBigint) {
            throw createError('PaymentsService', 'withdraw', `Insufficient available balance: have ${accountInfo.availableFunds.toString()}, need ${withdrawAmountBigint.toString()}`);
        }
        const txOptions = {};
        if (this._disableNonceManager) {
            const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending');
            txOptions.nonce = currentNonce;
        }
        const tx = await paymentsContract.withdraw(this._usdfcAddress, withdrawAmountBigint, txOptions);
        return tx;
    }
    async settle(railId, untilEpoch) {
        const railIdBigint = typeof railId === 'bigint' ? railId : BigInt(railId);
        const [signerAddress, currentEpoch] = await Promise.all([
            this._signer.getAddress(),
            untilEpoch == null ? getCurrentEpoch(this._provider) : Promise.resolve(null),
        ]);
        const untilEpochBigint = untilEpoch == null ? currentEpoch : BigInt(untilEpoch);
        const paymentsContract = this._getPaymentsContract();
        const txOptions = {
            value: SETTLEMENT_FEE,
        };
        if (this._disableNonceManager) {
            const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending');
            txOptions.nonce = currentNonce;
        }
        try {
            const tx = await paymentsContract.settleRail(railIdBigint, untilEpochBigint, txOptions);
            return tx;
        }
        catch (error) {
            throw createError('PaymentsService', 'settle', `Failed to settle rail ${railIdBigint.toString()} up to epoch ${untilEpochBigint.toString()}`, error);
        }
    }
    async getSettlementAmounts(railId, untilEpoch) {
        const railIdBigint = typeof railId === 'bigint' ? railId : BigInt(railId);
        const currentEpoch = untilEpoch == null ? await getCurrentEpoch(this._provider) : null;
        const untilEpochBigint = untilEpoch == null ? currentEpoch : BigInt(untilEpoch);
        const paymentsContract = this._getPaymentsContract();
        try {
            const result = await paymentsContract.settleRail.staticCall(railIdBigint, untilEpochBigint, {
                value: SETTLEMENT_FEE,
            });
            return {
                totalSettledAmount: result[0],
                totalNetPayeeAmount: result[1],
                totalOperatorCommission: result[2],
                finalSettledEpoch: result[3],
                note: result[4],
            };
        }
        catch (error) {
            throw createError('PaymentsService', 'getSettlementAmounts', `Failed to get settlement amounts for rail ${railIdBigint.toString()} up to epoch ${untilEpochBigint.toString()}`, error);
        }
    }
    async settleTerminatedRail(railId) {
        const railIdBigint = typeof railId === 'bigint' ? railId : BigInt(railId);
        const signerAddress = await this._signer.getAddress();
        const paymentsContract = this._getPaymentsContract();
        const txOptions = {};
        if (this._disableNonceManager) {
            const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending');
            txOptions.nonce = currentNonce;
        }
        try {
            const tx = await paymentsContract.settleTerminatedRailWithoutValidation(railIdBigint, txOptions);
            return tx;
        }
        catch (error) {
            throw createError('PaymentsService', 'settleTerminatedRail', `Failed to settle terminated rail ${railIdBigint.toString()}`, error);
        }
    }
    async getRail(railId) {
        const railIdBigint = typeof railId === 'bigint' ? railId : BigInt(railId);
        const paymentsContract = this._getPaymentsContract();
        try {
            const rail = await paymentsContract.getRail(railIdBigint);
            return {
                token: rail.token,
                from: rail.from,
                to: rail.to,
                operator: rail.operator,
                validator: rail.validator,
                paymentRate: rail.paymentRate,
                lockupPeriod: rail.lockupPeriod,
                lockupFixed: rail.lockupFixed,
                settledUpTo: rail.settledUpTo,
                endEpoch: rail.endEpoch,
                commissionRateBps: rail.commissionRateBps,
                serviceFeeRecipient: rail.serviceFeeRecipient,
            };
        }
        catch (error) {
            if (error.message?.includes('RailInactiveOrSettled')) {
                throw createError('PaymentsService', 'getRail', `Rail ${railIdBigint.toString()} does not exist or is inactive`);
            }
            throw createError('PaymentsService', 'getRail', `Failed to get rail ${railIdBigint.toString()}`, error);
        }
    }
    async settleAuto(railId, untilEpoch) {
        const railIdBigint = typeof railId === 'bigint' ? railId : BigInt(railId);
        const rail = await this.getRail(railIdBigint);
        if (rail.endEpoch > 0n) {
            return await this.settleTerminatedRail(railIdBigint);
        }
        else {
            return await this.settle(railIdBigint, untilEpoch);
        }
    }
    async getRailsAsPayer(token = TOKENS.USDFC) {
        if (token !== TOKENS.USDFC) {
            throw createError('PaymentsService', 'getRailsAsPayer', `Token "${token}" is not supported. Currently only USDFC token is supported.`);
        }
        const signerAddress = await this._signer.getAddress();
        const paymentsContract = this._getPaymentsContract();
        try {
            const rails = await paymentsContract.getRailsForPayerAndToken(signerAddress, this._usdfcAddress);
            return rails.map((rail) => ({
                railId: Number(rail.railId),
                isTerminated: rail.isTerminated,
                endEpoch: Number(rail.endEpoch),
            }));
        }
        catch (error) {
            throw createError('PaymentsService', 'getRailsAsPayer', 'Failed to get rails where wallet is payer', error);
        }
    }
    async getRailsAsPayee(token = TOKENS.USDFC) {
        if (token !== TOKENS.USDFC) {
            throw createError('PaymentsService', 'getRailsAsPayee', `Token "${token}" is not supported. Currently only USDFC token is supported.`);
        }
        const signerAddress = await this._signer.getAddress();
        const paymentsContract = this._getPaymentsContract();
        try {
            const rails = await paymentsContract.getRailsForPayeeAndToken(signerAddress, this._usdfcAddress);
            return rails.map((rail) => ({
                railId: Number(rail.railId),
                isTerminated: rail.isTerminated,
                endEpoch: Number(rail.endEpoch),
            }));
        }
        catch (error) {
            throw createError('PaymentsService', 'getRailsAsPayee', 'Failed to get rails where wallet is payee', error);
        }
    }
}
//# sourceMappingURL=service.js.map