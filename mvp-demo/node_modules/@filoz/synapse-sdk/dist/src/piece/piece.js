import * as Hasher from '@web3-storage/data-segment/multihash';
import { Unpadded } from '@web3-storage/data-segment/piece/size';
import { CID } from 'multiformats/cid';
import * as Raw from 'multiformats/codecs/raw';
import * as Digest from 'multiformats/hashes/digest';
import * as Link from 'multiformats/link';
const FIL_COMMITMENT_UNSEALED = 0xf101;
const SHA2_256_TRUNC254_PADDED = 0x1012;
function parsePieceCID(pieceCidString) {
    try {
        const cid = CID.parse(pieceCidString);
        if (isValidPieceCID(cid)) {
            return cid;
        }
    }
    catch {
    }
    return null;
}
function parseLegacyPieceCID(pieceCidString) {
    try {
        const cid = CID.parse(pieceCidString);
        if (isValidLegacyPieceCID(cid)) {
            return cid;
        }
    }
    catch {
    }
    return null;
}
function isValidPieceCID(cid) {
    return cid.code === Raw.code && cid.multihash.code === Hasher.code;
}
function isValidLegacyPieceCID(cid) {
    return cid.code === FIL_COMMITMENT_UNSEALED && cid.multihash.code === SHA2_256_TRUNC254_PADDED;
}
export function asPieceCID(pieceCidInput) {
    if (typeof pieceCidInput === 'string') {
        return parsePieceCID(pieceCidInput);
    }
    if (typeof pieceCidInput === 'object' && CID.asCID(pieceCidInput) !== null) {
        if (isValidPieceCID(pieceCidInput)) {
            return pieceCidInput;
        }
    }
    return null;
}
export function asLegacyPieceCID(pieceCidInput) {
    const pieceCid = asPieceCID(pieceCidInput);
    if (pieceCid != null) {
        const digest = Digest.create(SHA2_256_TRUNC254_PADDED, pieceCid.multihash.digest.subarray(-32));
        return Link.create(FIL_COMMITMENT_UNSEALED, digest);
    }
    if (typeof pieceCidInput === 'string') {
        return parseLegacyPieceCID(pieceCidInput);
    }
    if (typeof pieceCidInput === 'object' && CID.asCID(pieceCidInput) !== null) {
        if (isValidLegacyPieceCID(pieceCidInput)) {
            return pieceCidInput;
        }
    }
    return null;
}
export function calculate(data) {
    const hasher = Hasher.create();
    const chunkSize = 2048;
    for (let i = 0; i < data.length; i += chunkSize) {
        hasher.write(data.subarray(i, i + chunkSize));
    }
    const digest = hasher.digest();
    return Link.create(Raw.code, digest);
}
export function createPieceCIDStream() {
    const hasher = Hasher.create();
    let finished = false;
    let pieceCid = null;
    const stream = new TransformStream({
        transform(chunk, controller) {
            hasher.write(chunk);
            controller.enqueue(chunk);
        },
        flush() {
            const digest = hasher.digest();
            pieceCid = Link.create(Raw.code, digest);
            finished = true;
        },
    });
    return {
        stream,
        getPieceCID: () => {
            if (!finished) {
                return null;
            }
            return pieceCid;
        },
    };
}
export function getSizeFromPieceCID(pieceCidInput) {
    const pieceCid = asPieceCID(pieceCidInput);
    if (pieceCid == null) {
        throw new Error('Invalid PieceCID: input must be a valid PieceCIDv2');
    }
    const digest = Hasher.Digest.fromBytes(pieceCid.multihash.bytes);
    const height = digest.height;
    const padding = digest.padding;
    const rawSize = Unpadded.fromPiece({ height, padding });
    if (rawSize > Number.MAX_SAFE_INTEGER) {
        throw new Error(`Raw size ${rawSize} exceeds maximum safe integer`);
    }
    return Number(rawSize);
}
//# sourceMappingURL=piece.js.map