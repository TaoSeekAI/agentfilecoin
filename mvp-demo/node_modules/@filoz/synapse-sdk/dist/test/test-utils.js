import { ethers } from 'ethers';
export function createMockSigner(address = '0x1234567890123456789012345678901234567890', provider) {
    const signer = {
        provider: provider ?? null,
        async getAddress() { return address; },
        async signTransaction() { return '0xsignedtransaction'; },
        async signMessage() { return '0xsignedmessage'; },
        async signTypedData() { return '0xsignedtypeddata'; },
        connect(newProvider) {
            return createMockSigner(address, newProvider);
        },
        async sendTransaction(transaction) {
            if (provider != null) {
                return provider.sendTransaction(transaction);
            }
            throw new Error('No provider for sendTransaction');
        }
    };
    return signer;
}
export function createMockProvider(chainId = 314159) {
    const network = new ethers.Network('test', chainId);
    const provider = {
        getNetwork: async () => network,
        getSigner: async function () {
            return createMockSigner('0x1234567890123456789012345678901234567890', this);
        },
        getBalance: async (address) => ethers.parseEther('100'),
        getTransactionCount: async (address, blockTag) => 0,
        call: async (transaction) => {
            const data = transaction.data;
            if (data == null)
                return '0x';
            if (data.includes('70a08231') === true) {
                return ethers.zeroPadValue(ethers.toBeHex(ethers.parseUnits('1000', 18)), 32);
            }
            if (data.includes('313ce567') === true) {
                return ethers.zeroPadValue(ethers.toBeHex(18), 32);
            }
            if (data.includes('dd62ed3e') === true) {
                return ethers.zeroPadValue(ethers.toBeHex(0), 32);
            }
            if (data.includes('095ea7b3') === true) {
                return ethers.zeroPadValue(ethers.toBeHex(1), 32);
            }
            if (data.includes('ad74b775') === true) {
                const funds = ethers.parseUnits('500', 18);
                const lockedFunds = 0n;
                const frozen = false;
                return ethers.AbiCoder.defaultAbiCoder().encode(['uint256', 'uint256', 'bool'], [funds, lockedFunds, frozen]);
            }
            if (data.includes('e3d4c69e') === true) {
                const isApproved = false;
                const rateAllowance = 0n;
                const rateUsed = 0n;
                const lockupAllowance = 0n;
                const lockupUsed = 0n;
                return ethers.AbiCoder.defaultAbiCoder().encode(['bool', 'uint256', 'uint256', 'uint256', 'uint256'], [isApproved, rateAllowance, rateUsed, lockupAllowance, lockupUsed]);
            }
            return '0x';
        },
        getBlockNumber: async () => 1000000,
        getCode: async (address) => '0x1234',
        estimateGas: async (transaction) => 21000n,
        getFeeData: async () => new ethers.FeeData(ethers.parseUnits('1', 'gwei'), ethers.parseUnits('1', 'gwei'), ethers.parseUnits('1', 'gwei')),
        getLogs: async (filter) => [],
        resolveName: async (name) => null,
        lookupAddress: async (address) => null,
        broadcastTransaction: async (signedTx) => {
            throw new Error('Not implemented in mock');
        },
        getBlock: async (blockHashOrBlockTag) => {
            throw new Error('Not implemented in mock');
        },
        getTransaction: async (hash) => {
            throw new Error('Not implemented in mock');
        },
        getTransactionReceipt: async (hash) => {
            return {
                hash,
                from: '0x1234567890123456789012345678901234567890',
                to: null,
                contractAddress: null,
                index: 0,
                root: '',
                gasUsed: 50000n,
                gasPrice: 1000000000n,
                cumulativeGasUsed: 50000n,
                effectiveGasPrice: 1000000000n,
                logsBloom: '',
                blockHash: '',
                blockNumber: 1000000,
                logs: [],
                status: 1
            };
        },
        waitForTransaction: async (hash, confirmations, timeout) => {
            throw new Error('Not implemented in mock');
        },
        sendTransaction: async (transaction) => {
            const hash = '0x' + Math.random().toString(16).substring(2).padEnd(64, '0');
            return {
                hash,
                from: transaction.from ?? '',
                to: transaction.to ?? null,
                data: transaction.data ?? '',
                value: transaction.value ?? 0n,
                chainId: 314159n,
                gasLimit: 100000n,
                gasPrice: 1000000000n,
                nonce: 0,
                wait: async () => ({
                    hash,
                    from: transaction.from ?? '',
                    to: transaction.to ?? null,
                    contractAddress: null,
                    index: 0,
                    root: '',
                    gasUsed: 50000n,
                    gasPrice: 1000000000n,
                    cumulativeGasUsed: 50000n,
                    effectiveGasPrice: 1000000000n,
                    logsBloom: '',
                    blockHash: '',
                    blockNumber: 1000000,
                    logs: [],
                    status: 1
                })
            };
        }
    };
    return provider;
}
//# sourceMappingURL=test-utils.js.map