import { assert } from 'chai';
import { ethers } from 'ethers';
import { PDPTool, PDPAuthHelper } from '../pdp/index.js';
import { asCommP } from '../commp/index.js';
class MockPDPServer {
    server = null;
    handlers = new Map();
    addHandler(method, path, handler) {
        this.handlers.set(`${method}:${path}`, handler);
    }
    async start(port) {
        return await new Promise((resolve) => {
            const baseUrl = `http://localhost:${port}`;
            resolve(baseUrl);
        });
    }
    async stop() {
        return await Promise.resolve();
    }
}
describe('PDPTool', () => {
    let pdpTool;
    let authHelper;
    let mockServer;
    let serverUrl;
    const TEST_PRIVATE_KEY = '0x1234567890123456789012345678901234567890123456789012345678901234';
    const TEST_CONTRACT_ADDRESS = '0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f';
    const TEST_CHAIN_ID = 31337;
    beforeEach(async () => {
        const signer = new ethers.Wallet(TEST_PRIVATE_KEY);
        authHelper = new PDPAuthHelper(TEST_CONTRACT_ADDRESS, signer, BigInt(TEST_CHAIN_ID));
        mockServer = new MockPDPServer();
        serverUrl = await mockServer.start(0);
        pdpTool = new PDPTool(serverUrl, authHelper);
    });
    afterEach(async () => {
        await mockServer.stop();
    });
    describe('constructor', () => {
        it('should create PDPTool with valid API endpoint', () => {
            const tool = new PDPTool('https://example.com', authHelper);
            assert.strictEqual(tool.getApiEndpoint(), 'https://example.com');
        });
        it('should remove trailing slash from API endpoint', () => {
            const tool = new PDPTool('https://example.com/', authHelper);
            assert.strictEqual(tool.getApiEndpoint(), 'https://example.com');
        });
        it('should throw error for empty API endpoint', () => {
            assert.throws(() => {
                new PDPTool('', authHelper);
            }, 'PDP API endpoint is required');
        });
    });
    describe('createProofSet', () => {
        it('should handle successful proof set creation', async () => {
            const mockTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
            const originalFetch = global.fetch;
            global.fetch = async (input, init) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.href : input.url;
                assert.include(url, '/pdp/proof-sets');
                assert.strictEqual(init?.method, 'POST');
                const body = JSON.parse(init?.body);
                assert.isDefined(body.recordKeeper);
                assert.isDefined(body.extraData);
                return {
                    status: 201,
                    headers: {
                        get: (header) => {
                            if (header === 'Location') {
                                return `/pdp/proof-sets/created/${mockTxHash}`;
                            }
                            return null;
                        }
                    }
                };
            };
            try {
                const result = await pdpTool.createProofSet(0, '0x70997970C51812dc3A010C7d01b50e0d17dc79C8', false, TEST_CONTRACT_ADDRESS);
                assert.strictEqual(result.txHash, mockTxHash);
                assert.include(result.statusUrl, mockTxHash);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
    });
    describe('addRoots', () => {
        it('should validate input parameters', async () => {
            try {
                await pdpTool.addRoots(1, 0, 0, []);
                assert.fail('Should have thrown error for empty root entries');
            }
            catch (error) {
                assert.include(error.message, 'At least one root must be provided');
            }
            const invalidRawSize = {
                cid: 'baga6ea4seaqpy7usqklokfx2vxuynmupslkeutzexe2uqurdg5vhtebhxqmpqmy',
                rawSize: -1
            };
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return {
                    status: 400,
                    statusText: 'Bad Request',
                    text: async () => 'Invalid raw size'
                };
            };
            try {
                await pdpTool.addRoots(1, 0, 0, [invalidRawSize]);
                assert.fail('Should have thrown error for invalid raw size');
            }
            catch (error) {
                assert.include(error.message, 'Failed to add roots to proof set');
            }
            finally {
                global.fetch = originalFetch;
            }
            const invalidCommP = {
                cid: 'invalid-commp-string',
                rawSize: 1024
            };
            try {
                await pdpTool.addRoots(1, 0, 0, [invalidCommP]);
                assert.fail('Should have thrown error for invalid CommP');
            }
            catch (error) {
                assert.include(error.message, 'Invalid CommP');
            }
        });
        it('should handle successful root addition', async () => {
            const validRootData = [
                {
                    cid: 'baga6ea4seaqpy7usqklokfx2vxuynmupslkeutzexe2uqurdg5vhtebhxqmpqmy',
                    rawSize: 1024 * 1024
                }
            ];
            const originalFetch = global.fetch;
            global.fetch = async (input, init) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.href : input.url;
                assert.include(url, '/pdp/proof-sets/1/roots');
                assert.strictEqual(init?.method, 'POST');
                const body = JSON.parse(init?.body);
                assert.isDefined(body.roots);
                assert.isDefined(body.extraData);
                assert.strictEqual(body.roots.length, 1);
                assert.strictEqual(body.roots[0].rootCid, validRootData[0].cid);
                assert.strictEqual(body.roots[0].subroots.length, 1);
                assert.strictEqual(body.roots[0].subroots[0].subrootCid, validRootData[0].cid);
                return {
                    status: 201,
                    text: async () => 'Roots added successfully'
                };
            };
            try {
                const result = await pdpTool.addRoots(1, 0, 0, validRootData);
                assert.isDefined(result);
                assert.isDefined(result.message);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should handle server errors appropriately', async () => {
            const validRootData = [
                {
                    cid: 'baga6ea4seaqpy7usqklokfx2vxuynmupslkeutzexe2uqurdg5vhtebhxqmpqmy',
                    rawSize: 1024 * 1024
                }
            ];
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return {
                    status: 400,
                    statusText: 'Bad Request',
                    text: async () => 'Invalid root CID'
                };
            };
            try {
                await pdpTool.addRoots(1, 0, 0, validRootData);
                assert.fail('Should have thrown error for server error');
            }
            catch (error) {
                assert.include(error.message, 'Failed to add roots to proof set: 400 Bad Request - Invalid root CID');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should handle multiple roots', async () => {
            const commP1 = asCommP('baga6ea4seaqpy7usqklokfx2vxuynmupslkeutzexe2uqurdg5vhtebhxqmpqmy');
            const commP2 = asCommP('baga6ea4seaqkt24j5gbf2ye2wual5gn7a5yl2tqb52v2sk4nvur4bdy7lg76cdy');
            assert.isNotNull(commP1);
            assert.isNotNull(commP2);
            if (commP1 == null || commP2 == null) {
                throw new Error('Failed to parse test CommPs');
            }
            const multipleRootData = [
                {
                    cid: commP1,
                    rawSize: 1024 * 1024
                },
                {
                    cid: 'baga6ea4seaqkt24j5gbf2ye2wual5gn7a5yl2tqb52v2sk4nvur4bdy7lg76cdy',
                    rawSize: 2048 * 1024
                }
            ];
            const originalFetch = global.fetch;
            global.fetch = async (input, init) => {
                const body = JSON.parse(init?.body);
                assert.strictEqual(body.roots.length, 2);
                assert.strictEqual(body.roots[0].subroots.length, 1);
                assert.strictEqual(body.roots[1].subroots.length, 1);
                assert.strictEqual(body.roots[0].rootCid, body.roots[0].subroots[0].subrootCid);
                assert.strictEqual(body.roots[1].rootCid, body.roots[1].subroots[0].subrootCid);
                return {
                    status: 201,
                    text: async () => 'Multiple roots added successfully'
                };
            };
            try {
                const result = await pdpTool.addRoots(1, 0, 0, multipleRootData);
                assert.isDefined(result);
                assert.isDefined(result.message);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
    });
    describe('getProofSetCreationStatus', () => {
        it('should handle successful status check', async () => {
            const mockTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
            const mockResponse = {
                createMessageHash: mockTxHash,
                proofsetCreated: true,
                service: 'test-service',
                txStatus: 'confirmed',
                ok: true,
                proofSetId: 123
            };
            const originalFetch = global.fetch;
            global.fetch = async (input, init) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.href : input.url;
                assert.include(url, `/pdp/proof-sets/created/${mockTxHash}`);
                assert.strictEqual(init?.method, 'GET');
                return {
                    status: 200,
                    json: async () => mockResponse
                };
            };
            try {
                const result = await pdpTool.getProofSetCreationStatus(mockTxHash);
                assert.deepStrictEqual(result, mockResponse);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should handle not found status', async () => {
            const mockTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return {
                    status: 404
                };
            };
            try {
                await pdpTool.getProofSetCreationStatus(mockTxHash);
                assert.fail('Should have thrown error for not found status');
            }
            catch (error) {
                assert.include(error.message, `Proof set creation not found for transaction hash: ${mockTxHash}`);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
    });
    describe('getters', () => {
        it('should return API endpoint', () => {
            assert.strictEqual(pdpTool.getApiEndpoint(), serverUrl);
        });
        it('should return PDPAuthHelper instance', () => {
            assert.strictEqual(pdpTool.getPDPAuthHelper(), authHelper);
        });
    });
});
//# sourceMappingURL=pdp-tool.test.js.map