import { assert } from 'chai';
import { Synapse } from '../synapse.js';
import { SynapsePayments } from '../payments/index.js';
import { createMockProvider, createMockSigner } from './test-utils.js';
describe('Synapse', () => {
    let mockProvider;
    let mockSigner;
    beforeEach(() => {
        mockProvider = createMockProvider();
        mockSigner = createMockSigner('0x1234567890123456789012345678901234567890', mockProvider);
    });
    describe('Instantiation', () => {
        it('should create instance with signer', async () => {
            const synapse = await Synapse.create({ signer: mockSigner });
            assert.exists(synapse);
            assert.exists(synapse.payments);
            assert.isTrue(synapse.payments instanceof SynapsePayments);
        });
        it('should create instance with provider', async () => {
            const synapse = await Synapse.create({ provider: mockProvider });
            assert.exists(synapse);
            assert.exists(synapse.payments);
            assert.isTrue(synapse.payments instanceof SynapsePayments);
        });
        it.skip('should create instance with private key', async () => {
        });
        it('should apply NonceManager by default', async () => {
            const synapse = await Synapse.create({ signer: mockSigner });
            assert.exists(synapse);
        });
        it('should allow disabling NonceManager', async () => {
            const synapse = await Synapse.create({ signer: mockSigner, disableNonceManager: true });
            assert.exists(synapse);
        });
        it('should allow enabling CDN', async () => {
            const synapse = await Synapse.create({ signer: mockSigner, withCDN: true });
            const storageService = await synapse.createStorage();
            assert.exists(storageService);
        });
        it('should reject when no authentication method provided', async () => {
            try {
                await Synapse.create({});
                assert.fail('Should have thrown');
            }
            catch (error) {
                assert.include(error.message, 'Must provide exactly one of');
            }
        });
        it('should reject when multiple authentication methods provided', async () => {
            try {
                await Synapse.create({
                    privateKey: '0x123',
                    provider: mockProvider,
                    rpcURL: 'https://example.com'
                });
                assert.fail('Should have thrown');
            }
            catch (error) {
                assert.include(error.message, 'Must provide exactly one of');
            }
        });
        it('should reject privateKey without rpcURL', async () => {
            try {
                await Synapse.create({
                    privateKey: '0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef'
                });
                assert.fail('Should have thrown');
            }
            catch (error) {
                assert.include(error.message, 'rpcURL is required when using privateKey');
            }
        });
    });
    describe('Network validation', () => {
        it('should reject unsupported networks', async () => {
            const unsupportedProvider = createMockProvider(999999);
            try {
                await Synapse.create({ provider: unsupportedProvider });
                assert.fail('Should have thrown for unsupported network');
            }
            catch (error) {
                assert.include(error.message, 'Unsupported network');
                assert.include(error.message, '999999');
            }
        });
        it('should accept calibration network', async () => {
            const calibrationProvider = createMockProvider(314159);
            const synapse = await Synapse.create({ provider: calibrationProvider });
            assert.exists(synapse);
        });
        it('should accept mainnet', async () => {
            const mainnetProvider = createMockProvider(314);
            const synapse = await Synapse.create({ provider: mainnetProvider });
            assert.exists(synapse);
        });
    });
    describe('createStorage', () => {
        it('should create storage service', async () => {
            const synapse = await Synapse.create({ signer: mockSigner });
            const storage = await synapse.createStorage();
            assert.exists(storage);
            assert.exists(storage.proofSetId);
            assert.exists(storage.storageProvider);
            assert.isFunction(storage.upload);
            assert.isFunction(storage.download);
            assert.isFunction(storage.delete);
        });
        it('should accept custom proofSetId', async () => {
            const synapse = await Synapse.create({ signer: mockSigner });
            const customProofSetId = 'custom_proof_set_123';
            const storage = await synapse.createStorage({ proofSetId: customProofSetId });
            assert.equal(storage.proofSetId, customProofSetId);
        });
        it('should accept custom storageProvider', async () => {
            const synapse = await Synapse.create({ signer: mockSigner });
            const customProvider = 'f099999';
            const storage = await synapse.createStorage({ storageProvider: customProvider });
            assert.equal(storage.storageProvider, customProvider);
        });
    });
    describe('Payment access', () => {
        it('should provide read-only access to payments', async () => {
            const synapse = await Synapse.create({ signer: mockSigner });
            assert.exists(synapse.payments);
            assert.isTrue(synapse.payments instanceof SynapsePayments);
            assert.isFunction(synapse.payments.walletBalance);
            assert.isFunction(synapse.payments.balance);
            assert.isFunction(synapse.payments.deposit);
            assert.isFunction(synapse.payments.withdraw);
            assert.isFunction(synapse.payments.decimals);
            const descriptor = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(synapse), 'payments');
            assert.exists(descriptor?.get);
            assert.notExists(descriptor?.set);
        });
    });
    describe('getPDPAuthHelper', () => {
        it('should return PDPAuthHelper instance', async () => {
            const synapse = await Synapse.create({ signer: mockSigner });
            const authHelper = synapse.getPDPAuthHelper();
            assert.exists(authHelper);
            assert.isFunction(authHelper.signCreateProofSet);
            assert.isFunction(authHelper.signAddRoots);
            assert.isFunction(authHelper.signScheduleRemovals);
            assert.isFunction(authHelper.signDeleteProofSet);
        });
        it('should cache PDPAuthHelper instance', async () => {
            const synapse = await Synapse.create({ signer: mockSigner });
            const authHelper1 = synapse.getPDPAuthHelper();
            const authHelper2 = synapse.getPDPAuthHelper();
            assert.strictEqual(authHelper1, authHelper2);
        });
        it('should throw for network without PDP service contract', async () => {
            const mainnetProvider = createMockProvider(314);
            const synapse = await Synapse.create({ provider: mainnetProvider });
            try {
                synapse.getPDPAuthHelper();
                assert.fail('Should have thrown');
            }
            catch (error) {
                assert.include(error.message, 'PDP service contract not deployed on mainnet');
            }
        });
    });
});
//# sourceMappingURL=synapse.test.js.map