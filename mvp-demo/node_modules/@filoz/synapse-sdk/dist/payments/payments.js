import { ethers } from 'ethers';
import { createError, CONTRACT_ADDRESSES, CONTRACT_ABIS, TOKENS } from '../utils/index.js';
export class SynapsePayments {
    _provider;
    _signer;
    _network;
    _disableNonceManager;
    _usdfcContract = null;
    _paymentsContract = null;
    static USDFC = TOKENS.USDFC;
    constructor(provider, signer, network, disableNonceManager) {
        this._provider = provider;
        this._signer = signer;
        this._network = network;
        this._disableNonceManager = disableNonceManager;
    }
    _getUsdfcContract() {
        if (this._usdfcContract == null) {
            const usdfcAddress = CONTRACT_ADDRESSES.USDFC[this._network];
            if (usdfcAddress == null) {
                throw new Error(`USDFC contract not deployed on ${this._network} network`);
            }
            this._usdfcContract = new ethers.Contract(usdfcAddress, CONTRACT_ABIS.ERC20, this._signer);
        }
        return this._usdfcContract;
    }
    _getPaymentsContract() {
        if (this._paymentsContract == null) {
            const paymentsAddress = CONTRACT_ADDRESSES.PAYMENTS[this._network];
            if (paymentsAddress == null || paymentsAddress === '') {
                throw new Error(`Payments contract not deployed on ${this._network} network. Currently only Calibration testnet is supported.`);
            }
            this._paymentsContract = new ethers.Contract(paymentsAddress, CONTRACT_ABIS.PAYMENTS, this._signer);
        }
        return this._paymentsContract;
    }
    async balance(token = SynapsePayments.USDFC) {
        if (token !== SynapsePayments.USDFC) {
            throw createError('SynapsePayments', 'payments contract balance check', `Token "${token}" is not supported. Currently only USDFC token is supported for payments contract balance queries.`);
        }
        const signerAddress = await this._signer.getAddress();
        const usdfcAddress = CONTRACT_ADDRESSES.USDFC[this._network];
        const paymentsContract = this._getPaymentsContract();
        let accountInfo;
        try {
            accountInfo = await paymentsContract.accounts(usdfcAddress, signerAddress);
        }
        catch (contractCallError) {
            throw createError('SynapsePayments', 'payments contract balance check', 'Failed to read account information from payments contract. This could indicate the contract is not properly deployed, the ABI is incorrect, or there are network connectivity issues.', contractCallError);
        }
        const [funds, lockedFunds] = accountInfo;
        const availableFunds = BigInt(funds) - BigInt(lockedFunds);
        return availableFunds;
    }
    async walletBalance(token) {
        if (token == null || token === TOKENS.FIL) {
            try {
                const address = await this._signer.getAddress();
                const balance = await this._provider.getBalance(address);
                return balance;
            }
            catch (error) {
                throw createError('SynapsePayments', 'wallet FIL balance check', 'Unable to retrieve FIL balance from wallet. This could be due to network connectivity issues, RPC endpoint problems, or wallet connection issues.', error);
            }
        }
        if (token === SynapsePayments.USDFC) {
            try {
                const address = await this._signer.getAddress();
                const usdfcContract = this._getUsdfcContract();
                const balance = await usdfcContract.balanceOf(address);
                return balance;
            }
            catch (error) {
                throw createError('SynapsePayments', 'wallet USDFC balance check', 'Unexpected error while checking USDFC token balance in wallet.', error);
            }
        }
        throw createError('SynapsePayments', 'wallet balance check', `Token "${token}" is not supported. Currently only USDFC token is supported for balance queries.`);
    }
    decimals(token = SynapsePayments.USDFC) {
        return 18;
    }
    async allowance(token, spender) {
        if (token !== SynapsePayments.USDFC) {
            throw createError('SynapsePayments', 'allowance', `Token "${token}" is not supported. Currently only USDFC token is supported.`);
        }
        const signerAddress = await this._signer.getAddress();
        const usdfcContract = this._getUsdfcContract();
        try {
            const currentAllowance = await usdfcContract.allowance(signerAddress, spender);
            return currentAllowance;
        }
        catch (error) {
            throw createError('SynapsePayments', 'allowance check', 'Failed to check token allowance. This could indicate network connectivity issues or an invalid spender address.', error);
        }
    }
    async approve(token, spender, amount) {
        if (token !== SynapsePayments.USDFC) {
            throw createError('SynapsePayments', 'approve', `Token "${token}" is not supported. Currently only USDFC token is supported.`);
        }
        const approveAmount = typeof amount === 'bigint' ? amount : BigInt(amount);
        if (approveAmount < 0n) {
            throw createError('SynapsePayments', 'approve', 'Approval amount cannot be negative');
        }
        const signerAddress = await this._signer.getAddress();
        const usdfcContract = this._getUsdfcContract();
        const txOptions = {};
        if (this._disableNonceManager) {
            const approvalNonce = await this._provider.getTransactionCount(signerAddress, 'pending');
            txOptions.nonce = approvalNonce;
        }
        try {
            const approveTx = await usdfcContract.approve(spender, approveAmount, txOptions);
            await approveTx.wait();
            return approveTx.hash;
        }
        catch (error) {
            throw createError('SynapsePayments', 'approve', `Failed to approve ${spender} to spend ${approveAmount.toString()} ${token}`, error);
        }
    }
    async approveService(service, rateAllowance, lockupAllowance, token = SynapsePayments.USDFC) {
        if (token !== SynapsePayments.USDFC) {
            throw createError('SynapsePayments', 'approveService', `Token "${token}" is not supported. Currently only USDFC token is supported.`);
        }
        const rateAllowanceBigint = typeof rateAllowance === 'bigint' ? rateAllowance : BigInt(rateAllowance);
        const lockupAllowanceBigint = typeof lockupAllowance === 'bigint' ? lockupAllowance : BigInt(lockupAllowance);
        if (rateAllowanceBigint < 0n || lockupAllowanceBigint < 0n) {
            throw createError('SynapsePayments', 'approveService', 'Allowance values cannot be negative');
        }
        const signerAddress = await this._signer.getAddress();
        const usdfcAddress = CONTRACT_ADDRESSES.USDFC[this._network];
        const paymentsContract = this._getPaymentsContract();
        const txOptions = {};
        if (this._disableNonceManager) {
            const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending');
            txOptions.nonce = currentNonce;
        }
        try {
            const approveTx = await paymentsContract.setOperatorApproval(usdfcAddress, service, true, rateAllowanceBigint, lockupAllowanceBigint, txOptions);
            await approveTx.wait();
            return approveTx.hash;
        }
        catch (error) {
            throw createError('SynapsePayments', 'approveService', `Failed to approve service ${service} as operator for ${token}`, error);
        }
    }
    async revokeService(service, token = SynapsePayments.USDFC) {
        if (token !== SynapsePayments.USDFC) {
            throw createError('SynapsePayments', 'revokeService', `Token "${token}" is not supported. Currently only USDFC token is supported.`);
        }
        const signerAddress = await this._signer.getAddress();
        const usdfcAddress = CONTRACT_ADDRESSES.USDFC[this._network];
        const paymentsContract = this._getPaymentsContract();
        const txOptions = {};
        if (this._disableNonceManager) {
            const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending');
            txOptions.nonce = currentNonce;
        }
        try {
            const revokeTx = await paymentsContract.setOperatorApproval(usdfcAddress, service, false, 0n, 0n, txOptions);
            await revokeTx.wait();
            return revokeTx.hash;
        }
        catch (error) {
            throw createError('SynapsePayments', 'revokeService', `Failed to revoke service ${service} as operator for ${token}`, error);
        }
    }
    async serviceApproval(service, token = SynapsePayments.USDFC) {
        if (token !== SynapsePayments.USDFC) {
            throw createError('SynapsePayments', 'serviceApproval', `Token "${token}" is not supported. Currently only USDFC token is supported.`);
        }
        const signerAddress = await this._signer.getAddress();
        const usdfcAddress = CONTRACT_ADDRESSES.USDFC[this._network];
        const paymentsContract = this._getPaymentsContract();
        try {
            const approval = await paymentsContract.operatorApprovals(usdfcAddress, signerAddress, service);
            return {
                isApproved: approval[0],
                rateAllowance: approval[1],
                lockupAllowance: approval[2],
                rateUsed: approval[3],
                lockupUsed: approval[4]
            };
        }
        catch (error) {
            throw createError('SynapsePayments', 'serviceApproval', `Failed to check service approval status for ${service}`, error);
        }
    }
    async deposit(amount, token = SynapsePayments.USDFC) {
        if (token !== SynapsePayments.USDFC) {
            throw createError('SynapsePayments', 'deposit', `Unsupported token: ${token}`);
        }
        const depositAmountBigint = typeof amount === 'bigint' ? amount : BigInt(amount);
        if (depositAmountBigint <= 0n) {
            throw createError('SynapsePayments', 'deposit', 'Invalid amount');
        }
        const signerAddress = await this._signer.getAddress();
        const usdfcAddress = CONTRACT_ADDRESSES.USDFC[this._network];
        const usdfcContract = this._getUsdfcContract();
        const paymentsContract = this._getPaymentsContract();
        const usdfcBalance = await usdfcContract.balanceOf(signerAddress);
        if (usdfcBalance < depositAmountBigint) {
            throw createError('SynapsePayments', 'deposit', `Insufficient USDFC: have ${BigInt(usdfcBalance).toString()}, need ${depositAmountBigint.toString()}`);
        }
        const paymentsAddress = CONTRACT_ADDRESSES.PAYMENTS[this._network];
        if (paymentsAddress == null) {
            throw createError('SynapsePayments', 'deposit', `Payments contract not deployed on ${this._network}`);
        }
        const currentAllowance = await this.allowance(token, paymentsAddress);
        if (currentAllowance < depositAmountBigint) {
            await this.approve(token, paymentsAddress, depositAmountBigint);
        }
        const accountInfo = await paymentsContract.accounts(usdfcAddress, signerAddress);
        const [, , frozen] = accountInfo;
        if (frozen === true) {
            throw createError('SynapsePayments', 'deposit', 'Account is frozen');
        }
        const txOptions = {};
        if (this._disableNonceManager) {
            const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending');
            txOptions.nonce = currentNonce;
        }
        const depositTx = await paymentsContract.deposit(usdfcAddress, signerAddress, depositAmountBigint, txOptions);
        await depositTx.wait();
        return depositTx.hash;
    }
    async withdraw(amount, token = SynapsePayments.USDFC) {
        if (token !== SynapsePayments.USDFC) {
            throw createError('SynapsePayments', 'withdraw', `Unsupported token: ${token}`);
        }
        const withdrawAmountBigint = typeof amount === 'bigint' ? amount : BigInt(amount);
        if (withdrawAmountBigint <= 0n) {
            throw createError('SynapsePayments', 'withdraw', 'Invalid amount');
        }
        const signerAddress = await this._signer.getAddress();
        const usdfcAddress = CONTRACT_ADDRESSES.USDFC[this._network];
        const paymentsContract = this._getPaymentsContract();
        const accountInfo = await paymentsContract.accounts(usdfcAddress, signerAddress);
        const [funds, lockedFunds, frozen] = accountInfo;
        const availableFunds = BigInt(funds) - BigInt(lockedFunds);
        if (frozen === true) {
            throw createError('SynapsePayments', 'withdraw', 'Account is frozen');
        }
        if (availableFunds < withdrawAmountBigint) {
            throw createError('SynapsePayments', 'withdraw', `Insufficient balance: have ${availableFunds.toString()}, need ${withdrawAmountBigint.toString()}`);
        }
        const txOptions = {};
        if (this._disableNonceManager) {
            const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending');
            txOptions.nonce = currentNonce;
        }
        const withdrawTx = await paymentsContract.withdraw(usdfcAddress, withdrawAmountBigint, txOptions);
        await withdrawTx.wait();
        return withdrawTx.hash;
    }
}
//# sourceMappingURL=payments.js.map